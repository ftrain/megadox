<!DOCTYPE html>

<html lang="" xml:lang="" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta charset="utf-8"/>
<meta content="pandoc" name="generator"/>
<meta content="width=device-width, initial-scale=1.0, user-scalable=yes" name="viewport"/>
<title>PDP-7 Unix: A Complete Reference</title>
<link href="../book-style.css" rel="stylesheet"/>
<style>
    /* Inline critical CSS for faster loading */
    body { font-family: "Palatino", Georgia, serif; }
    .book-nav {
      background: #2c3e50;
      color: white;
      padding: 0.75rem 1.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    }
    .book-nav a {
      color: white;
      text-decoration: none;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      transition: background 0.2s;
    }
    .book-nav a:hover { background: rgba(255,255,255,0.1); }
    .book-nav .nav-left { display: flex; gap: 1rem; align-items: center; }
    .book-nav .nav-right { display: flex; gap: 0.5rem; }
    .download-btn {
      background: #3498db;
      padding: 0.4rem 0.8rem;
      border-radius: 4px;
      font-size: 0.875rem;
      font-weight: 600;
    }
    .download-btn:hover { background: #2980b9; }
    .pdf-btn { background: #e74c3c; }
    .pdf-btn:hover { background: #c0392b; }
  </style>
</head>
<body>
<nav class="book-nav">
<div class="nav-left">
<a href="../index.html">‚Üê All Books</a>
<span style="opacity: 0.7;">|</span>
<span style="font-weight: 600;">PDP-7 Unix: A Complete
Reference</span>
</div>
<div class="nav-right">
<a class="download-btn" href="#" onclick="window.print(); return false;">üñ®Ô∏è Print</a>
<a class="download-btn pdf-btn" href="pdp7-unix-complete-reference.pdf">üìÑ Download PDF</a>
</div>
</nav>
<div class="book-container">
<nav class="toc-sidebar">
<button class="toc-toggle" onclick="toggleTOC()">üìñ Table of Contents</button>
<div class="toc-content" id="toc-content">
<div class="toc-title">PDP-7 Unix: A Complete Reference</div>
<div class="search-container">
<input class="search-input" id="search-input" placeholder="üîç Search..." type="text"/>
<div class="search-results" id="search-results"></div>
</div><nav id="TOC"><ul>
<li><details><summary><a href="#frontmatter" id="toc-frontmatter">Frontmatter</a></summary><ul>
<li><a href="#about-this-work" id="toc-about-this-work">About This
Work</a></li>
<li><a href="#purpose-and-scope" id="toc-purpose-and-scope">Purpose and
Scope</a></li>
<li><details><summary><a href="#how-to-read-this-book" id="toc-how-to-read-this-book">How
to Read This Book</a></summary><ul>
<li><a href="#for-the-curious-reader" id="toc-for-the-curious-reader"><span class="toc-section-number">0.0.1</span> For the Curious Reader</a></li>
<li><a href="#for-the-systems-programmer" id="toc-for-the-systems-programmer"><span class="toc-section-number">0.0.2</span> For the Systems
Programmer</a></li>
<li><a href="#for-the-programming-language-enthusiast" id="toc-for-the-programming-language-enthusiast"><span class="toc-section-number">0.0.3</span> For the Programming Language
Enthusiast</a></li>
<li><a href="#for-the-computer-historian" id="toc-for-the-computer-historian"><span class="toc-section-number">0.0.4</span> For the Computer
Historian</a></li>
<li><a href="#for-complete-mastery" id="toc-for-complete-mastery"><span class="toc-section-number">0.0.5</span> For Complete Mastery</a></li>
</ul></details></li>
<li><details><summary><a href="#conventions-used" id="toc-conventions-used">Conventions
Used</a></summary><ul>
<li><a href="#code-formatting" id="toc-code-formatting"><span class="toc-section-number">0.0.6</span> Code Formatting</a></li>
<li><a href="#cross-references" id="toc-cross-references"><span class="toc-section-number">0.0.7</span> Cross-References</a></li>
<li><a href="#octal-notation" id="toc-octal-notation"><span class="toc-section-number">0.0.8</span> Octal Notation</a></li>
<li><a href="#assembly-language-syntax" id="toc-assembly-language-syntax"><span class="toc-section-number">0.0.9</span> Assembly Language
Syntax</a></li>
</ul></details></li>
<li><a href="#acknowledgments" id="toc-acknowledgments">Acknowledgments</a></li>
<li><a href="#license-and-usage" id="toc-license-and-usage">License and
Usage</a></li>
<li><a href="#note-on-historical-accuracy" id="toc-note-on-historical-accuracy">Note on Historical
Accuracy</a></li>
<li><a href="#version-information" id="toc-version-information">Version
Information</a></li>
</ul></details></li>
<li><details><summary><a href="#introduction-and-historical-context" id="toc-introduction-and-historical-context"><span class="toc-section-number">1</span> Introduction and Historical
Context</a></summary><ul>
<li><details><summary><a href="#the-birth-of-unix" id="toc-the-birth-of-unix"><span class="toc-section-number">1.1</span> The Birth of Unix</a></summary><ul>
<li><a href="#the-multics-withdrawal" id="toc-the-multics-withdrawal"><span class="toc-section-number">1.1.1</span> The Multics Withdrawal</a></li>
<li><a href="#space-travel-and-the-search-for-a-computer" id="toc-space-travel-and-the-search-for-a-computer"><span class="toc-section-number">1.1.2</span> Space Travel and the Search for
a Computer</a></li>
<li><a href="#from-game-to-operating-system" id="toc-from-game-to-operating-system"><span class="toc-section-number">1.1.3</span> From Game to Operating
System</a></li>
<li><a href="#the-four-week-creation" id="toc-the-four-week-creation"><span class="toc-section-number">1.1.4</span> The Four-Week Creation</a></li>
<li><a href="#why-unix" id="toc-why-unix"><span class="toc-section-number">1.1.5</span> Why ‚ÄúUnix‚Äù?</a></li>
</ul></details></li>
<li><details><summary><a href="#the-pdp-7-environment" id="toc-the-pdp-7-environment"><span class="toc-section-number">1.2</span> The PDP-7 Environment</a></summary><ul>
<li><a href="#why-this-machine-mattered" id="toc-why-this-machine-mattered"><span class="toc-section-number">1.2.1</span> Why This Machine
Mattered</a></li>
<li><a href="#the-development-environment" id="toc-the-development-environment"><span class="toc-section-number">1.2.2</span> The Development
Environment</a></li>
</ul></details></li>
<li><details><summary><a href="#the-source-code-we-have-today" id="toc-the-source-code-we-have-today"><span class="toc-section-number">1.3</span> The Source Code We Have Today</a></summary><ul>
<li><a href="#a-miraculous-preservation" id="toc-a-miraculous-preservation"><span class="toc-section-number">1.3.1</span> A Miraculous
Preservation</a></li>
<li><a href="#what-this-repository-represents" id="toc-what-this-repository-represents"><span class="toc-section-number">1.3.2</span> What This Repository
Represents</a></li>
</ul></details></li>
<li><details><summary><a href="#why-this-code-matters" id="toc-why-this-code-matters"><span class="toc-section-number">1.4</span> Why This Code Matters</a></summary><ul>
<li><a href="#historical-significance" id="toc-historical-significance"><span class="toc-section-number">1.4.1</span> Historical Significance</a></li>
<li><a href="#technical-significance" id="toc-technical-significance"><span class="toc-section-number">1.4.2</span> Technical Significance</a></li>
<li><a href="#cultural-impact" id="toc-cultural-impact"><span class="toc-section-number">1.4.3</span> Cultural Impact</a></li>
</ul></details></li>
<li><details><summary><a href="#the-evolution-path" id="toc-the-evolution-path"><span class="toc-section-number">1.5</span> The Evolution Path</a></summary><ul>
<li><a href="#from-pdp-7-to-pdp-11" id="toc-from-pdp-7-to-pdp-11"><span class="toc-section-number">1.5.1</span> From PDP-7 to PDP-11</a></li>
<li><a href="#the-invention-of-c" id="toc-the-invention-of-c"><span class="toc-section-number">1.5.2</span> The Invention of C</a></li>
<li><a href="#the-explosive-growth" id="toc-the-explosive-growth"><span class="toc-section-number">1.5.3</span> The Explosive Growth</a></li>
</ul></details></li>
<li><details><summary><a href="#reading-this-book-in-context" id="toc-reading-this-book-in-context"><span class="toc-section-number">1.6</span> Reading This Book in Context</a></summary><ul>
<li><a href="#what-youll-learn" id="toc-what-youll-learn"><span class="toc-section-number">1.6.1</span> What You‚Äôll Learn</a></li>
<li><a href="#what-makes-this-code-special" id="toc-what-makes-this-code-special"><span class="toc-section-number">1.6.2</span> What Makes This Code
Special</a></li>
<li><a href="#the-challenge-and-the-reward" id="toc-the-challenge-and-the-reward"><span class="toc-section-number">1.6.3</span> The Challenge and the
Reward</a></li>
</ul></details></li>
<li><details><summary><a href="#document-structure" id="toc-document-structure"><span class="toc-section-number">1.7</span> Document Structure</a></summary><ul>
<li><a href="#part-i-foundations-chapters-1-4" id="toc-part-i-foundations-chapters-1-4"><span class="toc-section-number">1.7.1</span> Part I: Foundations (Chapters
1-4)</a></li>
<li><a href="#part-ii-the-kernel-chapters-5-9" id="toc-part-ii-the-kernel-chapters-5-9"><span class="toc-section-number">1.7.2</span> Part II: The Kernel (Chapters
5-9)</a></li>
<li><a href="#part-iii-user-space-chapters-10-12" id="toc-part-iii-user-space-chapters-10-12"><span class="toc-section-number">1.7.3</span> Part III: User Space (Chapters
10-12)</a></li>
<li><a href="#part-iv-analysis-and-legacy-chapters-13-14" id="toc-part-iv-analysis-and-legacy-chapters-13-14"><span class="toc-section-number">1.7.4</span> Part IV: Analysis and Legacy
(Chapters 13-14)</a></li>
<li><a href="#appendices" id="toc-appendices"><span class="toc-section-number">1.7.5</span> Appendices</a></li>
</ul></details></li>
<li><a href="#begin-your-journey" id="toc-begin-your-journey"><span class="toc-section-number">1.8</span> Begin Your Journey</a></li>
</ul></details></li>
<li><details><summary><a href="#chapter-2-pdp-7-hardware-architecture" id="toc-chapter-2-pdp-7-hardware-architecture"><span class="toc-section-number">2</span> Chapter 2: PDP-7 Hardware
Architecture</a></summary><ul>
<li><a href="#introduction" id="toc-introduction"><span class="toc-section-number">2.1</span> Introduction</a></li>
<li><details><summary><a href="#cpu-architecture" id="toc-cpu-architecture"><span class="toc-section-number">2.2</span> 1. CPU Architecture</a></summary><ul>
<li><a href="#the-18-bit-word" id="toc-the-18-bit-word"><span class="toc-section-number">2.2.1</span> The 18-Bit Word</a></li>
<li><a href="#register-set" id="toc-register-set"><span class="toc-section-number">2.2.2</span> Register Set</a></li>
<li><a href="#auto-increment-registers" id="toc-auto-increment-registers"><span class="toc-section-number">2.2.3</span> Auto-Increment
Registers</a></li>
</ul></details></li>
<li><details><summary><a href="#instruction-set-architecture" id="toc-instruction-set-architecture"><span class="toc-section-number">2.3</span> 2. Instruction Set
Architecture</a></summary><ul>
<li><a href="#instruction-encoding-format" id="toc-instruction-encoding-format"><span class="toc-section-number">2.3.1</span> Instruction Encoding
Format</a></li>
<li><a href="#complete-16-instruction-set" id="toc-complete-16-instruction-set"><span class="toc-section-number">2.3.2</span> Complete 16-Instruction
Set</a></li>
<li><a href="#special-instructions" id="toc-special-instructions"><span class="toc-section-number">2.3.3</span> Special Instructions</a></li>
</ul></details></li>
<li><details><summary><a href="#addressing-modes" id="toc-addressing-modes"><span class="toc-section-number">2.4</span> 3. Addressing Modes</a></summary><ul>
<li><a href="#direct-addressing" id="toc-direct-addressing"><span class="toc-section-number">2.4.1</span> Direct Addressing</a></li>
<li><a href="#indirect-addressing" id="toc-indirect-addressing"><span class="toc-section-number">2.4.2</span> Indirect Addressing</a></li>
<li><a href="#auto-increment-addressing" id="toc-auto-increment-addressing"><span class="toc-section-number">2.4.3</span> Auto-Increment
Addressing</a></li>
<li><a href="#addressing-mode-comparison" id="toc-addressing-mode-comparison"><span class="toc-section-number">2.4.4</span> Addressing Mode
Comparison</a></li>
</ul></details></li>
<li><details><summary><a href="#memory-organization" id="toc-memory-organization"><span class="toc-section-number">2.5</span> 4. Memory Organization</a></summary><ul>
<li><a href="#memory-map" id="toc-memory-map"><span class="toc-section-number">2.5.1</span> Memory Map</a></li>
<li><a href="#special-memory-locations" id="toc-special-memory-locations"><span class="toc-section-number">2.5.2</span> Special Memory
Locations</a></li>
<li><a href="#word-vs.-byte-addressing" id="toc-word-vs.-byte-addressing"><span class="toc-section-number">2.5.3</span> Word vs.¬†Byte
Addressing</a></li>
<li><a href="#character-packing" id="toc-character-packing"><span class="toc-section-number">2.5.4</span> Character Packing</a></li>
<li><a href="#file-io-and-character-handling" id="toc-file-io-and-character-handling"><span class="toc-section-number">2.5.5</span> File I/O and Character
Handling</a></li>
</ul></details></li>
<li><details><summary><a href="#peripheral-devices" id="toc-peripheral-devices"><span class="toc-section-number">2.6</span> 5. Peripheral Devices</a></summary><ul>
<li><a href="#device-overview" id="toc-device-overview"><span class="toc-section-number">2.6.1</span> Device Overview</a></li>
<li><a href="#teletype-tty" id="toc-teletype-tty"><span class="toc-section-number">2.6.2</span> Teletype (TTY)</a></li>
<li><a href="#paper-tape-reader-and-punch" id="toc-paper-tape-reader-and-punch"><span class="toc-section-number">2.6.3</span> Paper Tape Reader and
Punch</a></li>
<li><a href="#dectape-mass-storage" id="toc-dectape-mass-storage"><span class="toc-section-number">2.6.4</span> DECtape (Mass Storage)</a></li>
<li><a href="#display-system-type-340" id="toc-display-system-type-340"><span class="toc-section-number">2.6.5</span> Display System (Type
340)</a></li>
<li><a href="#real-time-clock" id="toc-real-time-clock"><span class="toc-section-number">2.6.6</span> Real-Time Clock</a></li>
</ul></details></li>
<li><details><summary><a href="#io-architecture" id="toc-io-architecture"><span class="toc-section-number">2.7</span> 6. I/O Architecture</a></summary><ul>
<li><a href="#iot-inputoutput-transfer-instructions" id="toc-iot-inputoutput-transfer-instructions"><span class="toc-section-number">2.7.1</span> IOT (Input/Output Transfer)
Instructions</a></li>
<li><a href="#programmed-io" id="toc-programmed-io"><span class="toc-section-number">2.7.2</span> Programmed I/O</a></li>
<li><a href="#interrupt-driven-io" id="toc-interrupt-driven-io"><span class="toc-section-number">2.7.3</span> Interrupt-Driven I/O</a></li>
<li><a href="#data-transfer-mechanisms" id="toc-data-transfer-mechanisms"><span class="toc-section-number">2.7.4</span> Data Transfer
Mechanisms</a></li>
</ul></details></li>
<li><details><summary><a href="#technical-specifications" id="toc-technical-specifications"><span class="toc-section-number">2.8</span> 7. Technical Specifications</a></summary><ul>
<li><a href="#complete-hardware-specifications" id="toc-complete-hardware-specifications"><span class="toc-section-number">2.8.1</span> Complete Hardware
Specifications</a></li>
<li><a href="#performance-characteristics" id="toc-performance-characteristics"><span class="toc-section-number">2.8.2</span> Performance
Characteristics</a></li>
<li><a href="#memory-bandwidth" id="toc-memory-bandwidth"><span class="toc-section-number">2.8.3</span> Memory Bandwidth</a></li>
</ul></details></li>
<li><details><summary><a href="#assembly-language-syntax-1" id="toc-assembly-language-syntax-1"><span class="toc-section-number">2.9</span> 8. Assembly Language Syntax</a></summary><ul>
<li><a href="#octal-notation-1" id="toc-octal-notation-1"><span class="toc-section-number">2.9.1</span> Octal Notation</a></li>
<li><a href="#instruction-syntax" id="toc-instruction-syntax"><span class="toc-section-number">2.9.2</span> Instruction Syntax</a></li>
<li><a href="#labels-and-symbols" id="toc-labels-and-symbols"><span class="toc-section-number">2.9.3</span> Labels and Symbols</a></li>
<li><a href="#comments" id="toc-comments"><span class="toc-section-number">2.9.4</span> Comments</a></li>
<li><a href="#assembler-directives" id="toc-assembler-directives"><span class="toc-section-number">2.9.5</span> Assembler Directives</a></li>
</ul></details></li>
<li><details><summary><a href="#subroutine-linkage" id="toc-subroutine-linkage"><span class="toc-section-number">2.10</span> 9. Subroutine Linkage</a></summary><ul>
<li><a href="#jms-mechanism" id="toc-jms-mechanism"><span class="toc-section-number">2.10.1</span> JMS Mechanism</a></li>
<li><a href="#parameter-passing" id="toc-parameter-passing"><span class="toc-section-number">2.10.2</span> Parameter Passing</a></li>
<li><a href="#return-values" id="toc-return-values"><span class="toc-section-number">2.10.3</span> Return Values</a></li>
<li><a href="#non-reentrant-limitation" id="toc-non-reentrant-limitation"><span class="toc-section-number">2.10.4</span> Non-Reentrant
Limitation</a></li>
</ul></details></li>
<li><details><summary><a href="#hardware-constraints-and-their-impact-on-unix" id="toc-hardware-constraints-and-their-impact-on-unix"><span class="toc-section-number">2.11</span> 10. Hardware Constraints and
Their Impact on Unix</a></summary><ul>
<li><a href="#bit-architecture-impact" id="toc-bit-architecture-impact"><span class="toc-section-number">2.11.1</span> 18-Bit Architecture
Impact</a></li>
<li><a href="#memory-limitations" id="toc-memory-limitations"><span class="toc-section-number">2.11.2</span> Memory Limitations</a></li>
<li><a href="#io-limitations" id="toc-io-limitations"><span class="toc-section-number">2.11.3</span> I/O Limitations</a></li>
<li><a href="#performance-constraints" id="toc-performance-constraints"><span class="toc-section-number">2.11.4</span> Performance
Constraints</a></li>
<li><a href="#design-principles-emerging-from-constraints" id="toc-design-principles-emerging-from-constraints"><span class="toc-section-number">2.11.5</span> Design Principles Emerging from
Constraints</a></li>
</ul></details></li>
<li><a href="#conclusion" id="toc-conclusion"><span class="toc-section-number">2.12</span> Conclusion</a></li>
</ul></details></li>
<li><details><summary><a href="#chapter-3-assembly-language-and-programming" id="toc-chapter-3-assembly-language-and-programming"><span class="toc-section-number">3</span> Chapter 3: Assembly Language and
Programming</a></summary><ul>
<li><details><summary><a href="#introduction-1" id="toc-introduction-1"><span class="toc-section-number">3.1</span> Introduction</a></summary><ul>
<li><a href="#why-assembly-for-unix" id="toc-why-assembly-for-unix"><span class="toc-section-number">3.1.1</span> Why Assembly for Unix?</a></li>
<li><a href="#the-relationship-to-machine-code" id="toc-the-relationship-to-machine-code"><span class="toc-section-number">3.1.2</span> The Relationship to Machine
Code</a></li>
<li><a href="#the-unix-assembler-capabilities" id="toc-the-unix-assembler-capabilities"><span class="toc-section-number">3.1.3</span> The Unix Assembler
Capabilities</a></li>
<li><a href="#what-youll-learn-1" id="toc-what-youll-learn-1"><span class="toc-section-number">3.1.4</span> What You‚Äôll Learn</a></li>
</ul></details></li>
<li><details><summary><a href="#number-systems-and-notation" id="toc-number-systems-and-notation"><span class="toc-section-number">3.2</span> 1. Number Systems and Notation</a></summary><ul>
<li><a href="#why-octal-for-18-bit-words" id="toc-why-octal-for-18-bit-words"><span class="toc-section-number">3.2.1</span> Why Octal for 18-Bit
Words?</a></li>
<li><a href="#octal-digit-values" id="toc-octal-digit-values"><span class="toc-section-number">3.2.2</span> Octal Digit Values</a></li>
<li><a href="#converting-between-number-systems" id="toc-converting-between-number-systems"><span class="toc-section-number">3.2.3</span> Converting Between Number
Systems</a></li>
<li><a href="#common-octal-values-in-unix" id="toc-common-octal-values-in-unix"><span class="toc-section-number">3.2.4</span> Common Octal Values in
Unix</a></li>
<li><a href="#practice-exercises" id="toc-practice-exercises"><span class="toc-section-number">3.2.5</span> Practice Exercises</a></li>
<li><a href="#twos-complement-negative-numbers" id="toc-twos-complement-negative-numbers"><span class="toc-section-number">3.2.6</span> Two‚Äôs Complement Negative
Numbers</a></li>
</ul></details></li>
<li><details><summary><a href="#basic-instruction-tutorial" id="toc-basic-instruction-tutorial"><span class="toc-section-number">3.3</span> 2. Basic Instruction Tutorial</a></summary><ul>
<li><a href="#your-first-instruction-lac-load-ac" id="toc-your-first-instruction-lac-load-ac"><span class="toc-section-number">3.3.1</span> Your First Instruction: LAC
(Load AC)</a></li>
<li><a href="#dac-deposit-ac---storing-values" id="toc-dac-deposit-ac---storing-values"><span class="toc-section-number">3.3.2</span> DAC (Deposit AC) - Storing
Values</a></li>
<li><a href="#tad-twos-complement-add---addition" id="toc-tad-twos-complement-add---addition"><span class="toc-section-number">3.3.3</span> TAD (Two‚Äôs Complement Add) -
Addition</a></li>
<li><a href="#a-complete-example-increment-a-variable" id="toc-a-complete-example-increment-a-variable"><span class="toc-section-number">3.3.4</span> A Complete Example: Increment a
Variable</a></li>
<li><a href="#subtraction-using-twos-complement" id="toc-subtraction-using-twos-complement"><span class="toc-section-number">3.3.5</span> Subtraction Using Two‚Äôs
Complement</a></li>
<li><a href="#simple-arithmetic-examples" id="toc-simple-arithmetic-examples"><span class="toc-section-number">3.3.6</span> Simple Arithmetic
Examples</a></li>
<li><a href="#cla-clear-ac---starting-fresh" id="toc-cla-clear-ac---starting-fresh"><span class="toc-section-number">3.3.7</span> CLA (Clear AC) - Starting
Fresh</a></li>
<li><a href="#las-load-ac-with-switches---reading-input" id="toc-las-load-ac-with-switches---reading-input"><span class="toc-section-number">3.3.8</span> LAS (Load AC with Switches) -
Reading Input</a></li>
<li><a href="#practice-programs" id="toc-practice-programs"><span class="toc-section-number">3.3.9</span> Practice Programs</a></li>
</ul></details></li>
<li><details><summary><a href="#addressing-modes-in-practice" id="toc-addressing-modes-in-practice"><span class="toc-section-number">3.4</span> 3. Addressing Modes in
Practice</a></summary><ul>
<li><a href="#direct-addressing-default-mode" id="toc-direct-addressing-default-mode"><span class="toc-section-number">3.4.1</span> Direct Addressing (Default
Mode)</a></li>
<li><a href="#indirect-addressing-i-suffix" id="toc-indirect-addressing-i-suffix"><span class="toc-section-number">3.4.2</span> Indirect Addressing (i
Suffix)</a></li>
<li><a href="#law-load-address-word---loading-addresses" id="toc-law-load-address-word---loading-addresses"><span class="toc-section-number">3.4.3</span> LAW (Load Address Word) -
Loading Addresses</a></li>
<li><a href="#auto-increment-addressing-locations-8-15" id="toc-auto-increment-addressing-locations-8-15"><span class="toc-section-number">3.4.4</span> Auto-Increment Addressing
(Locations 8-15)</a></li>
<li><a href="#array-processing-with-auto-increment" id="toc-array-processing-with-auto-increment"><span class="toc-section-number">3.4.5</span> Array Processing with
Auto-Increment</a></li>
<li><a href="#two-pointers-array-copy" id="toc-two-pointers-array-copy"><span class="toc-section-number">3.4.6</span> Two Pointers: Array
Copy</a></li>
<li><a href="#when-to-use-each-mode" id="toc-when-to-use-each-mode"><span class="toc-section-number">3.4.7</span> When to Use Each Mode</a></li>
<li><a href="#all-eight-auto-increment-registers" id="toc-all-eight-auto-increment-registers"><span class="toc-section-number">3.4.8</span> All Eight Auto-Increment
Registers</a></li>
<li><a href="#real-unix-example-character-packing" id="toc-real-unix-example-character-packing"><span class="toc-section-number">3.4.9</span> Real Unix Example: Character
Packing</a></li>
</ul></details></li>
<li><details><summary><a href="#control-flow" id="toc-control-flow"><span class="toc-section-number">3.5</span> 4. Control Flow</a></summary><ul>
<li><a href="#unconditional-jump-jmp" id="toc-unconditional-jump-jmp"><span class="toc-section-number">3.5.1</span> Unconditional Jump: JMP</a></li>
<li><a href="#skip-instructions-building-conditional-logic" id="toc-skip-instructions-building-conditional-logic"><span class="toc-section-number">3.5.2</span> Skip Instructions: Building
Conditional Logic</a></li>
<li><a href="#conditional-execution-examples" id="toc-conditional-execution-examples"><span class="toc-section-number">3.5.3</span> Conditional Execution
Examples</a></li>
<li><a href="#sad-skip-if-ac-different---comparison" id="toc-sad-skip-if-ac-different---comparison"><span class="toc-section-number">3.5.4</span> SAD (Skip if AC Different) -
Comparison</a></li>
<li><a href="#skp-skip-unconditionally" id="toc-skp-skip-unconditionally"><span class="toc-section-number">3.5.5</span> SKP (Skip
Unconditionally)</a></li>
<li><a href="#isz-increment-and-skip-if-zero---counting-loops" id="toc-isz-increment-and-skip-if-zero---counting-loops"><span class="toc-section-number">3.5.6</span> ISZ (Increment and Skip if Zero)
- Counting Loops</a></li>
<li><a href="#complete-loop-examples" id="toc-complete-loop-examples"><span class="toc-section-number">3.5.7</span> Complete Loop Examples</a></li>
<li><a href="#dzm-deposit-zero-to-memory---efficient-clearing" id="toc-dzm-deposit-zero-to-memory---efficient-clearing"><span class="toc-section-number">3.5.8</span> DZM (Deposit Zero to Memory) -
Efficient Clearing</a></li>
<li><a href="#jms-jump-to-subroutine---function-calls" id="toc-jms-jump-to-subroutine---function-calls"><span class="toc-section-number">3.5.9</span> JMS (Jump to Subroutine) -
Function Calls</a></li>
<li><a href="#subroutine-examples" id="toc-subroutine-examples"><span class="toc-section-number">3.5.10</span> Subroutine Examples</a></li>
</ul></details></li>
<li><details><summary><a href="#data-structures" id="toc-data-structures"><span class="toc-section-number">3.6</span> 5. Data Structures</a></summary><ul>
<li><a href="#constants" id="toc-constants"><span class="toc-section-number">3.6.1</span> Constants</a></li>
<li><a href="#single-word-variables" id="toc-single-word-variables"><span class="toc-section-number">3.6.2</span> Single-Word Variables</a></li>
<li><a href="#arrays-sequential-storage" id="toc-arrays-sequential-storage"><span class="toc-section-number">3.6.3</span> Arrays (Sequential
Storage)</a></li>
<li><a href="#structures-grouped-data" id="toc-structures-grouped-data"><span class="toc-section-number">3.6.4</span> Structures (Grouped
Data)</a></li>
<li><a href="#character-strings-packed" id="toc-character-strings-packed"><span class="toc-section-number">3.6.5</span> Character Strings
(Packed)</a></li>
<li><a href="#linked-lists-advanced" id="toc-linked-lists-advanced"><span class="toc-section-number">3.6.6</span> Linked Lists (Advanced)</a></li>
</ul></details></li>
<li><details><summary><a href="#advanced-techniques" id="toc-advanced-techniques"><span class="toc-section-number">3.7</span> 6. Advanced Techniques</a></summary><ul>
<li><a href="#multi-precision-arithmetic" id="toc-multi-precision-arithmetic"><span class="toc-section-number">3.7.1</span> Multi-Precision
Arithmetic</a></li>
<li><a href="#multiplication-by-shifting" id="toc-multiplication-by-shifting"><span class="toc-section-number">3.7.2</span> Multiplication by
Shifting</a></li>
<li><a href="#bit-manipulation" id="toc-bit-manipulation"><span class="toc-section-number">3.7.3</span> Bit Manipulation</a></li>
<li><a href="#rotate-operations" id="toc-rotate-operations"><span class="toc-section-number">3.7.4</span> Rotate Operations</a></li>
<li><a href="#optimized-character-handling" id="toc-optimized-character-handling"><span class="toc-section-number">3.7.5</span> Optimized Character
Handling</a></li>
<li><a href="#loop-unrolling-for-performance" id="toc-loop-unrolling-for-performance"><span class="toc-section-number">3.7.6</span> Loop Unrolling for
Performance</a></li>
</ul></details></li>
<li><details><summary><a href="#the-unix-assembler" id="toc-the-unix-assembler"><span class="toc-section-number">3.8</span> 7. The Unix Assembler</a></summary><ul>
<li><a href="#two-pass-assembly-process" id="toc-two-pass-assembly-process"><span class="toc-section-number">3.8.1</span> Two-Pass Assembly
Process</a></li>
<li><a href="#symbol-table" id="toc-symbol-table"><span class="toc-section-number">3.8.2</span> Symbol Table</a></li>
<li><a href="#forward-and-backward-references" id="toc-forward-and-backward-references"><span class="toc-section-number">3.8.3</span> Forward and Backward
References</a></li>
<li><a href="#expression-evaluation" id="toc-expression-evaluation"><span class="toc-section-number">3.8.4</span> Expression Evaluation</a></li>
<li><a href="#assembler-directives-1" id="toc-assembler-directives-1"><span class="toc-section-number">3.8.5</span> Assembler Directives</a></li>
<li><a href="#code-from-as.s" id="toc-code-from-as.s"><span class="toc-section-number">3.8.6</span> Code from as.s</a></li>
<li><a href="#macro-expansion-sys" id="toc-macro-expansion-sys"><span class="toc-section-number">3.8.7</span> Macro Expansion (sys)</a></li>
<li><a href="#linking-multiple-files" id="toc-linking-multiple-files"><span class="toc-section-number">3.8.8</span> Linking Multiple Files</a></li>
</ul></details></li>
<li><details><summary><a href="#calling-conventions" id="toc-calling-conventions"><span class="toc-section-number">3.9</span> 8. Calling Conventions</a></summary><ul>
<li><a href="#parameter-passing-1" id="toc-parameter-passing-1"><span class="toc-section-number">3.9.1</span> Parameter Passing</a></li>
<li><a href="#return-values-1" id="toc-return-values-1"><span class="toc-section-number">3.9.2</span> Return Values</a></li>
<li><a href="#register-usage-conventions" id="toc-register-usage-conventions"><span class="toc-section-number">3.9.3</span> Register Usage
Conventions</a></li>
<li><a href="#library-function-example" id="toc-library-function-example"><span class="toc-section-number">3.9.4</span> Library Function
Example</a></li>
</ul></details></li>
<li><details><summary><a href="#system-call-interface" id="toc-system-call-interface"><span class="toc-section-number">3.10</span> 9. System Call Interface</a></summary><ul>
<li><a href="#the-sys-pseudo-operation" id="toc-the-sys-pseudo-operation"><span class="toc-section-number">3.10.1</span> The sys
Pseudo-Operation</a></li>
<li><a href="#system-call-conventions" id="toc-system-call-conventions"><span class="toc-section-number">3.10.2</span> System Call
Conventions</a></li>
<li><a href="#common-system-calls" id="toc-common-system-calls"><span class="toc-section-number">3.10.3</span> Common System Calls</a></li>
<li><a href="#error-handling" id="toc-error-handling"><span class="toc-section-number">3.10.4</span> Error Handling</a></li>
<li><a href="#complete-system-call-example" id="toc-complete-system-call-example"><span class="toc-section-number">3.10.5</span> Complete System Call
Example</a></li>
</ul></details></li>
<li><details><summary><a href="#complete-programs" id="toc-complete-programs"><span class="toc-section-number">3.11</span> 10. Complete Programs</a></summary><ul>
<li><a href="#program-1-character-counter" id="toc-program-1-character-counter"><span class="toc-section-number">3.11.1</span> Program 1: Character
Counter</a></li>
<li><a href="#program-2-file-copier-cp" id="toc-program-2-file-copier-cp"><span class="toc-section-number">3.11.2</span> Program 2: File Copier
(cp)</a></li>
<li><a href="#program-3-line-counter-wc--l" id="toc-program-3-line-counter-wc--l"><span class="toc-section-number">3.11.3</span> Program 3: Line Counter (wc
-l)</a></li>
<li><a href="#program-4-simple-grep-search" id="toc-program-4-simple-grep-search"><span class="toc-section-number">3.11.4</span> Program 4: Simple grep
(Search)</a></li>
</ul></details></li>
<li><details><summary><a href="#debugging-assembly-code" id="toc-debugging-assembly-code"><span class="toc-section-number">3.12</span> 11. Debugging Assembly Code</a></summary><ul>
<li><a href="#using-db.s-the-debugger" id="toc-using-db.s-the-debugger"><span class="toc-section-number">3.12.1</span> Using db.s (The
Debugger)</a></li>
<li><a href="#reading-core-dumps" id="toc-reading-core-dumps"><span class="toc-section-number">3.12.2</span> Reading Core Dumps</a></li>
<li><a href="#common-assembly-errors" id="toc-common-assembly-errors"><span class="toc-section-number">3.12.3</span> Common Assembly Errors</a></li>
<li><a href="#debugging-strategies" id="toc-debugging-strategies"><span class="toc-section-number">3.12.4</span> Debugging Strategies</a></li>
</ul></details></li>
<li><details><summary><a href="#practical-tips-and-best-practices" id="toc-practical-tips-and-best-practices"><span class="toc-section-number">3.13</span> 12. Practical Tips and Best
Practices</a></summary><ul>
<li><a href="#code-organization" id="toc-code-organization"><span class="toc-section-number">3.13.1</span> Code Organization</a></li>
<li><a href="#performance-optimization" id="toc-performance-optimization"><span class="toc-section-number">3.13.2</span> Performance
Optimization</a></li>
<li><a href="#memory-conservation" id="toc-memory-conservation"><span class="toc-section-number">3.13.3</span> Memory Conservation</a></li>
<li><a href="#documentation" id="toc-documentation"><span class="toc-section-number">3.13.4</span> Documentation</a></li>
</ul></details></li>
<li><a href="#summary" id="toc-summary"><span class="toc-section-number">3.14</span> Summary</a></li>
</ul></details></li>
<li><details><summary><a href="#chapter-4---system-architecture-overview" id="toc-chapter-4---system-architecture-overview"><span class="toc-section-number">4</span> Chapter 4 - System Architecture
Overview</a></summary><ul>
<li><details><summary><a href="#the-big-picture" id="toc-the-big-picture"><span class="toc-section-number">4.1</span> 1. The Big Picture</a></summary><ul>
<li><a href="#system-components-diagram" id="toc-system-components-diagram"><span class="toc-section-number">4.1.1</span> System Components
Diagram</a></li>
<li><a href="#data-flow-example-reading-a-file" id="toc-data-flow-example-reading-a-file"><span class="toc-section-number">4.1.2</span> Data Flow Example: Reading a
File</a></li>
</ul></details></li>
<li><details><summary><a href="#kernel-organization" id="toc-kernel-organization"><span class="toc-section-number">4.2</span> 2. Kernel Organization</a></summary><ul>
<li><a href="#module-responsibilities" id="toc-module-responsibilities"><span class="toc-section-number">4.2.1</span> Module Responsibilities</a></li>
<li><a href="#detailed-module-descriptions" id="toc-detailed-module-descriptions"><span class="toc-section-number">4.2.2</span> Detailed Module
Descriptions</a></li>
<li><a href="#why-s1-through-s9" id="toc-why-s1-through-s9"><span class="toc-section-number">4.2.3</span> Why s1 through s9?</a></li>
</ul></details></li>
<li><details><summary><a href="#system-calls-overview" id="toc-system-calls-overview"><span class="toc-section-number">4.3</span> 3. System Calls Overview</a></summary><ul>
<li><a href="#complete-system-call-reference" id="toc-complete-system-call-reference"><span class="toc-section-number">4.3.1</span> Complete System Call
Reference</a></li>
<li><a href="#system-call-categories" id="toc-system-call-categories"><span class="toc-section-number">4.3.2</span> System Call Categories</a></li>
<li><a href="#calling-convention" id="toc-calling-convention"><span class="toc-section-number">4.3.3</span> Calling Convention</a></li>
</ul></details></li>
<li><details><summary><a href="#file-system-architecture" id="toc-file-system-architecture"><span class="toc-section-number">4.4</span> 4. File System Architecture</a></summary><ul>
<li><a href="#high-level-design" id="toc-high-level-design"><span class="toc-section-number">4.4.1</span> High-Level Design</a></li>
<li><a href="#disk-layout" id="toc-disk-layout"><span class="toc-section-number">4.4.2</span> Disk Layout</a></li>
<li><a href="#inode-structure" id="toc-inode-structure"><span class="toc-section-number">4.4.3</span> Inode Structure</a></li>
<li><a href="#directory-structure" id="toc-directory-structure"><span class="toc-section-number">4.4.4</span> Directory Structure</a></li>
<li><a href="#free-block-management" id="toc-free-block-management"><span class="toc-section-number">4.4.5</span> Free Block Management</a></li>
<li><a href="#example-storing-a-200-word-file" id="toc-example-storing-a-200-word-file"><span class="toc-section-number">4.4.6</span> Example: Storing a 200-Word
File</a></li>
</ul></details></li>
<li><details><summary><a href="#process-model" id="toc-process-model"><span class="toc-section-number">4.5</span> 5. Process Model</a></summary><ul>
<li><a href="#process-table-structure" id="toc-process-table-structure"><span class="toc-section-number">4.5.1</span> Process Table Structure</a></li>
<li><a href="#user-data-structure" id="toc-user-data-structure"><span class="toc-section-number">4.5.2</span> User Data Structure</a></li>
<li><a href="#process-states" id="toc-process-states"><span class="toc-section-number">4.5.3</span> Process States</a></li>
<li><a href="#swapping-mechanism" id="toc-swapping-mechanism"><span class="toc-section-number">4.5.4</span> Swapping Mechanism</a></li>
<li><a href="#process-lifecycle" id="toc-process-lifecycle"><span class="toc-section-number">4.5.5</span> Process Lifecycle</a></li>
</ul></details></li>
<li><details><summary><a href="#memory-map-1" id="toc-memory-map-1"><span class="toc-section-number">4.6</span> 6. Memory Map</a></summary><ul>
<li><a href="#complete-memory-layout" id="toc-complete-memory-layout"><span class="toc-section-number">4.6.1</span> Complete Memory Layout</a></li>
<li><a href="#kernel-memory-organization" id="toc-kernel-memory-organization"><span class="toc-section-number">4.6.2</span> Kernel Memory
Organization</a></li>
<li><a href="#user-memory-layout" id="toc-user-memory-layout"><span class="toc-section-number">4.6.3</span> User Memory Layout</a></li>
<li><a href="#special-memory-locations-1" id="toc-special-memory-locations-1"><span class="toc-section-number">4.6.4</span> Special Memory
Locations</a></li>
<li><a href="#memory-usage-analysis" id="toc-memory-usage-analysis"><span class="toc-section-number">4.6.5</span> Memory Usage Analysis</a></li>
</ul></details></li>
<li><details><summary><a href="#device-io-architecture" id="toc-device-io-architecture"><span class="toc-section-number">4.7</span> 7. Device I/O Architecture</a></summary><ul>
<li><a href="#device-list" id="toc-device-list"><span class="toc-section-number">4.7.1</span> Device List</a></li>
<li><a href="#character-vs.-block-devices" id="toc-character-vs.-block-devices"><span class="toc-section-number">4.7.2</span> Character vs.¬†Block
Devices</a></li>
<li><a href="#character-queue-implementation" id="toc-character-queue-implementation"><span class="toc-section-number">4.7.3</span> Character Queue
Implementation</a></li>
<li><a href="#buffering-strategy" id="toc-buffering-strategy"><span class="toc-section-number">4.7.4</span> Buffering Strategy</a></li>
<li><a href="#interrupt-handling-overview" id="toc-interrupt-handling-overview"><span class="toc-section-number">4.7.5</span> Interrupt Handling
Overview</a></li>
<li><a href="#device-specific-handlers" id="toc-device-specific-handlers"><span class="toc-section-number">4.7.6</span> Device-Specific
Handlers</a></li>
</ul></details></li>
<li><details><summary><a href="#boot-and-initialization" id="toc-boot-and-initialization"><span class="toc-section-number">4.8</span> 8. Boot and Initialization</a></summary><ul>
<li><a href="#cold-boot-sequence" id="toc-cold-boot-sequence"><span class="toc-section-number">4.8.1</span> Cold Boot Sequence</a></li>
<li><a href="#full-boot-flowchart" id="toc-full-boot-flowchart"><span class="toc-section-number">4.8.2</span> Full Boot Flowchart</a></li>
<li><a href="#installation-boot-s9.s-alternate-path" id="toc-installation-boot-s9.s-alternate-path"><span class="toc-section-number">4.8.3</span> Installation Boot (s9.s
alternate path)</a></li>
<li><a href="#shutdown-and-restart" id="toc-shutdown-and-restart"><span class="toc-section-number">4.8.4</span> Shutdown and Restart</a></li>
</ul></details></li>
<li><details><summary><a href="#data-structures-1" id="toc-data-structures-1"><span class="toc-section-number">4.9</span> 9. Data Structures</a></summary><ul>
<li><a href="#process-table-ulist" id="toc-process-table-ulist"><span class="toc-section-number">4.9.1</span> Process Table (ulist)</a></li>
<li><a href="#user-data-structure-userdata" id="toc-user-data-structure-userdata"><span class="toc-section-number">4.9.2</span> User Data Structure
(userdata)</a></li>
<li><a href="#inode-structure-1" id="toc-inode-structure-1"><span class="toc-section-number">4.9.3</span> Inode Structure</a></li>
<li><a href="#directory-entry-structure" id="toc-directory-entry-structure"><span class="toc-section-number">4.9.4</span> Directory Entry
Structure</a></li>
<li><a href="#file-descriptor-structure" id="toc-file-descriptor-structure"><span class="toc-section-number">4.9.5</span> File Descriptor
Structure</a></li>
<li><a href="#system-data-sysdata" id="toc-system-data-sysdata"><span class="toc-section-number">4.9.6</span> System Data (sysdata)</a></li>
<li><a href="#constants-and-manifests" id="toc-constants-and-manifests"><span class="toc-section-number">4.9.7</span> Constants and Manifests</a></li>
<li><a href="#memory-allocation-pattern" id="toc-memory-allocation-pattern"><span class="toc-section-number">4.9.8</span> Memory Allocation
Pattern</a></li>
</ul></details></li>
<li><details><summary><a href="#naming-conventions" id="toc-naming-conventions"><span class="toc-section-number">4.10</span> 10. Naming Conventions</a></summary><ul>
<li><a href="#why-s1-through-s9-1" id="toc-why-s1-through-s9-1"><span class="toc-section-number">4.10.1</span> Why s1 through s9?</a></li>
<li><a href="#symbol-naming-patterns" id="toc-symbol-naming-patterns"><span class="toc-section-number">4.10.2</span> Symbol Naming Patterns</a></li>
<li><a href="#label-naming" id="toc-label-naming"><span class="toc-section-number">4.10.3</span> Label Naming</a></li>
<li><a href="#octal-address-conventions" id="toc-octal-address-conventions"><span class="toc-section-number">4.10.4</span> Octal Address
Conventions</a></li>
<li><a href="#function-call-conventions" id="toc-function-call-conventions"><span class="toc-section-number">4.10.5</span> Function Call
Conventions</a></li>
<li><a href="#naming-evolution" id="toc-naming-evolution"><span class="toc-section-number">4.10.6</span> Naming Evolution</a></li>
</ul></details></li>
<li><details><summary><a href="#size-and-complexity-analysis" id="toc-size-and-complexity-analysis"><span class="toc-section-number">4.11</span> 11. Size and Complexity
Analysis</a></summary><ul>
<li><a href="#line-counts-by-module" id="toc-line-counts-by-module"><span class="toc-section-number">4.11.1</span> Line Counts by Module</a></li>
<li><a href="#functionality-density" id="toc-functionality-density"><span class="toc-section-number">4.11.2</span> Functionality Density</a></li>
<li><a href="#functionality-per-line-metrics" id="toc-functionality-per-line-metrics"><span class="toc-section-number">4.11.3</span> Functionality per Line
Metrics</a></li>
<li><a href="#comparison-with-modern-systems" id="toc-comparison-with-modern-systems"><span class="toc-section-number">4.11.4</span> Comparison with Modern
Systems</a></li>
<li><a href="#code-reuse-analysis" id="toc-code-reuse-analysis"><span class="toc-section-number">4.11.5</span> Code Reuse Analysis</a></li>
<li><a href="#complexity-metrics" id="toc-complexity-metrics"><span class="toc-section-number">4.11.6</span> Complexity Metrics</a></li>
</ul></details></li>
<li><details><summary><a href="#reading-map" id="toc-reading-map"><span class="toc-section-number">4.12</span> 12. Reading Map</a></summary><ul>
<li><a href="#what-to-read-first" id="toc-what-to-read-first"><span class="toc-section-number">4.12.1</span> What to Read First</a></li>
<li><a href="#dependencies-between-modules" id="toc-dependencies-between-modules"><span class="toc-section-number">4.12.2</span> Dependencies Between
Modules</a></li>
<li><a href="#cross-reference-table" id="toc-cross-reference-table"><span class="toc-section-number">4.12.3</span> Cross-Reference Table</a></li>
<li><a href="#reading-strategies" id="toc-reading-strategies"><span class="toc-section-number">4.12.4</span> Reading Strategies</a></li>
<li><a href="#common-confusion-points" id="toc-common-confusion-points"><span class="toc-section-number">4.12.5</span> Common Confusion
Points</a></li>
<li><a href="#recommended-reading-order" id="toc-recommended-reading-order"><span class="toc-section-number">4.12.6</span> Recommended Reading
Order</a></li>
</ul></details></li>
<li><a href="#conclusion-1" id="toc-conclusion-1"><span class="toc-section-number">4.13</span> Conclusion</a></li>
</ul></details></li>
<li><details><summary><a href="#boot-and-initialization-1" id="toc-boot-and-initialization-1"><span class="toc-section-number">5</span> Boot and Initialization</a></summary><ul>
<li><details><summary><a href="#the-cold-start-bringing-unix-to-life" id="toc-the-cold-start-bringing-unix-to-life"><span class="toc-section-number">5.1</span> The Cold Start: Bringing Unix to
Life</a></summary><ul>
<li><a href="#historical-context-bootstrapping-in-1969" id="toc-historical-context-bootstrapping-in-1969"><span class="toc-section-number">5.1.1</span> Historical Context:
Bootstrapping in 1969</a></li>
</ul></details></li>
<li><details><summary><a href="#the-cold-boot-process-s9.s" id="toc-the-cold-boot-process-s9.s"><span class="toc-section-number">5.2</span> 6.1 The Cold Boot Process
(s9.s)</a></summary><ul>
<li><a href="#stage-1-disk-initialization" id="toc-stage-1-disk-initialization"><span class="toc-section-number">5.2.1</span> Stage 1: Disk
Initialization</a></li>
<li><a href="#stage-2-reading-files-from-paper-tape" id="toc-stage-2-reading-files-from-paper-tape"><span class="toc-section-number">5.2.2</span> Stage 2: Reading Files from
Paper Tape</a></li>
<li><a href="#stage-3-jump-to-system" id="toc-stage-3-jump-to-system"><span class="toc-section-number">5.2.3</span> Stage 3: Jump to System</a></li>
</ul></details></li>
<li><a href="#the-warm-boot-process-s8.s-coldentry" id="toc-the-warm-boot-process-s8.s-coldentry"><span class="toc-section-number">5.3</span> 6.2 The Warm Boot Process (s8.s
coldentry)</a></li>
<li><details><summary><a href="#the-init-process-unixs-first-program" id="toc-the-init-process-unixs-first-program"><span class="toc-section-number">5.4</span> 6.3 The Init Process: Unix‚Äôs First
Program</a></summary><ul>
<li><a href="#forking-login-processes" id="toc-forking-login-processes"><span class="toc-section-number">5.4.1</span> Forking Login Processes</a></li>
<li><a href="#the-login-sequence" id="toc-the-login-sequence"><span class="toc-section-number">5.4.2</span> The Login Sequence</a></li>
<li><a href="#password-file-format" id="toc-password-file-format"><span class="toc-section-number">5.4.3</span> Password File Format</a></li>
<li><a href="#setting-user-context" id="toc-setting-user-context"><span class="toc-section-number">5.4.4</span> Setting User Context</a></li>
</ul></details></li>
<li><details><summary><a href="#memory-layout-during-boot" id="toc-memory-layout-during-boot"><span class="toc-section-number">5.5</span> 6.4 Memory Layout During Boot</a></summary><ul>
<li><a href="#t0-power-on" id="toc-t0-power-on"><span class="toc-section-number">5.5.1</span> T+0: Power On</a></li>
<li><a href="#t100ms-bootstrap-loaded" id="toc-t100ms-bootstrap-loaded"><span class="toc-section-number">5.5.2</span> T+100ms: Bootstrap
Loaded</a></li>
<li><a href="#t500ms-coldentry-running" id="toc-t500ms-coldentry-running"><span class="toc-section-number">5.5.3</span> T+500ms: Coldentry
Running</a></li>
<li><a href="#t5000ms-init-running" id="toc-t5000ms-init-running"><span class="toc-section-number">5.5.4</span> T+5000ms: Init Running</a></li>
<li><a href="#t10000ms-user-logged-in-shell-running" id="toc-t10000ms-user-logged-in-shell-running"><span class="toc-section-number">5.5.5</span> T+10000ms: User Logged In, Shell
Running</a></li>
</ul></details></li>
<li><details><summary><a href="#historical-context-boot-processes-in-1969" id="toc-historical-context-boot-processes-in-1969"><span class="toc-section-number">5.6</span> 6.5 Historical Context: Boot
Processes in 1969</a></summary><ul>
<li><a href="#other-systems-boot-processes" id="toc-other-systems-boot-processes"><span class="toc-section-number">5.6.1</span> Other Systems‚Äô Boot
Processes</a></li>
<li><a href="#what-made-pdp-7-unix-different" id="toc-what-made-pdp-7-unix-different"><span class="toc-section-number">5.6.2</span> What Made PDP-7 Unix
Different</a></li>
</ul></details></li>
<li><details><summary><a href="#the-evolution-of-unix-booting" id="toc-the-evolution-of-unix-booting"><span class="toc-section-number">5.7</span> 6.6 The Evolution of Unix
Booting</a></summary><ul>
<li><a href="#pdp-7-unix-1970" id="toc-pdp-7-unix-1970"><span class="toc-section-number">5.7.1</span> PDP-7 Unix (1970)</a></li>
<li><a href="#unix-v1-1971---pdp-11" id="toc-unix-v1-1971---pdp-11"><span class="toc-section-number">5.7.2</span> Unix V1 (1971) - PDP-11</a></li>
<li><a href="#unix-v6-1975---pdp-11" id="toc-unix-v6-1975---pdp-11"><span class="toc-section-number">5.7.3</span> Unix V6 (1975) - PDP-11</a></li>
<li><a href="#unix-v7-1979---pdp-11" id="toc-unix-v7-1979---pdp-11"><span class="toc-section-number">5.7.4</span> Unix V7 (1979) - PDP-11</a></li>
<li><a href="#modern-linux-2020s" id="toc-modern-linux-2020s"><span class="toc-section-number">5.7.5</span> Modern Linux (2020s)</a></li>
</ul></details></li>
<li><details><summary><a href="#clever-optimizations" id="toc-clever-optimizations"><span class="toc-section-number">5.8</span> 6.7 Clever Optimizations</a></summary><ul>
<li><a href="#re-entrance-guard" id="toc-re-entrance-guard"><span class="toc-section-number">5.8.1</span> Re-entrance Guard</a></li>
<li><a href="#single-track-system-data" id="toc-single-track-system-data"><span class="toc-section-number">5.8.2</span> Single-Track System
Data</a></li>
<li><a href="#shared-buffer-space" id="toc-shared-buffer-space"><span class="toc-section-number">5.8.3</span> Shared Buffer Space</a></li>
<li><a href="#init-as-inode-3" id="toc-init-as-inode-3"><span class="toc-section-number">5.8.4</span> Init as Inode 3</a></li>
</ul></details></li>
<li><details><summary><a href="#lessons-from-pdp-7-boot-process" id="toc-lessons-from-pdp-7-boot-process"><span class="toc-section-number">5.9</span> 6.8 Lessons from PDP-7 Boot
Process</a></summary><ul>
<li><a href="#design-principles" id="toc-design-principles"><span class="toc-section-number">5.9.1</span> Design Principles</a></li>
<li><a href="#modern-relevance" id="toc-modern-relevance"><span class="toc-section-number">5.9.2</span> Modern Relevance</a></li>
<li><a href="#what-we-lost" id="toc-what-we-lost"><span class="toc-section-number">5.9.3</span> What We Lost</a></li>
</ul></details></li>
<li><a href="#hands-on-tracing-a-complete-boot" id="toc-hands-on-tracing-a-complete-boot"><span class="toc-section-number">5.10</span> 6.9 Hands-On: Tracing a Complete
Boot</a></li>
<li><a href="#conclusion-2" id="toc-conclusion-2"><span class="toc-section-number">5.11</span> 6.10 Conclusion</a></li>
</ul></details></li>
<li><details><summary><a href="#chapter-7---file-system-implementation" id="toc-chapter-7---file-system-implementation"><span class="toc-section-number">6</span> Chapter 7 - File System
Implementation</a></summary><ul>
<li><details><summary><a href="#revolutionary-design" id="toc-revolutionary-design"><span class="toc-section-number">6.1</span> 7.1 Revolutionary Design</a></summary><ul>
<li><a href="#the-fundamental-innovation" id="toc-the-fundamental-innovation"><span class="toc-section-number">6.1.1</span> The Fundamental
Innovation</a></li>
<li><a href="#why-this-was-revolutionary" id="toc-why-this-was-revolutionary"><span class="toc-section-number">6.1.2</span> Why This Was
Revolutionary</a></li>
<li><a href="#comparison-with-contemporary-systems" id="toc-comparison-with-contemporary-systems"><span class="toc-section-number">6.1.3</span> Comparison with Contemporary
Systems</a></li>
</ul></details></li>
<li><details><summary><a href="#disk-layout-1" id="toc-disk-layout-1"><span class="toc-section-number">6.2</span> 7.2 Disk Layout</a></summary><ul>
<li><a href="#complete-disk-organization" id="toc-complete-disk-organization"><span class="toc-section-number">6.2.1</span> Complete Disk
Organization</a></li>
<li><a href="#detailed-memory-map-diagram" id="toc-detailed-memory-map-diagram"><span class="toc-section-number">6.2.2</span> Detailed Memory Map
Diagram</a></li>
<li><a href="#why-this-layout" id="toc-why-this-layout"><span class="toc-section-number">6.2.3</span> Why This Layout?</a></li>
<li><a href="#physical-block-addressing" id="toc-physical-block-addressing"><span class="toc-section-number">6.2.4</span> Physical Block
Addressing</a></li>
</ul></details></li>
<li><details><summary><a href="#inodes---the-heart-of-unix" id="toc-inodes---the-heart-of-unix"><span class="toc-section-number">6.3</span> 7.3 Inodes - The Heart of Unix</a></summary><ul>
<li><a href="#inode-structure-12-words" id="toc-inode-structure-12-words"><span class="toc-section-number">6.3.1</span> Inode Structure (12
Words)</a></li>
<li><a href="#field-by-field-analysis" id="toc-field-by-field-analysis"><span class="toc-section-number">6.3.2</span> Field-by-Field Analysis</a></li>
<li><a href="#complete-inode-code-analysis" id="toc-complete-inode-code-analysis"><span class="toc-section-number">6.3.3</span> Complete inode Code
Analysis</a></li>
<li><a href="#example-inode-a-text-file" id="toc-example-inode-a-text-file"><span class="toc-section-number">6.3.4</span> Example Inode: A Text
File</a></li>
</ul></details></li>
<li><details><summary><a href="#directories" id="toc-directories"><span class="toc-section-number">6.4</span> 7.4 Directories</a></summary><ul>
<li><a href="#directory-entry-structure-8-words" id="toc-directory-entry-structure-8-words"><span class="toc-section-number">6.4.1</span> Directory Entry Structure (8
Words)</a></li>
<li><a href="#filename-encoding" id="toc-filename-encoding"><span class="toc-section-number">6.4.2</span> Filename Encoding</a></li>
<li><a href="#example-directory-root-directory" id="toc-example-directory-root-directory"><span class="toc-section-number">6.4.3</span> Example Directory: Root
Directory ‚Äú/‚Äù</a></li>
<li><a href="#directory-operations-code" id="toc-directory-operations-code"><span class="toc-section-number">6.4.4</span> Directory Operations
Code</a></li>
</ul></details></li>
<li><details><summary><a href="#free-block-management-1" id="toc-free-block-management-1"><span class="toc-section-number">6.5</span> 7.5 Free Block Management</a></summary><ul>
<li><a href="#free-block-list-structure" id="toc-free-block-list-structure"><span class="toc-section-number">6.5.1</span> Free Block List
Structure</a></li>
<li><a href="#visual-representation" id="toc-visual-representation"><span class="toc-section-number">6.5.2</span> Visual Representation</a></li>
<li><a href="#allocation-algorithm-alloc" id="toc-allocation-algorithm-alloc"><span class="toc-section-number">6.5.3</span> Allocation Algorithm
(alloc)</a></li>
<li><a href="#free-algorithm-free" id="toc-free-algorithm-free"><span class="toc-section-number">6.5.4</span> Free Algorithm (free)</a></li>
<li><a href="#why-this-design" id="toc-why-this-design"><span class="toc-section-number">6.5.5</span> Why This Design?</a></li>
</ul></details></li>
<li><details><summary><a href="#file-operations" id="toc-file-operations"><span class="toc-section-number">6.6</span> 7.6 File Operations</a></summary><ul>
<li><a href="#open---opening-a-file" id="toc-open---opening-a-file"><span class="toc-section-number">6.6.1</span> 7.6.1 open - Opening a
File</a></li>
<li><a href="#read---reading-from-a-file" id="toc-read---reading-from-a-file"><span class="toc-section-number">6.6.2</span> 7.6.2 read - Reading from a
File</a></li>
<li><a href="#write---writing-to-a-file" id="toc-write---writing-to-a-file"><span class="toc-section-number">6.6.3</span> 7.6.3 write - Writing to a
File</a></li>
<li><a href="#creat---creating-a-file" id="toc-creat---creating-a-file"><span class="toc-section-number">6.6.4</span> 7.6.4 creat - Creating a
File</a></li>
<li><a href="#link---creating-hard-links" id="toc-link---creating-hard-links"><span class="toc-section-number">6.6.5</span> 7.6.5 link - Creating Hard
Links</a></li>
<li><a href="#unlink---removing-directory-entries" id="toc-unlink---removing-directory-entries"><span class="toc-section-number">6.6.6</span> 7.6.6 unlink - Removing
Directory Entries</a></li>
</ul></details></li>
<li><details><summary><a href="#path-name-lookup" id="toc-path-name-lookup"><span class="toc-section-number">6.7</span> 7.7 Path Name Lookup</a></summary><ul>
<li><a href="#namei-algorithm" id="toc-namei-algorithm"><span class="toc-section-number">6.7.1</span> namei Algorithm</a></li>
<li><a href="#execution-trace-opening-ddkenprog.s" id="toc-execution-trace-opening-ddkenprog.s"><span class="toc-section-number">6.7.2</span> Execution Trace: Opening
‚Äú/dd/ken/prog.s‚Äù</a></li>
</ul></details></li>
<li><details><summary><a href="#buffer-cache" id="toc-buffer-cache"><span class="toc-section-number">6.8</span> 7.8 Buffer Cache</a></summary><ul>
<li><a href="#buffer-cache-structure" id="toc-buffer-cache-structure"><span class="toc-section-number">6.8.1</span> Buffer Cache Structure</a></li>
<li><a href="#dskrd-with-caching" id="toc-dskrd-with-caching"><span class="toc-section-number">6.8.2</span> dskrd with Caching</a></li>
<li><a href="#performance-impact" id="toc-performance-impact"><span class="toc-section-number">6.8.3</span> Performance Impact</a></li>
</ul></details></li>
<li><details><summary><a href="#large-files" id="toc-large-files"><span class="toc-section-number">6.9</span> 7.9 Large Files</a></summary><ul>
<li><a href="#direct-vs.-indirect-blocks" id="toc-direct-vs.-indirect-blocks"><span class="toc-section-number">6.9.1</span> Direct vs.¬†Indirect
Blocks</a></li>
<li><a href="#maximum-file-size" id="toc-maximum-file-size"><span class="toc-section-number">6.9.2</span> Maximum File Size</a></li>
<li><a href="#implementation-get_block_addr" id="toc-implementation-get_block_addr"><span class="toc-section-number">6.9.3</span> Implementation:
get_block_addr</a></li>
</ul></details></li>
<li><details><summary><a href="#file-permissions" id="toc-file-permissions"><span class="toc-section-number">6.10</span> 7.10 File Permissions</a></summary><ul>
<li><a href="#permission-bit-layout" id="toc-permission-bit-layout"><span class="toc-section-number">6.10.1</span> Permission Bit Layout</a></li>
<li><a href="#permission-check-algorithm" id="toc-permission-check-algorithm"><span class="toc-section-number">6.10.2</span> Permission Check
Algorithm</a></li>
<li><a href="#setuid-implementation" id="toc-setuid-implementation"><span class="toc-section-number">6.10.3</span> Setuid Implementation</a></li>
</ul></details></li>
<li><details><summary><a href="#historical-context" id="toc-historical-context"><span class="toc-section-number">6.11</span> 7.11 Historical Context</a></summary><ul>
<li><a href="#file-systems" id="toc-file-systems"><span class="toc-section-number">6.11.1</span> 1969 File Systems</a></li>
<li><a href="#comparison-table" id="toc-comparison-table"><span class="toc-section-number">6.11.2</span> Comparison Table</a></li>
<li><a href="#influence-on-modern-file-systems" id="toc-influence-on-modern-file-systems"><span class="toc-section-number">6.11.3</span> Influence on Modern File
Systems</a></li>
<li><a href="#what-changed-what-didnt" id="toc-what-changed-what-didnt"><span class="toc-section-number">6.11.4</span> What Changed, What
Didn‚Äôt</a></li>
</ul></details></li>
<li><details><summary><a href="#complete-example-creating-and-reading-a-file" id="toc-complete-example-creating-and-reading-a-file"><span class="toc-section-number">6.12</span> 7.12 Complete Example: Creating
and Reading a File</a></summary><ul>
<li><a href="#scenario" id="toc-scenario"><span class="toc-section-number">6.12.1</span> Scenario</a></li>
<li><a href="#step-by-step-execution" id="toc-step-by-step-execution"><span class="toc-section-number">6.12.2</span> Step-by-Step Execution</a></li>
</ul></details></li>
<li><a href="#summary-1" id="toc-summary-1"><span class="toc-section-number">6.13</span> Summary</a></li>
</ul></details></li>
<li><details><summary><a href="#chapter-8---process-management" id="toc-chapter-8---process-management"><span class="toc-section-number">7</span> Chapter 8 - Process Management</a></summary><ul>
<li><details><summary><a href="#the-process-abstraction" id="toc-the-process-abstraction"><span class="toc-section-number">7.1</span> 8.1 The Process Abstraction</a></summary><ul>
<li><a href="#what-is-a-process-in-pdp-7-unix" id="toc-what-is-a-process-in-pdp-7-unix"><span class="toc-section-number">7.1.1</span> What is a Process in PDP-7
Unix?</a></li>
<li><a href="#the-revolutionary-concept-in-1969" id="toc-the-revolutionary-concept-in-1969"><span class="toc-section-number">7.1.2</span> The Revolutionary Concept in
1969</a></li>
<li><a href="#comparison-with-batch-jobs" id="toc-comparison-with-batch-jobs"><span class="toc-section-number">7.1.3</span> Comparison with Batch
Jobs</a></li>
</ul></details></li>
<li><details><summary><a href="#process-table" id="toc-process-table"><span class="toc-section-number">7.2</span> 8.2 Process Table</a></summary><ul>
<li><a href="#the-ulist-structure" id="toc-the-ulist-structure"><span class="toc-section-number">7.2.1</span> The ulist Structure</a></li>
<li><a href="#maximum-10-processes" id="toc-maximum-10-processes"><span class="toc-section-number">7.2.2</span> Maximum 10 Processes</a></li>
<li><a href="#the-state-field-2-bits" id="toc-the-state-field-2-bits"><span class="toc-section-number">7.2.3</span> The State Field (2
bits)</a></li>
<li><a href="#pid-allocation" id="toc-pid-allocation"><span class="toc-section-number">7.2.4</span> PID Allocation</a></li>
<li><a href="#complete-process-table-structure-analysis" id="toc-complete-process-table-structure-analysis"><span class="toc-section-number">7.2.5</span> Complete Process Table Structure
Analysis</a></li>
<li><a href="#finding-a-free-process-slot" id="toc-finding-a-free-process-slot"><span class="toc-section-number">7.2.6</span> Finding a Free Process
Slot</a></li>
</ul></details></li>
<li><details><summary><a href="#user-data-structure-1" id="toc-user-data-structure-1"><span class="toc-section-number">7.3</span> 8.3 User Data Structure</a></summary><ul>
<li><a href="#the-userdata-structure-64-words" id="toc-the-userdata-structure-64-words"><span class="toc-section-number">7.3.1</span> The userdata Structure (64
words)</a></li>
<li><a href="#saved-registers" id="toc-saved-registers"><span class="toc-section-number">7.3.2</span> Saved Registers</a></li>
<li><a href="#file-descriptors-30-slots" id="toc-file-descriptors-30-slots"><span class="toc-section-number">7.3.3</span> File Descriptors (30
slots)</a></li>
<li><a href="#current-directory" id="toc-current-directory"><span class="toc-section-number">7.3.4</span> Current Directory</a></li>
<li><a href="#uid-and-pid" id="toc-uid-and-pid"><span class="toc-section-number">7.3.5</span> UID and PID</a></li>
<li><a href="#full-code-walkthrough-saving-context" id="toc-full-code-walkthrough-saving-context"><span class="toc-section-number">7.3.6</span> Full Code Walkthrough: Saving
Context</a></li>
<li><a href="#restoring-context-on-return" id="toc-restoring-context-on-return"><span class="toc-section-number">7.3.7</span> Restoring Context on
Return</a></li>
<li><a href="#complete-memory-layout-of-userdata" id="toc-complete-memory-layout-of-userdata"><span class="toc-section-number">7.3.8</span> Complete Memory Layout of
userdata</a></li>
</ul></details></li>
<li><details><summary><a href="#process-states-1" id="toc-process-states-1"><span class="toc-section-number">7.4</span> 8.4 Process States</a></summary><ul>
<li><a href="#state-definitions" id="toc-state-definitions"><span class="toc-section-number">7.4.1</span> State Definitions</a></li>
<li><a href="#state-0-not-used-free-slot" id="toc-state-0-not-used-free-slot"><span class="toc-section-number">7.4.2</span> State 0: Not Used (Free
Slot)</a></li>
<li><a href="#state-1-in-memory-ready" id="toc-state-1-in-memory-ready"><span class="toc-section-number">7.4.3</span> State 1: In Memory,
Ready</a></li>
<li><a href="#state-2-in-memory-not-ready-blocked" id="toc-state-2-in-memory-not-ready-blocked"><span class="toc-section-number">7.4.4</span> State 2: In Memory, Not Ready
(Blocked)</a></li>
<li><a href="#state-3-on-disk-ready-swapped-out" id="toc-state-3-on-disk-ready-swapped-out"><span class="toc-section-number">7.4.5</span> State 3: On Disk, Ready (Swapped
Out)</a></li>
<li><a href="#state-transitions" id="toc-state-transitions"><span class="toc-section-number">7.4.6</span> State Transitions</a></li>
<li><a href="#state-checking-in-system-calls" id="toc-state-checking-in-system-calls"><span class="toc-section-number">7.4.7</span> State Checking in System
Calls</a></li>
<li><a href="#complete-state-example" id="toc-complete-state-example"><span class="toc-section-number">7.4.8</span> Complete State Example</a></li>
</ul></details></li>
<li><details><summary><a href="#process-creation---fork" id="toc-process-creation---fork"><span class="toc-section-number">7.5</span> 8.5 Process Creation - fork()</a></summary><ul>
<li><a href="#the-fork-concept" id="toc-the-fork-concept"><span class="toc-section-number">7.5.1</span> The fork() Concept</a></li>
<li><a href="#complete-fork-implementation" id="toc-complete-fork-implementation"><span class="toc-section-number">7.5.2</span> Complete fork()
Implementation</a></li>
<li><a href="#parentchild-relationship" id="toc-parentchild-relationship"><span class="toc-section-number">7.5.3</span> Parent/Child
Relationship</a></li>
<li><a href="#memory-copying-via-swapping" id="toc-memory-copying-via-swapping"><span class="toc-section-number">7.5.4</span> Memory Copying via
Swapping</a></li>
<li><a href="#process-table-setup" id="toc-process-table-setup"><span class="toc-section-number">7.5.5</span> Process Table Setup</a></li>
<li><a href="#return-value-difference" id="toc-return-value-difference"><span class="toc-section-number">7.5.6</span> Return Value Difference</a></li>
<li><a href="#full-annotated-fork-code-with-comments" id="toc-full-annotated-fork-code-with-comments"><span class="toc-section-number">7.5.7</span> Full Annotated fork() Code with
Comments</a></li>
<li><a href="#execution-trace-example" id="toc-execution-trace-example"><span class="toc-section-number">7.5.8</span> Execution Trace Example</a></li>
</ul></details></li>
<li><details><summary><a href="#process-termination---exit" id="toc-process-termination---exit"><span class="toc-section-number">7.6</span> 8.6 Process Termination -
exit()</a></summary><ul>
<li><a href="#what-exit-does" id="toc-what-exit-does"><span class="toc-section-number">7.6.1</span> What exit() Does</a></li>
<li><a href="#complete-exit-implementation" id="toc-complete-exit-implementation"><span class="toc-section-number">7.6.2</span> Complete exit()
Implementation</a></li>
<li><a href="#cleanup-operations" id="toc-cleanup-operations"><span class="toc-section-number">7.6.3</span> Cleanup Operations</a></li>
<li><a href="#message-to-parent" id="toc-message-to-parent"><span class="toc-section-number">7.6.4</span> Message to Parent</a></li>
<li><a href="#process-table-cleanup" id="toc-process-table-cleanup"><span class="toc-section-number">7.6.5</span> Process Table Cleanup</a></li>
<li><a href="#no-return-path" id="toc-no-return-path"><span class="toc-section-number">7.6.6</span> No Return Path</a></li>
<li><a href="#complete-execution-trace" id="toc-complete-execution-trace"><span class="toc-section-number">7.6.7</span> Complete Execution
Trace</a></li>
<li><a href="#orphaned-processes" id="toc-orphaned-processes"><span class="toc-section-number">7.6.8</span> Orphaned Processes</a></li>
</ul></details></li>
<li><details><summary><a href="#process-swapping" id="toc-process-swapping"><span class="toc-section-number">7.7</span> 8.7 Process Swapping</a></summary><ul>
<li><a href="#why-swapping" id="toc-why-swapping"><span class="toc-section-number">7.7.1</span> Why Swapping?</a></li>
<li><a href="#swap-algorithm-in-s1.s" id="toc-swap-algorithm-in-s1.s"><span class="toc-section-number">7.7.2</span> Swap Algorithm in s1.s</a></li>
<li><a href="#quantum-based-preemption" id="toc-quantum-based-preemption"><span class="toc-section-number">7.7.3</span> Quantum-Based
Preemption</a></li>
<li><a href="#disk-tracks-0600007000" id="toc-disk-tracks-0600007000"><span class="toc-section-number">7.7.4</span> Disk Tracks 06000/07000</a></li>
<li><a href="#complete-swapping-implementation" id="toc-complete-swapping-implementation"><span class="toc-section-number">7.7.5</span> Complete Swapping
Implementation</a></li>
<li><a href="#performance-analysis" id="toc-performance-analysis"><span class="toc-section-number">7.7.6</span> Performance Analysis</a></li>
<li><a href="#complete-execution-trace-1" id="toc-complete-execution-trace-1"><span class="toc-section-number">7.7.7</span> Complete Execution
Trace</a></li>
</ul></details></li>
<li><details><summary><a href="#scheduling" id="toc-scheduling"><span class="toc-section-number">7.8</span> 8.8 Scheduling</a></summary><ul>
<li><a href="#simple-round-robin" id="toc-simple-round-robin"><span class="toc-section-number">7.8.1</span> Simple Round-Robin</a></li>
<li><a href="#quantum-30-clock-ticks" id="toc-quantum-30-clock-ticks"><span class="toc-section-number">7.8.2</span> Quantum = 30 Clock
Ticks</a></li>
<li><a href="#no-priorities" id="toc-no-priorities"><span class="toc-section-number">7.8.3</span> No Priorities</a></li>
<li><a href="#the-lookfor-function---complete-code" id="toc-the-lookfor-function---complete-code"><span class="toc-section-number">7.8.4</span> The lookfor Function - Complete
Code</a></li>
<li><a href="#idle-loop" id="toc-idle-loop"><span class="toc-section-number">7.8.5</span> Idle Loop</a></li>
<li><a href="#complete-scheduling-example" id="toc-complete-scheduling-example"><span class="toc-section-number">7.8.6</span> Complete Scheduling
Example</a></li>
</ul></details></li>
<li><details><summary><a href="#inter-process-communication" id="toc-inter-process-communication"><span class="toc-section-number">7.9</span> 8.9 Inter-Process
Communication</a></summary><ul>
<li><a href="#smes---send-message" id="toc-smes---send-message"><span class="toc-section-number">7.9.1</span> smes - Send Message</a></li>
<li><a href="#rmes---receive-message-blocking" id="toc-rmes---receive-message-blocking"><span class="toc-section-number">7.9.2</span> rmes - Receive Message
(Blocking)</a></li>
<li><a href="#message-queue-structure" id="toc-message-queue-structure"><span class="toc-section-number">7.9.3</span> Message Queue Structure</a></li>
<li><a href="#use-in-init" id="toc-use-in-init"><span class="toc-section-number">7.9.4</span> Use in init</a></li>
<li><a href="#full-ipc-implementation" id="toc-full-ipc-implementation"><span class="toc-section-number">7.9.5</span> Full IPC Implementation</a></li>
<li><a href="#message-passing-execution-trace" id="toc-message-passing-execution-trace"><span class="toc-section-number">7.9.6</span> Message-Passing Execution
Trace</a></li>
</ul></details></li>
<li><details><summary><a href="#context-switching" id="toc-context-switching"><span class="toc-section-number">7.10</span> 8.10 Context Switching</a></summary><ul>
<li><a href="#saverestore-mechanism" id="toc-saverestore-mechanism"><span class="toc-section-number">7.10.1</span> Save/Restore Mechanism</a></li>
<li><a href="#register-preservation" id="toc-register-preservation"><span class="toc-section-number">7.10.2</span> Register Preservation</a></li>
<li><a href="#userkernel-mode-transition" id="toc-userkernel-mode-transition"><span class="toc-section-number">7.10.3</span> User/Kernel Mode
Transition</a></li>
<li><a href="#complete-code-analysis" id="toc-complete-code-analysis"><span class="toc-section-number">7.10.4</span> Complete Code Analysis</a></li>
<li><a href="#context-switch-timeline" id="toc-context-switch-timeline"><span class="toc-section-number">7.10.5</span> Context Switch
Timeline</a></li>
</ul></details></li>
<li><details><summary><a href="#the-complete-process-lifecycle" id="toc-the-complete-process-lifecycle"><span class="toc-section-number">7.11</span> 8.11 The Complete Process
Lifecycle</a></summary><ul>
<li><a href="#stage-0-before-fork" id="toc-stage-0-before-fork"><span class="toc-section-number">7.11.1</span> Stage 0: Before fork</a></li>
<li><a href="#stage-1-fork-called" id="toc-stage-1-fork-called"><span class="toc-section-number">7.11.2</span> Stage 1: Fork Called</a></li>
<li><a href="#stage-2-child-copied" id="toc-stage-2-child-copied"><span class="toc-section-number">7.11.3</span> Stage 2: Child Copied</a></li>
<li><a href="#stage-3-child-swapped-out" id="toc-stage-3-child-swapped-out"><span class="toc-section-number">7.11.4</span> Stage 3: Child Swapped
Out</a></li>
<li><a href="#stage-4-parent-returns" id="toc-stage-4-parent-returns"><span class="toc-section-number">7.11.5</span> Stage 4: Parent
Returns</a></li>
<li><a href="#stage-5-parent-waits" id="toc-stage-5-parent-waits"><span class="toc-section-number">7.11.6</span> Stage 5: Parent Waits</a></li>
<li><a href="#stage-6-child-scheduled" id="toc-stage-6-child-scheduled"><span class="toc-section-number">7.11.7</span> Stage 6: Child
Scheduled</a></li>
<li><a href="#stage-7-child-executes" id="toc-stage-7-child-executes"><span class="toc-section-number">7.11.8</span> Stage 7: Child
Executes</a></li>
<li><a href="#stage-8-child-exits" id="toc-stage-8-child-exits"><span class="toc-section-number">7.11.9</span> Stage 8: Child Exits</a></li>
<li><a href="#stage-9-parent-wakes" id="toc-stage-9-parent-wakes"><span class="toc-section-number">7.11.10</span> Stage 9: Parent Wakes</a></li>
<li><a href="#memory-diagrams-at-each-stage" id="toc-memory-diagrams-at-each-stage"><span class="toc-section-number">7.11.11</span> Memory Diagrams at Each
Stage</a></li>
<li><a href="#process-table-state-transitions" id="toc-process-table-state-transitions"><span class="toc-section-number">7.11.12</span> Process Table State
Transitions</a></li>
</ul></details></li>
<li><details><summary><a href="#historical-context-1" id="toc-historical-context-1"><span class="toc-section-number">7.12</span> 8.12 Historical Context</a></summary><ul>
<li><a href="#multiprogramming-in-1969" id="toc-multiprogramming-in-1969"><span class="toc-section-number">7.12.1</span> Multiprogramming in
1969</a></li>
<li><a href="#pdp-7-unix-process-management-compared" id="toc-pdp-7-unix-process-management-compared"><span class="toc-section-number">7.12.2</span> PDP-7 Unix Process Management
Compared</a></li>
<li><a href="#how-unix-differed" id="toc-how-unix-differed"><span class="toc-section-number">7.12.3</span> How Unix Differed</a></li>
<li><a href="#influence-on-modern-operating-systems" id="toc-influence-on-modern-operating-systems"><span class="toc-section-number">7.12.4</span> Influence on Modern Operating
Systems</a></li>
<li><a href="#the-genius-of-simplicity" id="toc-the-genius-of-simplicity"><span class="toc-section-number">7.12.5</span> The Genius of
Simplicity</a></li>
</ul></details></li>
<li><a href="#summary-2" id="toc-summary-2"><span class="toc-section-number">7.13</span> Summary</a></li>
</ul></details></li>
<li><details><summary><a href="#chapter-10---development-tools-building-a-self-hosting-system" id="toc-chapter-10---development-tools-building-a-self-hosting-system"><span class="toc-section-number">8</span> Chapter 10 - Development Tools:
Building a Self-Hosting System</a></summary><ul>
<li><details><summary><a href="#the-self-hosting-achievement" id="toc-the-self-hosting-achievement"><span class="toc-section-number">8.1</span> 10.1 The Self-Hosting
Achievement</a></summary><ul>
<li><a href="#what-self-hosting-means" id="toc-what-self-hosting-means"><span class="toc-section-number">8.1.1</span> What Self-Hosting Means</a></li>
<li><a href="#why-it-was-revolutionary-in-1969" id="toc-why-it-was-revolutionary-in-1969"><span class="toc-section-number">8.1.2</span> Why It Was Revolutionary in
1969</a></li>
<li><a href="#industry-context-other-systems-in-1969" id="toc-industry-context-other-systems-in-1969"><span class="toc-section-number">8.1.3</span> Industry Context: Other Systems
in 1969</a></li>
<li><a href="#the-virtuous-cycle-better-tools-enable-better-tools" id="toc-the-virtuous-cycle-better-tools-enable-better-tools"><span class="toc-section-number">8.1.4</span> The Virtuous Cycle: Better Tools
Enable Better Tools</a></li>
</ul></details></li>
<li><details><summary><a href="#the-assembler-as.s" id="toc-the-assembler-as.s"><span class="toc-section-number">8.2</span> 10.2 The Assembler (as.s)</a></summary><ul>
<li><a href="#complete-two-pass-assembly-algorithm" id="toc-complete-two-pass-assembly-algorithm"><span class="toc-section-number">8.2.1</span> Complete Two-Pass Assembly
Algorithm</a></li>
<li><a href="#main-assembly-loop" id="toc-main-assembly-loop"><span class="toc-section-number">8.2.2</span> Main Assembly Loop</a></li>
<li><a href="#symbol-table-implementation" id="toc-symbol-table-implementation"><span class="toc-section-number">8.2.3</span> Symbol Table
Implementation</a></li>
<li><a href="#character-packing-getsc-and-putsc" id="toc-character-packing-getsc-and-putsc"><span class="toc-section-number">8.2.4</span> Character Packing: getsc and
putsc</a></li>
<li><a href="#expression-evaluation-1" id="toc-expression-evaluation-1"><span class="toc-section-number">8.2.5</span> Expression Evaluation</a></li>
<li><a href="#forward-and-backward-references-1" id="toc-forward-and-backward-references-1"><span class="toc-section-number">8.2.6</span> Forward and Backward
References</a></li>
<li><a href="#object-file-format" id="toc-object-file-format"><span class="toc-section-number">8.2.7</span> Object File Format</a></li>
<li><a href="#historical-context-why-write-an-assembler-in-assembly" id="toc-historical-context-why-write-an-assembler-in-assembly"><span class="toc-section-number">8.2.8</span> Historical Context: Why Write an
Assembler in Assembly?</a></li>
<li><a href="#comparison-to-other-1969-assemblers" id="toc-comparison-to-other-1969-assemblers"><span class="toc-section-number">8.2.9</span> Comparison to Other 1969
Assemblers</a></li>
<li><a href="#complete-example-assembling-a-simple-program" id="toc-complete-example-assembling-a-simple-program"><span class="toc-section-number">8.2.10</span> Complete Example: Assembling a
Simple Program</a></li>
</ul></details></li>
<li><details><summary><a href="#the-editor-ed1.s-ed2.s" id="toc-the-editor-ed1.s-ed2.s"><span class="toc-section-number">8.3</span> 10.3 The Editor (ed1.s +
ed2.s)</a></summary><ul>
<li><a href="#why-line-based-editing-in-1969" id="toc-why-line-based-editing-in-1969"><span class="toc-section-number">8.3.1</span> Why Line-Based Editing in
1969?</a></li>
<li><a href="#command-set-and-implementation" id="toc-command-set-and-implementation"><span class="toc-section-number">8.3.2</span> Command Set and
Implementation</a></li>
<li><a href="#the-append-command-adding-text" id="toc-the-append-command-adding-text"><span class="toc-section-number">8.3.3</span> The Append Command: Adding
Text</a></li>
<li><a href="#temporary-file-usage-the-disk-buffer" id="toc-temporary-file-usage-the-disk-buffer"><span class="toc-section-number">8.3.4</span> Temporary File Usage: The Disk
Buffer</a></li>
<li><a href="#search-and-substitution-algorithms" id="toc-search-and-substitution-algorithms"><span class="toc-section-number">8.3.5</span> Search and Substitution
Algorithms</a></li>
<li><a href="#pattern-compilation" id="toc-pattern-compilation"><span class="toc-section-number">8.3.6</span> Pattern Compilation</a></li>
<li><a href="#historical-context-what-editors-existed-in-1969" id="toc-historical-context-what-editors-existed-in-1969"><span class="toc-section-number">8.3.7</span> Historical Context: What Editors
Existed in 1969?</a></li>
<li><a href="#the-ed-legacy-modern-tools-descended-from-ed" id="toc-the-ed-legacy-modern-tools-descended-from-ed"><span class="toc-section-number">8.3.8</span> The Ed Legacy: Modern Tools
Descended from Ed</a></li>
</ul></details></li>
<li><details><summary><a href="#the-debugger-db.s" id="toc-the-debugger-db.s"><span class="toc-section-number">8.4</span> 10.4 The Debugger (db.s)</a></summary><ul>
<li><a href="#symbolic-debugging-concepts" id="toc-symbolic-debugging-concepts"><span class="toc-section-number">8.4.1</span> Symbolic Debugging
Concepts</a></li>
<li><a href="#core-dump-analysis" id="toc-core-dump-analysis"><span class="toc-section-number">8.4.2</span> Core Dump Analysis</a></li>
<li><a href="#memory-examination-modes" id="toc-memory-examination-modes"><span class="toc-section-number">8.4.3</span> Memory Examination
Modes</a></li>
<li><a href="#expression-evaluation-2" id="toc-expression-evaluation-2"><span class="toc-section-number">8.4.4</span> Expression Evaluation</a></li>
<li><a href="#complete-code-walkthrough-print-symbol" id="toc-complete-code-walkthrough-print-symbol"><span class="toc-section-number">8.4.5</span> Complete Code Walkthrough: Print
Symbol</a></li>
<li><a href="#why-debugging-was-so-hard-in-1969" id="toc-why-debugging-was-so-hard-in-1969"><span class="toc-section-number">8.4.6</span> Why Debugging Was So Hard in
1969</a></li>
<li><a href="#modern-debugging-tools-descended-from-db" id="toc-modern-debugging-tools-descended-from-db"><span class="toc-section-number">8.4.7</span> Modern Debugging Tools Descended
from db</a></li>
</ul></details></li>
<li><details><summary><a href="#the-loader-ald.s" id="toc-the-loader-ald.s"><span class="toc-section-number">8.5</span> 10.5 The Loader (ald.s)</a></summary><ul>
<li><a href="#card-reader-input-format" id="toc-card-reader-input-format"><span class="toc-section-number">8.5.1</span> Card Reader Input
Format</a></li>
<li><a href="#binary-format-parsing" id="toc-binary-format-parsing"><span class="toc-section-number">8.5.2</span> Binary Format Parsing</a></li>
<li><a href="#checksum-verification" id="toc-checksum-verification"><span class="toc-section-number">8.5.3</span> Checksum Verification</a></li>
<li><a href="#complete-implementation-analysis" id="toc-complete-implementation-analysis"><span class="toc-section-number">8.5.4</span> Complete Implementation
Analysis</a></li>
<li><a href="#physical-punched-cards-in-1969" id="toc-physical-punched-cards-in-1969"><span class="toc-section-number">8.5.5</span> Physical Punched Cards in
1969</a></li>
</ul></details></li>
<li><details><summary><a href="#the-development-workflow" id="toc-the-development-workflow"><span class="toc-section-number">8.6</span> 10.6 The Development Workflow</a></summary><ul>
<li><a href="#write-code-in-ed" id="toc-write-code-in-ed"><span class="toc-section-number">8.6.1</span> Write Code in ed</a></li>
<li><a href="#assemble-with-as" id="toc-assemble-with-as"><span class="toc-section-number">8.6.2</span> Assemble with as</a></li>
<li><a href="#test-and-debug" id="toc-test-and-debug"><span class="toc-section-number">8.6.3</span> Test and Debug</a></li>
<li><a href="#complete-example-workflow" id="toc-complete-example-workflow"><span class="toc-section-number">8.6.4</span> Complete Example
Workflow</a></li>
<li><a href="#comparison-to-modern-ides" id="toc-comparison-to-modern-ides"><span class="toc-section-number">8.6.5</span> Comparison to Modern
IDEs</a></li>
<li><a href="#what-made-this-revolutionary" id="toc-what-made-this-revolutionary"><span class="toc-section-number">8.6.6</span> What Made This
Revolutionary</a></li>
</ul></details></li>
<li><a href="#conclusion-celebrating-the-achievement" id="toc-conclusion-celebrating-the-achievement"><span class="toc-section-number">8.7</span> Conclusion: Celebrating the
Achievement</a></li>
</ul></details></li>
<li><details><summary><a href="#chapter-11---user-utilities-the-unix-philosophy-emerges" id="toc-chapter-11---user-utilities-the-unix-philosophy-emerges"><span class="toc-section-number">9</span> Chapter 11 - User Utilities: The
Unix Philosophy Emerges</a></summary><ul>
<li><details><summary><a href="#the-unix-philosophy-in-code" id="toc-the-unix-philosophy-in-code"><span class="toc-section-number">9.1</span> 11.1 The Unix Philosophy in
Code</a></summary><ul>
<li><a href="#the-constraints-that-shaped-philosophy" id="toc-the-constraints-that-shaped-philosophy"><span class="toc-section-number">9.1.1</span> The Constraints That Shaped
Philosophy</a></li>
<li><a href="#contrast-with-1969-computing-culture" id="toc-contrast-with-1969-computing-culture"><span class="toc-section-number">9.1.2</span> Contrast with 1969 Computing
Culture</a></li>
<li><a href="#the-unix-difference" id="toc-the-unix-difference"><span class="toc-section-number">9.1.3</span> The Unix Difference</a></li>
<li><a href="#the-cultural-impact" id="toc-the-cultural-impact"><span class="toc-section-number">9.1.4</span> The Cultural Impact</a></li>
</ul></details></li>
<li><details><summary><a href="#file-viewing-and-manipulation" id="toc-file-viewing-and-manipulation"><span class="toc-section-number">9.2</span> 11.2 File Viewing and
Manipulation</a></summary><ul>
<li><a href="#cat.s---concatenate-files" id="toc-cat.s---concatenate-files"><span class="toc-section-number">9.2.1</span> cat.s - Concatenate
Files</a></li>
<li><a href="#cp.s---copy-files" id="toc-cp.s---copy-files"><span class="toc-section-number">9.2.2</span> cp.s - Copy Files</a></li>
<li><a href="#chmod.s---change-file-mode" id="toc-chmod.s---change-file-mode"><span class="toc-section-number">9.2.3</span> chmod.s - Change File
Mode</a></li>
<li><a href="#chown.s---change-owner" id="toc-chown.s---change-owner"><span class="toc-section-number">9.2.4</span> chown.s - Change Owner</a></li>
<li><a href="#chrm.s---changeremove-utility" id="toc-chrm.s---changeremove-utility"><span class="toc-section-number">9.2.5</span> chrm.s - Change/Remove
Utility</a></li>
</ul></details></li>
<li><details><summary><a href="#system-utilities" id="toc-system-utilities"><span class="toc-section-number">9.3</span> 11.3 System Utilities</a></summary><ul>
<li><a href="#check.s---file-system-checker" id="toc-check.s---file-system-checker"><span class="toc-section-number">9.3.1</span> check.s - File System
Checker</a></li>
<li><a href="#init.s---system-initialization-and-login" id="toc-init.s---system-initialization-and-login"><span class="toc-section-number">9.3.2</span> init.s - System Initialization
and Login</a></li>
<li><a href="#maksys.s---system-installation" id="toc-maksys.s---system-installation"><span class="toc-section-number">9.3.3</span> maksys.s - System
Installation</a></li>
<li><a href="#trysys.s---system-loader" id="toc-trysys.s---system-loader"><span class="toc-section-number">9.3.4</span> trysys.s - System
Loader</a></li>
</ul></details></li>
<li><details><summary><a href="#disk-utilities" id="toc-disk-utilities"><span class="toc-section-number">9.4</span> 11.4 Disk Utilities</a></summary><ul>
<li><a href="#dsksav.s-dskres.s---disk-backuprestore" id="toc-dsksav.s-dskres.s---disk-backuprestore"><span class="toc-section-number">9.4.1</span> dsksav.s / dskres.s - Disk
Backup/Restore</a></li>
</ul></details></li>
<li><details><summary><a href="#common-patterns" id="toc-common-patterns"><span class="toc-section-number">9.5</span> 11.5 Common Patterns</a></summary><ul>
<li><a href="#pattern-1-argument-parsing" id="toc-pattern-1-argument-parsing"><span class="toc-section-number">9.5.1</span> Pattern 1: Argument
Parsing</a></li>
<li><a href="#pattern-2-character-packingunpacking" id="toc-pattern-2-character-packingunpacking"><span class="toc-section-number">9.5.2</span> Pattern 2: Character
Packing/Unpacking</a></li>
<li><a href="#pattern-3-buffered-io" id="toc-pattern-3-buffered-io"><span class="toc-section-number">9.5.3</span> Pattern 3: Buffered I/O</a></li>
<li><a href="#pattern-4-error-reporting" id="toc-pattern-4-error-reporting"><span class="toc-section-number">9.5.4</span> Pattern 4: Error
Reporting</a></li>
<li><a href="#pattern-5-octal-parsing" id="toc-pattern-5-octal-parsing"><span class="toc-section-number">9.5.5</span> Pattern 5: Octal
Parsing</a></li>
<li><a href="#pattern-6-self-modifying-code" id="toc-pattern-6-self-modifying-code"><span class="toc-section-number">9.5.6</span> Pattern 6: Self-Modifying
Code</a></li>
<li><a href="#pattern-7-word-aligned-string-storage" id="toc-pattern-7-word-aligned-string-storage"><span class="toc-section-number">9.5.7</span> Pattern 7: Word-Aligned String
Storage</a></li>
</ul></details></li>
<li><details><summary><a href="#the-minimalist-aesthetic" id="toc-the-minimalist-aesthetic"><span class="toc-section-number">9.6</span> 11.6 The Minimalist Aesthetic</a></summary><ul>
<li><a href="#lines-of-code-comparison" id="toc-lines-of-code-comparison"><span class="toc-section-number">9.6.1</span> Lines of Code
Comparison</a></li>
<li><a href="#why-less-was-more" id="toc-why-less-was-more"><span class="toc-section-number">9.6.2</span> Why Less Was More</a></li>
<li><a href="#the-constraint-driven-design-process" id="toc-the-constraint-driven-design-process"><span class="toc-section-number">9.6.3</span> The Constraint-Driven Design
Process</a></li>
<li><a href="#cultural-impact-on-modern-software" id="toc-cultural-impact-on-modern-software"><span class="toc-section-number">9.6.4</span> Cultural Impact on Modern
Software</a></li>
</ul></details></li>
<li><details><summary><a href="#historical-context-2" id="toc-historical-context-2"><span class="toc-section-number">9.7</span> 11.7 Historical Context</a></summary><ul>
<li><a href="#what-utilities-existed-on-other-1969-systems" id="toc-what-utilities-existed-on-other-1969-systems"><span class="toc-section-number">9.7.1</span> What Utilities Existed on Other
1969 Systems?</a></li>
<li><a href="#the-batch-processing-era" id="toc-the-batch-processing-era"><span class="toc-section-number">9.7.2</span> The Batch Processing
Era</a></li>
<li><a href="#time-sharing-system-commands" id="toc-time-sharing-system-commands"><span class="toc-section-number">9.7.3</span> Time-Sharing System
Commands</a></li>
<li><a href="#how-unix-utilities-differed" id="toc-how-unix-utilities-differed"><span class="toc-section-number">9.7.4</span> How Unix Utilities
Differed</a></li>
<li><a href="#the-lasting-influence-on-command-line-culture" id="toc-the-lasting-influence-on-command-line-culture"><span class="toc-section-number">9.7.5</span> The Lasting Influence on
Command-Line Culture</a></li>
<li><a href="#from-necessity-to-philosophy" id="toc-from-necessity-to-philosophy"><span class="toc-section-number">9.7.6</span> From Necessity to
Philosophy</a></li>
<li><a href="#the-irony-of-success" id="toc-the-irony-of-success"><span class="toc-section-number">9.7.7</span> The Irony of Success</a></li>
<li><a href="#modern-lessons" id="toc-modern-lessons"><span class="toc-section-number">9.7.8</span> Modern Lessons</a></li>
<li><a href="#conclusion-philosophy-from-pragmatism" id="toc-conclusion-philosophy-from-pragmatism"><span class="toc-section-number">9.7.9</span> Conclusion: Philosophy from
Pragmatism</a></li>
</ul></details></li>
</ul></details></li>
<li><details><summary><a href="#chapter-12-the-b-language-system-unixs-first-high-level-language" id="toc-chapter-12-the-b-language-system-unixs-first-high-level-language"><span class="toc-section-number">10</span> Chapter 12: The B Language System ‚Äî
Unix‚Äôs First High-Level Language</a></summary><ul>
<li><details><summary><a href="#b-language-origins" id="toc-b-language-origins"><span class="toc-section-number">10.1</span> 12.1 B Language Origins</a></summary><ul>
<li><a href="#ken-thompsons-creation-1969" id="toc-ken-thompsons-creation-1969"><span class="toc-section-number">10.1.1</span> Ken Thompson‚Äôs Creation
(1969)</a></li>
<li><a href="#evolution-from-bcpl" id="toc-evolution-from-bcpl"><span class="toc-section-number">10.1.2</span> Evolution from BCPL</a></li>
<li><a href="#precursor-to-c" id="toc-precursor-to-c"><span class="toc-section-number">10.1.3</span> Precursor to C</a></li>
<li><a href="#why-a-high-level-language" id="toc-why-a-high-level-language"><span class="toc-section-number">10.1.4</span> Why a High-Level
Language?</a></li>
<li><a href="#historical-context-3" id="toc-historical-context-3"><span class="toc-section-number">10.1.5</span> Historical Context</a></li>
</ul></details></li>
<li><details><summary><a href="#b-language-syntax" id="toc-b-language-syntax"><span class="toc-section-number">10.2</span> 12.2 B Language Syntax</a></summary><ul>
<li><a href="#based-on-actual-.b-files" id="toc-based-on-actual-.b-files"><span class="toc-section-number">10.2.1</span> Based on Actual .b
Files</a></li>
<li><a href="#untyped-language" id="toc-untyped-language"><span class="toc-section-number">10.2.2</span> Untyped Language</a></li>
<li><a href="#blocks-vs" id="toc-blocks-vs"><span class="toc-section-number">10.2.3</span> Blocks: <code>$(</code>
<code>$)</code> vs <code>{</code> <code>}</code></a></li>
<li><a href="#external-declarations-extrn" id="toc-external-declarations-extrn"><span class="toc-section-number">10.2.4</span> External Declarations:
<code>extrn</code></a></li>
<li><a href="#control-flow-1" id="toc-control-flow-1"><span class="toc-section-number">10.2.5</span> Control Flow</a></li>
<li><a href="#example-programs" id="toc-example-programs"><span class="toc-section-number">10.2.6</span> Example Programs</a></li>
</ul></details></li>
<li><details><summary><a href="#the-b-interpreter-bi.s" id="toc-the-b-interpreter-bi.s"><span class="toc-section-number">10.3</span> 12.3 The B Interpreter (bi.s)</a></summary><ul>
<li><a href="#stack-based-execution" id="toc-stack-based-execution"><span class="toc-section-number">10.3.1</span> Stack-Based Execution</a></li>
<li><a href="#virtual-machine-model" id="toc-virtual-machine-model"><span class="toc-section-number">10.3.2</span> Virtual Machine Model</a></li>
<li><a href="#instruction-format-18-bits" id="toc-instruction-format-18-bits"><span class="toc-section-number">10.3.3</span> Instruction Format (18
bits)</a></li>
<li><a href="#complete-implementation" id="toc-complete-implementation"><span class="toc-section-number">10.3.4</span> Complete
Implementation</a></li>
</ul></details></li>
<li><details><summary><a href="#b-operations" id="toc-b-operations"><span class="toc-section-number">10.4</span> 12.4 B Operations</a></summary><ul>
<li><a href="#autop---auto-variables" id="toc-autop---auto-variables"><span class="toc-section-number">10.4.1</span> autop - Auto Variables</a></li>
<li><a href="#binop---binary-operations" id="toc-binop---binary-operations"><span class="toc-section-number">10.4.2</span> binop - Binary
Operations</a></li>
<li><a href="#consop---constants" id="toc-consop---constants"><span class="toc-section-number">10.4.3</span> consop - Constants</a></li>
<li><a href="#ifop---conditionals" id="toc-ifop---conditionals"><span class="toc-section-number">10.4.4</span> ifop - Conditionals</a></li>
<li><a href="#traop---transfers-goto-function-calls" id="toc-traop---transfers-goto-function-calls"><span class="toc-section-number">10.4.5</span> traop - Transfers (goto,
function calls)</a></li>
<li><a href="#unaop---unary-operations" id="toc-unaop---unary-operations"><span class="toc-section-number">10.4.6</span> unaop - Unary
Operations</a></li>
<li><a href="#extop---external-references" id="toc-extop---external-references"><span class="toc-section-number">10.4.7</span> extop - External
References</a></li>
<li><a href="#aryop---arrays" id="toc-aryop---arrays"><span class="toc-section-number">10.4.8</span> aryop - Arrays</a></li>
</ul></details></li>
<li><details><summary><a href="#b-runtime-support-bc.s" id="toc-b-runtime-support-bc.s"><span class="toc-section-number">10.5</span> 12.5 B Runtime Support (bc.s)</a></summary><ul>
<li><a href="#instruction-tracing" id="toc-instruction-tracing"><span class="toc-section-number">10.5.1</span> Instruction Tracing</a></li>
<li><a href="#display-buffer-management" id="toc-display-buffer-management"><span class="toc-section-number">10.5.2</span> Display Buffer
Management</a></li>
<li><a href="#histogram-collection" id="toc-histogram-collection"><span class="toc-section-number">10.5.3</span> Histogram Collection</a></li>
<li><a href="#octal-output" id="toc-octal-output"><span class="toc-section-number">10.5.4</span> Octal Output</a></li>
<li><a href="#stack-validation" id="toc-stack-validation"><span class="toc-section-number">10.5.5</span> Stack Validation</a></li>
</ul></details></li>
<li><details><summary><a href="#b-library-bl.s" id="toc-b-library-bl.s"><span class="toc-section-number">10.6</span> 12.6 B Library (bl.s)</a></summary><ul>
<li><a href="#array---array-allocation" id="toc-array---array-allocation"><span class="toc-section-number">10.6.1</span> .array - Array
Allocation</a></li>
<li><a href="#read---character-input" id="toc-read---character-input"><span class="toc-section-number">10.6.2</span> .read - Character
Input</a></li>
<li><a href="#write---word-output" id="toc-write---word-output"><span class="toc-section-number">10.6.3</span> .write - Word Output</a></li>
<li><a href="#flush---buffer-flush" id="toc-flush---buffer-flush"><span class="toc-section-number">10.6.4</span> .flush - Buffer Flush</a></li>
<li><a href="#buffered-io-implementation" id="toc-buffered-io-implementation"><span class="toc-section-number">10.6.5</span> Buffered I/O
Implementation</a></li>
</ul></details></li>
<li><details><summary><a href="#example-programs-1" id="toc-example-programs-1"><span class="toc-section-number">10.7</span> 12.7 Example Programs</a></summary><ul>
<li><a href="#lcase.b---lowercase-converter-1" id="toc-lcase.b---lowercase-converter-1"><span class="toc-section-number">10.7.1</span> lcase.b - Lowercase
Converter</a></li>
<li><a href="#ind.b---indentation-tool-1" id="toc-ind.b---indentation-tool-1"><span class="toc-section-number">10.7.2</span> ind.b - Indentation
Tool</a></li>
</ul></details></li>
<li><details><summary><a href="#b-vs-c" id="toc-b-vs-c"><span class="toc-section-number">10.8</span> 12.8 B vs C</a></summary><ul>
<li><a href="#what-b-lacked" id="toc-what-b-lacked"><span class="toc-section-number">10.8.1</span> What B Lacked</a></li>
<li><a href="#why-c-was-needed" id="toc-why-c-was-needed"><span class="toc-section-number">10.8.2</span> Why C Was Needed</a></li>
<li><a href="#evolution-path" id="toc-evolution-path"><span class="toc-section-number">10.8.3</span> Evolution Path</a></li>
</ul></details></li>
<li><details><summary><a href="#bs-legacy" id="toc-bs-legacy"><span class="toc-section-number">10.9</span> 12.9 B‚Äôs Legacy</a></summary><ul>
<li><a href="#influence-on-c" id="toc-influence-on-c"><span class="toc-section-number">10.9.1</span> Influence on C</a></li>
<li><a href="#concepts-that-survived" id="toc-concepts-that-survived"><span class="toc-section-number">10.9.2</span> Concepts That Survived</a></li>
<li><a href="#what-disappeared" id="toc-what-disappeared"><span class="toc-section-number">10.9.3</span> What Disappeared</a></li>
<li><a href="#historical-significance-1" id="toc-historical-significance-1"><span class="toc-section-number">10.9.4</span> Historical
Significance</a></li>
</ul></details></li>
<li><details><summary><a href="#programming-in-b" id="toc-programming-in-b"><span class="toc-section-number">10.10</span> 12.10 Programming in B</a></summary><ul>
<li><a href="#writing-b-programs" id="toc-writing-b-programs"><span class="toc-section-number">10.10.1</span> Writing B Programs</a></li>
<li><a href="#compilationinterpretation" id="toc-compilationinterpretation"><span class="toc-section-number">10.10.2</span>
Compilation/Interpretation</a></li>
<li><a href="#debugging" id="toc-debugging"><span class="toc-section-number">10.10.3</span> Debugging</a></li>
<li><a href="#performance" id="toc-performance"><span class="toc-section-number">10.10.4</span> Performance</a></li>
</ul></details></li>
<li><details><summary><a href="#historical-context-4" id="toc-historical-context-4"><span class="toc-section-number">10.11</span> 12.11 Historical Context</a></summary><ul>
<li><a href="#high-level-languages" id="toc-high-level-languages"><span class="toc-section-number">10.11.1</span> 1969 High-Level
Languages</a></li>
<li><a href="#bcpl-algol-fortran" id="toc-bcpl-algol-fortran"><span class="toc-section-number">10.11.2</span> BCPL, ALGOL, FORTRAN</a></li>
<li><a href="#why-b-was-different" id="toc-why-b-was-different"><span class="toc-section-number">10.11.3</span> Why B Was Different</a></li>
<li><a href="#impact-on-portability" id="toc-impact-on-portability"><span class="toc-section-number">10.11.4</span> Impact on Portability</a></li>
</ul></details></li>
<li><a href="#conclusion-bs-place-in-computing-history" id="toc-conclusion-bs-place-in-computing-history"><span class="toc-section-number">10.12</span> Conclusion: B‚Äôs Place in
Computing History</a></li>
</ul></details></li>
<li><details><summary><a href="#chapter-14-legacy-and-impact-how-8000-lines-changed-the-world" id="toc-chapter-14-legacy-and-impact-how-8000-lines-changed-the-world"><span class="toc-section-number">11</span> Chapter 14: Legacy and Impact ‚Äî How
8,000 Lines Changed the World</a></summary><ul>
<li><details><summary><a href="#from-pdp-7-to-world-domination" id="toc-from-pdp-7-to-world-domination"><span class="toc-section-number">11.1</span> 14.1 From PDP-7 to World
Domination</a></summary><ul>
<li><a href="#the-pdp-11-port-1970-1971" id="toc-the-pdp-11-port-1970-1971"><span class="toc-section-number">11.1.1</span> The PDP-11 Port
(1970-1971)</a></li>
<li><a href="#the-invention-of-c-1972" id="toc-the-invention-of-c-1972"><span class="toc-section-number">11.1.2</span> The Invention of C
(1972)</a></li>
<li><a href="#research-unix-evolution-1971-1979" id="toc-research-unix-evolution-1971-1979"><span class="toc-section-number">11.1.3</span> Research Unix Evolution
(1971-1979)</a></li>
</ul></details></li>
<li><details><summary><a href="#the-unix-family-tree" id="toc-the-unix-family-tree"><span class="toc-section-number">11.2</span> 14.2 The Unix Family Tree</a></summary><ul>
<li><a href="#bsd-unix-1977-1995" id="toc-bsd-unix-1977-1995"><span class="toc-section-number">11.2.1</span> BSD Unix (1977-1995)</a></li>
<li><a href="#system-v-1983-1992" id="toc-system-v-1983-1992"><span class="toc-section-number">11.2.2</span> System V (1983-1992)</a></li>
<li><a href="#the-open-source-revolution" id="toc-the-open-source-revolution"><span class="toc-section-number">11.2.3</span> The Open Source
Revolution</a></li>
<li><a href="#the-mobile-era-unix-in-your-pocket" id="toc-the-mobile-era-unix-in-your-pocket"><span class="toc-section-number">11.2.4</span> The Mobile Era: Unix in Your
Pocket</a></li>
</ul></details></li>
<li><details><summary><a href="#unix-concepts-in-modern-systems" id="toc-unix-concepts-in-modern-systems"><span class="toc-section-number">11.3</span> 14.3 Unix Concepts in Modern
Systems</a></summary><ul>
<li><a href="#ubiquitous-ideas-from-pdp-7-unix" id="toc-ubiquitous-ideas-from-pdp-7-unix"><span class="toc-section-number">11.3.1</span> Ubiquitous Ideas from PDP-7
Unix</a></li>
<li><a href="#modern-implementations-whats-the-same-what-evolved" id="toc-modern-implementations-whats-the-same-what-evolved"><span class="toc-section-number">11.3.2</span> Modern Implementations: What‚Äôs
the Same, What Evolved</a></li>
</ul></details></li>
<li><details><summary><a href="#cultural-impact-1" id="toc-cultural-impact-1"><span class="toc-section-number">11.4</span> 14.4 Cultural Impact</a></summary><ul>
<li><a href="#the-unix-philosophy" id="toc-the-unix-philosophy"><span class="toc-section-number">11.4.1</span> The Unix Philosophy</a></li>
<li><a href="#worse-is-better-vs.-the-right-thing" id="toc-worse-is-better-vs.-the-right-thing"><span class="toc-section-number">11.4.2</span> ‚ÄúWorse is Better‚Äù vs.¬†‚ÄúThe
Right Thing‚Äù</a></li>
<li><a href="#how-this-shaped-software-engineering" id="toc-how-this-shaped-software-engineering"><span class="toc-section-number">11.4.3</span> How This Shaped Software
Engineering</a></li>
<li><a href="#the-open-source-movement" id="toc-the-open-source-movement"><span class="toc-section-number">11.4.4</span> The Open Source
Movement</a></li>
<li><a href="#software-engineering-practices" id="toc-software-engineering-practices"><span class="toc-section-number">11.4.5</span> Software Engineering
Practices</a></li>
</ul></details></li>
<li><details><summary><a href="#market-impact" id="toc-market-impact"><span class="toc-section-number">11.5</span> 14.5 Market Impact</a></summary><ul>
<li><a href="#the-minicomputer-era-1970s" id="toc-the-minicomputer-era-1970s"><span class="toc-section-number">11.5.1</span> The Minicomputer Era
(1970s)</a></li>
<li><a href="#the-workstation-era-1980s" id="toc-the-workstation-era-1980s"><span class="toc-section-number">11.5.2</span> The Workstation Era
(1980s)</a></li>
<li><a href="#the-server-era-1990s-present" id="toc-the-server-era-1990s-present"><span class="toc-section-number">11.5.3</span> The Server Era
(1990s-present)</a></li>
<li><a href="#the-mobile-era-2000s-present" id="toc-the-mobile-era-2000s-present"><span class="toc-section-number">11.5.4</span> The Mobile Era
(2000s-present)</a></li>
</ul></details></li>
<li><details><summary><a href="#educational-impact" id="toc-educational-impact"><span class="toc-section-number">11.6</span> 14.6 Educational Impact</a></summary><ul>
<li><a href="#unix-in-computer-science-education" id="toc-unix-in-computer-science-education"><span class="toc-section-number">11.6.1</span> Unix in Computer Science
Education</a></li>
<li><a href="#this-pdp-7-code-as-historical-artifact" id="toc-this-pdp-7-code-as-historical-artifact"><span class="toc-section-number">11.6.2</span> This PDP-7 Code as Historical
Artifact</a></li>
</ul></details></li>
<li><details><summary><a href="#economic-impact" id="toc-economic-impact"><span class="toc-section-number">11.7</span> 14.7 Economic Impact</a></summary><ul>
<li><a href="#companies-built-on-unix" id="toc-companies-built-on-unix"><span class="toc-section-number">11.7.1</span> Companies Built on
Unix</a></li>
<li><a href="#market-valuations" id="toc-market-valuations"><span class="toc-section-number">11.7.2</span> Market Valuations</a></li>
<li><a href="#jobs-created" id="toc-jobs-created"><span class="toc-section-number">11.7.3</span> Jobs Created</a></li>
<li><a href="#industries-enabled" id="toc-industries-enabled"><span class="toc-section-number">11.7.4</span> Industries Enabled</a></li>
<li><a href="#estimated-total-economic-impact" id="toc-estimated-total-economic-impact"><span class="toc-section-number">11.7.5</span> Estimated Total Economic
Impact</a></li>
</ul></details></li>
<li><details><summary><a href="#technical-debt-and-lessons" id="toc-technical-debt-and-lessons"><span class="toc-section-number">11.8</span> 14.8 Technical Debt and
Lessons</a></summary><ul>
<li><a href="#what-aged-well" id="toc-what-aged-well"><span class="toc-section-number">11.8.1</span> What Aged Well</a></li>
<li><a href="#what-didnt-age-well" id="toc-what-didnt-age-well"><span class="toc-section-number">11.8.2</span> What Didn‚Äôt Age Well</a></li>
<li><a href="#lessons-for-today" id="toc-lessons-for-today"><span class="toc-section-number">11.8.3</span> Lessons for Today</a></li>
</ul></details></li>
<li><details><summary><a href="#the-preservation-effort" id="toc-the-preservation-effort"><span class="toc-section-number">11.9</span> 14.9 The Preservation Effort</a></summary><ul>
<li><a href="#the-unix-heritage-society" id="toc-the-unix-heritage-society"><span class="toc-section-number">11.9.1</span> The Unix Heritage
Society</a></li>
<li><a href="#running-pdp-7-unix-today" id="toc-running-pdp-7-unix-today"><span class="toc-section-number">11.9.2</span> Running PDP-7 Unix
Today</a></li>
</ul></details></li>
<li><details><summary><a href="#conclusion-the-longest-lasting-code" id="toc-conclusion-the-longest-lasting-code"><span class="toc-section-number">11.10</span> 14.10 Conclusion: The
Longest-Lasting Code</a></summary><ul>
<li><a href="#perspective" id="toc-perspective"><span class="toc-section-number">11.10.1</span> Perspective</a></li>
<li><a href="#the-thompson-and-ritchie-legacy" id="toc-the-thompson-and-ritchie-legacy"><span class="toc-section-number">11.10.2</span> The Thompson and Ritchie
Legacy</a></li>
<li><a href="#looking-forward" id="toc-looking-forward"><span class="toc-section-number">11.10.3</span> Looking Forward</a></li>
<li><a href="#final-reflection-8000-lines-that-changed-the-world" id="toc-final-reflection-8000-lines-that-changed-the-world"><span class="toc-section-number">11.10.4</span> Final Reflection: 8,000 Lines
That Changed the World</a></li>
</ul></details></li>
<li><a href="#references-and-further-reading" id="toc-references-and-further-reading"><span class="toc-section-number">11.11</span> References and Further
Reading</a></li>
</ul></details></li>
<li><a href="#glossary" id="toc-glossary"><span class="toc-section-number">12</span> Glossary</a></li>
</ul></nav>

</div>
</nav>
<main class="book-content">
<header class="book-header">
<h1 class="book-title">PDP-7 Unix: A Complete Reference</h1>
<p class="book-subtitle">The Original Unix System on the PDP-7</p>
</header>
<div class="ai-notice">
<strong>üìù AI-Generated Documentation:</strong> This encyclopedia was entirely created by Claude (Anthropic AI) through comprehensive source code analysis,
      historical research, and community documentation review. Starting from the actual codebase, Claude examined thousands of source files,
      traced git history, and synthesized documentation that explains not just <em>what</em> the code does, but <em>why</em> it exists
      and <em>how</em> it evolved. The result is a deep, systematic exploration compiled with attention to technical accuracy,
      historical context, and educational value.
    </div>
<h1 class="unnumbered" id="frontmatter">Frontmatter</h1>
<h2 class="unnumbered" id="about-this-work">About This Work</h2>
<p>This comprehensive technical reference documents the PDP-7 Unix
operating system, one of the most significant software artifacts in
computing history. Written in 1969-1970 by Ken Thompson and Dennis
Ritchie at Bell Labs, this code represents the birth of Unix and, by
extension, the foundation of modern computing.</p>
<h2 class="unnumbered" id="purpose-and-scope">Purpose and Scope</h2>
<p>This work provides:</p>
<ul>
<li><strong>Complete technical documentation</strong> of every component
in the PDP-7 Unix system</li>
<li><strong>Literate programming presentation</strong> with extensive
narrative explanation accompanied by code</li>
<li><strong>Historical analysis</strong> of how Unix evolved and the
development patterns that emerged</li>
<li><strong>Hardware context</strong> explaining the PDP-7 computer
architecture and its constraints</li>
<li><strong>Cross-referenced</strong> comprehensive coverage enabling
deep understanding of system interactions</li>
</ul>
<h2 class="unnumbered" id="how-to-read-this-book">How to Read This
Book</h2>
<p>This reference is organized to support multiple reading paths:</p>
<h3 data-number="0.0.1" id="for-the-curious-reader"><span class="header-section-number">0.0.1</span> For the Curious Reader</h3>
<p>Start with: - Chapter 1: Historical Context - Chapter 2: PDP-7
Hardware Architecture - Chapter 4: System Architecture Overview -
Chapter 11: User Utilities (cat, cp, chmod, etc.)</p>
<h3 data-number="0.0.2" id="for-the-systems-programmer"><span class="header-section-number">0.0.2</span> For the Systems
Programmer</h3>
<p>Focus on: - Chapter 3: Assembly Language and Programming - Chapter 5:
The Kernel Deep Dive - Chapter 7: File System Implementation - Chapter
8: Process Management - Chapter 9: Device Drivers and I/O</p>
<h3 data-number="0.0.3" id="for-the-programming-language-enthusiast"><span class="header-section-number">0.0.3</span> For the Programming Language
Enthusiast</h3>
<p>Read: - Chapter 10: Development Tools - Chapter 12: The B Language
System - Chapter 3: Assembly Language</p>
<h3 data-number="0.0.4" id="for-the-computer-historian"><span class="header-section-number">0.0.4</span> For the Computer
Historian</h3>
<p>Study: - Chapter 1: Historical Context - Chapter 13: Code Evolution
and Development Patterns - Chapter 14: Legacy and Impact</p>
<h3 data-number="0.0.5" id="for-complete-mastery"><span class="header-section-number">0.0.5</span> For Complete Mastery</h3>
<p>Read sequentially from start to finish, consulting the Index and
Glossary as needed.</p>
<h2 class="unnumbered" id="conventions-used">Conventions Used</h2>
<h3 data-number="0.0.6" id="code-formatting"><span class="header-section-number">0.0.6</span> Code Formatting</h3>
<ul>
<li><strong>Inline code</strong> appears in
<code>monospace font</code></li>
<li><strong>Code blocks</strong> are syntax-highlighted and
annotated:</li>
</ul>
<pre class="assembly"><code>" This is a comment in PDP-7 assembly
lac value       " Load accumulator from location 'value'
tad constant    " Two's complement add
dac result      " Deposit (store) accumulator to 'result'</code></pre>
<h3 data-number="0.0.7" id="cross-references"><span class="header-section-number">0.0.7</span> Cross-References</h3>
<ul>
<li><strong>File references</strong> use the format:
<code>filename:line</code> (e.g., <code>init.s:42</code>)</li>
<li><strong>Chapter cross-references</strong> link to relevant
sections</li>
<li><strong>Index entries</strong> appear in <strong>bold</strong> on
first significant use</li>
</ul>
<h3 data-number="0.0.8" id="octal-notation"><span class="header-section-number">0.0.8</span> Octal Notation</h3>
<p>Following PDP-7 conventions, all numbers are octal unless otherwise
specified: - <code>0177</code> = octal 177 = decimal 127 -
<code>017777</code> = octal 17777 = decimal 8191 - Decimal numbers
explicitly marked: <code>127‚ÇÅ‚ÇÄ</code></p>
<h3 data-number="0.0.9" id="assembly-language-syntax"><span class="header-section-number">0.0.9</span> Assembly Language Syntax</h3>
<p>PDP-7 Unix uses distinctive syntax: - <strong>Comments</strong> begin
with <code>"</code> (double quote) and continue to end of line -
<strong>Labels</strong> end with <code>:</code> (colon) - <strong>System
calls</strong> use <code>sys</code> directive:
<code>sys open; filename; 0</code> - <strong>Indirect
addressing</strong> indicated by <code>i</code>:
<code>lac i pointer</code></p>
<h2 class="unnumbered" id="acknowledgments">Acknowledgments</h2>
<p>This work would not be possible without:</p>
<ul>
<li><strong>Ken Thompson</strong> and <strong>Dennis Ritchie</strong> -
creators of Unix</li>
<li><strong>Dennis Ritchie</strong> (posthumous) - for preserving the
original source code printouts</li>
<li><strong>Warren Toomey</strong> and the <strong>Unix Heritage Society
(TUHS)</strong> - for Unix archaeology and preservation</li>
<li><strong>The pdp7-unix project contributors</strong> - for
resurrecting Unix from scanned printouts</li>
<li><strong>The Computer History Museum</strong> - for making the source
code publicly accessible</li>
<li><strong>Digital Equipment Corporation</strong> - for creating the
PDP-7 computer</li>
<li><strong>The retrocomputing community</strong> - for keeping this
history alive</li>
</ul>
<h2 class="unnumbered" id="license-and-usage">License and Usage</h2>
<p>The original PDP-7 Unix source code is released under multiple
historical licenses:</p>
<ul>
<li><strong>Caldera License</strong> - Covering ancient Unix
versions</li>
<li><strong>Historical research</strong> - Source code available for
educational purposes</li>
</ul>
<p>This documentation is released under the <strong>Creative Commons
Attribution-ShareAlike 4.0 International License (CC BY-SA
4.0)</strong>. You are free to:</p>
<ul>
<li><strong>Share</strong> - copy and redistribute the material</li>
<li><strong>Adapt</strong> - remix, transform, and build upon the
material</li>
</ul>
<p>Under the following terms:</p>
<ul>
<li><strong>Attribution</strong> - You must give appropriate credit</li>
<li><strong>ShareAlike</strong> - Distribute derivative works under the
same license</li>
</ul>
<h2 class="unnumbered" id="note-on-historical-accuracy">Note on
Historical Accuracy</h2>
<p>This documentation is based on:</p>
<ol type="1">
<li><strong>Original source code</strong> scanned from printouts dated
1970-1971</li>
<li><strong>DEC PDP-7 technical manuals</strong> from the 1960s</li>
<li><strong>Historical research</strong> by computer historians</li>
<li><strong>Modern reconstruction</strong> through the pdp7-unix
project</li>
</ol>
<p>Every effort has been made to ensure technical accuracy. Where
historical records are ambiguous or incomplete, this is noted in the
text.</p>
<h2 class="unnumbered" id="version-information">Version Information</h2>
<ul>
<li><strong>Documentation Version</strong>: 1.0</li>
<li><strong>Source Code</strong>: PDP-7 Unix (circa 1970, commit
16fdb21)</li>
<li><strong>Repository</strong>: unix-history-repo</li>
<li><strong>Documentation Date</strong>: November 2025</li>
</ul>
<hr/>
<p><em>‚ÄúA language that doesn‚Äôt affect the way you think about
programming is not worth knowing.‚Äù</em> ‚Äî Alan Perlis</p>
<p><em>‚ÄúUnix is simple. It just takes a genius to understand its
simplicity.‚Äù</em> ‚Äî Dennis Ritchie</p>
<p><em>‚ÄúOne of my most productive days was throwing away 1000 lines of
code.‚Äù</em> ‚Äî Ken Thompson</p>
<h1 data-number="1" id="introduction-and-historical-context"><span class="header-section-number">1</span> Introduction and Historical
Context</h1>
<h2 data-number="1.1" id="the-birth-of-unix"><span class="header-section-number">1.1</span> The Birth of Unix</h2>
<p>On a summer day in 1969, Ken Thompson sat down at a PDP-7
minicomputer at Bell Laboratories in Murray Hill, New Jersey. What he
created over the following months would fundamentally reshape computing
for the next half-century and beyond. This was the birth of Unix.</p>
<h3 data-number="1.1.1" id="the-multics-withdrawal"><span class="header-section-number">1.1.1</span> The Multics Withdrawal</h3>
<p>The story begins not with success, but with abandonment. Bell Labs,
along with MIT and General Electric, had been developing
<strong>Multics</strong> (Multiplexed Information and Computing
Service), an ambitious time-sharing operating system. Multics aimed to
provide a computing utility‚Äîlike telephone service or electricity‚Äîwhere
many users could simultaneously access a powerful central computer.</p>
<p>By 1969, the project had grown enormously complex. Bell Labs
management, concerned about cost and complexity, decided to withdraw
from the project. This left several researchers, including Ken Thompson
and Dennis Ritchie, without access to the comfortable interactive
computing environment they had grown accustomed to.</p>
<h3 data-number="1.1.2" id="space-travel-and-the-search-for-a-computer"><span class="header-section-number">1.1.2</span> Space Travel and the Search
for a Computer</h3>
<p>Ken Thompson had written a game called <strong>Space Travel</strong>
that simulated the motion of planets and spacecraft in the solar system.
The game required significant computational power and, more importantly,
a graphics display. Thompson initially ran it on the GE mainframe using
Multics, but the cost‚Äîapproximately $75 per session in 1960s dollars‚Äîwas
prohibitive for a game.</p>
<p>Thompson and Ritchie went searching for an available computer. They
found a <strong>Digital Equipment Corporation PDP-7</strong> sitting in
a corner of Bell Labs. The PDP-7 was already obsolete by 1969 standards
(it had been introduced in 1964), but it had several appealing
characteristics:</p>
<ol type="1">
<li><strong>Graphics capability</strong> - A <strong>DEC Type 340
display</strong> for vector graphics</li>
<li><strong>Availability</strong> - Nobody else was using it</li>
<li><strong>Accessibility</strong> - No gatekeepers controlling
access</li>
<li><strong>Interactivity</strong> - Direct connection without batch
processing delays</li>
</ol>
<h3 data-number="1.1.3" id="from-game-to-operating-system"><span class="header-section-number">1.1.3</span> From Game to Operating
System</h3>
<p>Thompson ported Space Travel to the PDP-7, but quickly realized that
what the machine really needed was a proper operating system. Drawing on
his experience with Multics, but striving for simplicity rather than
comprehensiveness, Thompson began designing a minimal but complete
operating system.</p>
<p>The design philosophy was revolutionary for its time:</p>
<blockquote>
<p><strong>‚ÄúMake each program do one thing well. To do a new job, build
afresh rather than complicate old programs by adding new
features.‚Äù</strong></p>
</blockquote>
<p>This became known as the <strong>Unix philosophy</strong>.</p>
<h3 data-number="1.1.4" id="the-four-week-creation"><span class="header-section-number">1.1.4</span> The Four-Week Creation</h3>
<p>According to Thompson‚Äôs later recollections, Unix was created during
a four-week period when his family was on vacation:</p>
<ul>
<li><strong>Week 1</strong>: Written the kernel (process management,
system calls)</li>
<li><strong>Week 2</strong>: Implemented the file system</li>
<li><strong>Week 3</strong>: Created the editor (ed)</li>
<li><strong>Week 4</strong>: Built the assembler (as)</li>
</ul>
<p>While this timeline is somewhat mythologized‚Äîactual development took
longer‚Äîit captures the remarkable speed and simplicity of the original
Unix implementation.</p>
<h3 data-number="1.1.5" id="why-unix"><span class="header-section-number">1.1.5</span> Why ‚ÄúUnix‚Äù?</h3>
<p>The original name was <strong>‚ÄúUnics‚Äù</strong>‚ÄîUniplexed Information
and Computing Service‚Äîa pun on ‚ÄúMultics.‚Äù Where Multics aimed to
multiplex resources for many users simultaneously, Unics simplified
everything by handling one thing at a time well. The name eventually
became ‚ÄúUnix.‚Äù</p>
<h2 data-number="1.2" id="the-pdp-7-environment"><span class="header-section-number">1.2</span> The PDP-7 Environment</h2>
<h3 data-number="1.2.1" id="why-this-machine-mattered"><span class="header-section-number">1.2.1</span> Why This Machine
Mattered</h3>
<p>The PDP-7 was a significant constraint that shaped Unix‚Äôs
development:</p>
<h4 data-number="1.2.1.1" id="hardware-limitations"><span class="header-section-number">1.2.1.1</span> <strong>Hardware
Limitations</strong></h4>
<table>
<thead>
<tr>
<th>Specification</th>
<th>Value</th>
<th>Impact on Unix</th>
</tr>
</thead>
<tbody>
<tr>
<td>Word size</td>
<td>18 bits</td>
<td>Files measured in words, not bytes</td>
</tr>
<tr>
<td>Memory</td>
<td>8K words (16 KB)</td>
<td>Extreme minimalism required</td>
</tr>
<tr>
<td>Mass storage</td>
<td>DECtape</td>
<td>Limited filesystem space</td>
</tr>
<tr>
<td>CPU speed</td>
<td>~1.75 Œºs cycle</td>
<td>Performance-conscious code</td>
</tr>
<tr>
<td>Price</td>
<td>~$72,000 (1965)</td>
<td>Accessible for research lab</td>
</tr>
</tbody>
</table>
<h4 data-number="1.2.1.2" id="the-18-bit-architecture"><span class="header-section-number">1.2.1.2</span> <strong>The 18-Bit
Architecture</strong></h4>
<p>Unlike modern 8-bit byte-oriented architectures, the PDP-7 used
<strong>18-bit words</strong>. This affected everything:</p>
<ul>
<li><strong>Character storage</strong>: 2 characters per word (9 bits
each, supporting 512 possible characters)</li>
<li><strong>File sizes</strong>: Measured in words, not bytes</li>
<li><strong>Addressing</strong>: Octal (base-8) notation natural for
18-bit words</li>
<li><strong>Pointers</strong>: Word addresses, not byte addresses</li>
</ul>
<p>This is why early Unix source code uses octal notation
pervasively:</p>
<pre class="assembly"><code>" Octal notation in PDP-7 assembly
lac 0177        " Load accumulator with octal 177 (decimal 127)
dac 017777      " Store at location 17777 octal (decimal 8191)</code></pre>
<h3 data-number="1.2.2" id="the-development-environment"><span class="header-section-number">1.2.2</span> The Development
Environment</h3>
<p>Creating Unix on the PDP-7 presented unique challenges:</p>
<h4 data-number="1.2.2.1" id="cross-development"><span class="header-section-number">1.2.2.1</span>
<strong>Cross-Development</strong></h4>
<p>Initially, Thompson wrote the assembler on the <strong>GE 635
mainframe</strong> running GECOS (the successor to Multics at Bell
Labs):</p>
<ol type="1">
<li>Write PDP-7 assembly code on the GE 635</li>
<li>Cross-assemble to PDP-7 machine code</li>
<li>Punch output to paper tape</li>
<li>Physically carry paper tape to PDP-7</li>
<li>Load paper tape into PDP-7 memory</li>
<li>Debug by examining core dumps</li>
</ol>
<p>This tedious process continued until the PDP-7 could self-host‚Äîthat
is, until Unix itself could run the assembler and tools needed to
develop Unix.</p>
<h4 data-number="1.2.2.2" id="self-hosting-achievement"><span class="header-section-number">1.2.2.2</span> <strong>Self-Hosting
Achievement</strong></h4>
<p>A crucial milestone came when Unix became
<strong>self-hosting</strong>:</p>
<ul>
<li>The <strong>assembler (as.s)</strong> could assemble itself</li>
<li>The <strong>editor (ed1.s, ed2.s)</strong> could edit its own source
code</li>
<li>The <strong>debugger (db.s)</strong> could debug programs that
crashed</li>
<li>System utilities could be developed entirely on Unix</li>
</ul>
<p>This self-hosting capability proved Unix‚Äôs viability as a complete
operating system.</p>
<h2 data-number="1.3" id="the-source-code-we-have-today"><span class="header-section-number">1.3</span> The Source Code We Have
Today</h2>
<h3 data-number="1.3.1" id="a-miraculous-preservation"><span class="header-section-number">1.3.1</span> A Miraculous
Preservation</h3>
<p>The PDP-7 Unix source code could easily have been lost to history.
What we have today exists thanks to remarkable preservation efforts:</p>
<h4 data-number="1.3.1.1" id="the-original-printouts"><span class="header-section-number">1.3.1.1</span> <strong>1970-1971: The
Original Printouts</strong></h4>
<p>Dennis Ritchie kept <strong>printed listings</strong> of the PDP-7
Unix source code‚Äînearly 190 pages of line-printer output. These
printouts sat in his office at Bell Labs for decades.</p>
<h4 data-number="1.3.1.2" id="the-discovery"><span class="header-section-number">1.3.1.2</span> <strong>2019: The
Discovery</strong></h4>
<p>After Ritchie‚Äôs death in 2011, his papers were donated to the
<strong>Computer History Museum</strong>. In 2019, to commemorate Unix‚Äôs
50th anniversary, the museum made these printouts publicly accessible.
The source code listings included:</p>
<ul>
<li>Complete system source (s1.s through s9.s)</li>
<li>User utilities (cat, cp, ed, as, etc.)</li>
<li>Development tools (assembler, editor, debugger)</li>
<li>B language interpreter (bi.s)</li>
<li>Documentation (sysmap symbol table)</li>
</ul>
<h4 data-number="1.3.1.3" id="the-resurrection-project"><span class="header-section-number">1.3.1.3</span> <strong>The Resurrection
Project</strong></h4>
<p>Warren Toomey and the <strong>Unix Heritage Society (TUHS)</strong>
undertook a remarkable project:</p>
<ol type="1">
<li><strong>Scan</strong> the 190 pages of printouts</li>
<li><strong>OCR</strong> (Optical Character Recognition) the assembly
code</li>
<li><strong>Manually correct</strong> OCR errors</li>
<li><strong>Reconstruct</strong> the exact file structure</li>
<li><strong>Cross-assemble</strong> the code to verify correctness</li>
<li><strong>Run</strong> the resulting system in a PDP-7 simulator</li>
</ol>
<p>The <strong>pdp7-unix project</strong> successfully booted PDP-7 Unix
from these scanned printouts. The operating system that Thompson wrote
in 1969 runs again today‚Äîmore than 50 years later.</p>
<h3 data-number="1.3.2" id="what-this-repository-represents"><span class="header-section-number">1.3.2</span> What This Repository
Represents</h3>
<p>The <code>unix-history-repo</code> repository you‚Äôre reading about
contains:</p>
<p><strong>Git Commit Structure</strong>:</p>
<pre><code>185f8e8 - Empty repository at start of Unix Epoch (1970-01-01)
68ed7b9 - Add licenses and README (2021-01-01)
c7f751f - Start development on Research PDP7 (1970-06-30) [merge]
16fdb21 - Research PDP7 development (1970-06-30) [40 FILES]</code></pre>
<p>The dates are symbolic: - <strong>January 1, 1970</strong> = Unix
Epoch (time_t = 0, the beginning of Unix time) - <strong>June 30,
1970</strong> = Approximate date of PDP-7 Unix completion</p>
<p>The files represent Unix as it existed in mid-1970, before Unix was
rewritten in C, before it ran on the PDP-11, before it became the
foundation of the modern computing world.</p>
<h2 data-number="1.4" id="why-this-code-matters"><span class="header-section-number">1.4</span> Why This Code Matters</h2>
<h3 data-number="1.4.1" id="historical-significance"><span class="header-section-number">1.4.1</span> Historical Significance</h3>
<p>This code represents:</p>
<ol type="1">
<li><strong>First Unix</strong>: The original implementation by Thompson
and Ritchie</li>
<li><strong>Last assembly Unix</strong>: All later versions were
rewritten in C</li>
<li><strong>Design principles</strong>: Core Unix concepts in their
purest form</li>
<li><strong>Proof of concept</strong>: Demonstrated that a small team
could build a complete OS</li>
<li><strong>Foundation</strong>: Direct ancestor of Linux, BSD, macOS,
iOS, Android</li>
</ol>
<h3 data-number="1.4.2" id="technical-significance"><span class="header-section-number">1.4.2</span> Technical Significance</h3>
<p>The PDP-7 Unix demonstrated several revolutionary concepts:</p>
<h4 data-number="1.4.2.1" id="hierarchical-file-system"><span class="header-section-number">1.4.2.1</span> <strong>1. Hierarchical
File System</strong></h4>
<p>Before Unix, most systems had flat file structures. Unix
introduced:</p>
<ul>
<li><strong>Directories</strong> as special files containing
name-to-inode mappings</li>
<li><strong>Hierarchical organization</strong> with <code>/</code> root
directory</li>
<li><strong>Path-based navigation</strong> (added in later PDP-7
versions)</li>
<li><strong>Unified namespace</strong> treating devices as files</li>
</ul>
<pre class="assembly"><code>" Directory entry structure (from s8.s)
" d.i    - inode number (1 word)
" d.name - filename (4 words, 3 chars/word)
" d.uniq - unique ID (1 word)
" Total: 6 words per directory entry</code></pre>
<h4 data-number="1.4.2.2" id="process-abstraction"><span class="header-section-number">1.4.2.2</span> <strong>2. Process
Abstraction</strong></h4>
<p>Unix provided clean process primitives:</p>
<ul>
<li><strong>fork()</strong> - Create child process (copy of parent)</li>
<li><strong>exit()</strong> - Terminate process</li>
<li><strong>Interprocess communication</strong> via message passing
(smes/rmes)</li>
</ul>
<p>This process model persists in Unix and Linux today:</p>
<pre class="assembly"><code>" Process creation (from s3.s)
.fork:
   lac procmax         " Get maximum process number
   dac i u.namep       " Store as new process ID
   " ... create new process table entry
   " ... copy parent's memory to disk
   " ... set up child's state</code></pre>
<h4 data-number="1.4.2.3" id="simple-but-complete-io-model"><span class="header-section-number">1.4.2.3</span> <strong>3. Simple but
Complete I/O Model</strong></h4>
<p>Unix unified file and device I/O:</p>
<ul>
<li>Same system calls (read/write) for files and devices</li>
<li>Character devices handled through queue abstraction</li>
<li>Block devices (disk) accessed through buffer cache</li>
</ul>
<pre class="assembly"><code>" Reading from file or device uses same interface
sys read; buffer; count</code></pre>
<h4 data-number="1.4.2.4" id="minimalist-design-philosophy"><span class="header-section-number">1.4.2.4</span> <strong>4. Minimalist
Design Philosophy</strong></h4>
<p>The entire PDP-7 Unix consists of:</p>
<table>
<thead>
<tr>
<th>Component</th>
<th>Lines of Code</th>
</tr>
</thead>
<tbody>
<tr>
<td>Kernel (s1-s9)</td>
<td>~2,500</td>
</tr>
<tr>
<td>Utilities</td>
<td>~2,500</td>
</tr>
<tr>
<td>Development tools</td>
<td>~3,000</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td><strong>~8,000</strong></td>
</tr>
</tbody>
</table>
<p>Compare this to modern systems: - Linux kernel: ~30 million lines -
Windows: ~50 million lines</p>
<p>Yet PDP-7 Unix was a complete, self-hosting operating system.</p>
<h3 data-number="1.4.3" id="cultural-impact"><span class="header-section-number">1.4.3</span> Cultural Impact</h3>
<p>Unix introduced cultural practices that shaped software
development:</p>
<h4 data-number="1.4.3.1" id="open-development"><span class="header-section-number">1.4.3.1</span> <strong>Open
Development</strong></h4>
<p>While not ‚Äúopen source‚Äù in the modern sense, Unix spread through: -
Academic licenses (universities could get source code) - Source code
included with distributions - Collaborative development culture</p>
<h4 data-number="1.4.3.2" id="documentation-philosophy"><span class="header-section-number">1.4.3.2</span> <strong>Documentation
Philosophy</strong></h4>
<p>The concept of <strong>manual pages</strong> (man pages) started with
Unix: - One page per command - Standard format (NAME, SYNOPSIS,
DESCRIPTION) - Comprehensive reference always available</p>
<h4 data-number="1.4.3.3" id="tool-composition"><span class="header-section-number">1.4.3.3</span> <strong>Tool
Composition</strong></h4>
<p>The Unix philosophy of <strong>small tools composed via
pipes</strong> emerged from this era:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a aria-hidden="true" href="#cb7-1" tabindex="-1"></a><span class="co"># Modern example of Unix philosophy</span></span>
<span id="cb7-2"><a aria-hidden="true" href="#cb7-2" tabindex="-1"></a><span class="fu">cat</span> file.txt <span class="kw">|</span> <span class="fu">grep</span> <span class="st">"error"</span> <span class="kw">|</span> <span class="fu">sort</span> <span class="kw">|</span> <span class="fu">uniq</span> <span class="kw">|</span> <span class="fu">wc</span> <span class="at">-l</span></span></code></pre></div>
<p>Though pipes came in later PDP-11 versions, the principle of small,
focused tools originated with PDP-7 Unix.</p>
<h2 data-number="1.5" id="the-evolution-path"><span class="header-section-number">1.5</span> The Evolution Path</h2>
<h3 data-number="1.5.1" id="from-pdp-7-to-pdp-11"><span class="header-section-number">1.5.1</span> From PDP-7 to PDP-11</h3>
<p>By 1971, Bell Labs acquired a <strong>PDP-11/20</strong>, a more
capable machine:</p>
<ul>
<li><strong>16-bit words</strong> (more conventional than 18-bit)</li>
<li><strong>Byte addressing</strong> (8-bit bytes)</li>
<li><strong>More memory</strong> (up to 256 KB)</li>
<li><strong>Better performance</strong></li>
</ul>
<p>Thompson and Ritchie rewrote Unix in PDP-11 assembly, improving and
extending it. This became <strong>Unix Version 1</strong> (V1), released
in 1971.</p>
<h3 data-number="1.5.2" id="the-invention-of-c"><span class="header-section-number">1.5.2</span> The Invention of C</h3>
<p>In 1972, Dennis Ritchie created the <strong>C programming
language</strong>, evolving it from:</p>
<ul>
<li><strong>B language</strong> (Ken Thompson, 1969) - untyped,
interpreted</li>
<li><strong>BCPL</strong> (Martin Richards, 1966) - systems programming
language</li>
</ul>
<p>By 1973, Unix was <strong>rewritten in C</strong>‚Äîan unprecedented
achievement. Operating systems were written in assembly; using a
high-level language was considered impractical. But C was designed
specifically to be efficient enough for systems programming.</p>
<p>This decision made Unix <strong>portable</strong>. Instead of
rewriting the entire system for each new computer, only the small
machine-dependent parts needed to change. Unix could‚Äîand did‚Äîrun on
dozens of different architectures.</p>
<h3 data-number="1.5.3" id="the-explosive-growth"><span class="header-section-number">1.5.3</span> The Explosive Growth</h3>
<p>From PDP-7 Unix‚Äôs humble beginning, Unix spread rapidly:</p>
<ul>
<li><strong>1970s</strong>: Research Unix (V1-V7), BSD Unix at UC
Berkeley</li>
<li><strong>1980s</strong>: System V (AT&amp;T), SunOS, HP-UX, AIX</li>
<li><strong>1990s</strong>: Linux (Linus Torvalds), FreeBSD, NetBSD,
OpenBSD</li>
<li><strong>2000s</strong>: Mac OS X (based on BSD), Android (Linux
kernel)</li>
<li><strong>2020s</strong>: Unix and Unix-like systems power the vast
majority of servers, smartphones, and embedded devices</li>
</ul>
<h2 data-number="1.6" id="reading-this-book-in-context"><span class="header-section-number">1.6</span> Reading This Book in
Context</h2>
<h3 data-number="1.6.1" id="what-youll-learn"><span class="header-section-number">1.6.1</span> What You‚Äôll Learn</h3>
<p>This comprehensive reference will teach you:</p>
<ol type="1">
<li><strong>How an operating system actually works</strong> - Not
abstract theory, but concrete implementation</li>
<li><strong>Assembly language programming</strong> - PDP-7 assembly in
detail</li>
<li><strong>Historical computing</strong> - How programmers worked with
severe constraints</li>
<li><strong>System design principles</strong> - Lessons that remain
relevant today</li>
<li><strong>Software archaeology</strong> - How to read and understand
legacy code</li>
</ol>
<h3 data-number="1.6.2" id="what-makes-this-code-special"><span class="header-section-number">1.6.2</span> What Makes This Code
Special</h3>
<p>Unlike learning from modern systems:</p>
<ul>
<li><strong>Small enough to understand completely</strong> - 8,000 lines
vs.¬†millions</li>
<li><strong>No abstractions hiding complexity</strong> - Direct hardware
access throughout</li>
<li><strong>Every line serves a purpose</strong> - No cruft, no legacy
compatibility layers</li>
<li><strong>Elegant simplicity</strong> - Core concepts without decades
of additions</li>
</ul>
<h3 data-number="1.6.3" id="the-challenge-and-the-reward"><span class="header-section-number">1.6.3</span> The Challenge and the
Reward</h3>
<p>Reading 1960s assembly code is challenging:</p>
<ul>
<li><strong>Octal arithmetic</strong> instead of decimal or
hexadecimal</li>
<li><strong>18-bit words</strong> instead of bytes</li>
<li><strong>Minimal comments</strong> (Ken Thompson was famously
terse)</li>
<li><strong>Archaic syntax</strong> and conventions</li>
</ul>
<p>But the reward is profound understanding. By the time you finish this
book, you will understand:</p>
<ul>
<li>How a computer boots from nothing</li>
<li>How files are stored and retrieved</li>
<li>How processes are created and scheduled</li>
<li>How programs are assembled and executed</li>
<li>How a complete operating system fits in 8,000 lines of code</li>
</ul>
<h2 data-number="1.7" id="document-structure"><span class="header-section-number">1.7</span> Document Structure</h2>
<p>This reference is organized as follows:</p>
<h3 data-number="1.7.1" id="part-i-foundations-chapters-1-4"><span class="header-section-number">1.7.1</span> Part I: Foundations (Chapters
1-4)</h3>
<p><strong>Chapter 1</strong> (this chapter) - Historical context and
introduction <strong>Chapter 2</strong> - PDP-7 hardware architecture in
detail <strong>Chapter 3</strong> - Assembly language programming guide
<strong>Chapter 4</strong> - System architecture overview</p>
<h3 data-number="1.7.2" id="part-ii-the-kernel-chapters-5-9"><span class="header-section-number">1.7.2</span> Part II: The Kernel (Chapters
5-9)</h3>
<p><strong>Chapter 5</strong> - Kernel internals (s1.s through s9.s)
<strong>Chapter 6</strong> - Boot process and initialization
<strong>Chapter 7</strong> - File system implementation <strong>Chapter
8</strong> - Process management <strong>Chapter 9</strong> - Device
drivers and I/O</p>
<h3 data-number="1.7.3" id="part-iii-user-space-chapters-10-12"><span class="header-section-number">1.7.3</span> Part III: User Space
(Chapters 10-12)</h3>
<p><strong>Chapter 10</strong> - Development tools (assembler, editor,
debugger) <strong>Chapter 11</strong> - User utilities (cat, cp, chmod,
etc.) <strong>Chapter 12</strong> - The B language system</p>
<h3 data-number="1.7.4" id="part-iv-analysis-and-legacy-chapters-13-14"><span class="header-section-number">1.7.4</span> Part IV: Analysis and Legacy
(Chapters 13-14)</h3>
<p><strong>Chapter 13</strong> - Code evolution and development patterns
<strong>Chapter 14</strong> - Legacy and impact on modern systems</p>
<h3 data-number="1.7.5" id="appendices"><span class="header-section-number">1.7.5</span> Appendices</h3>
<p><strong>Appendix A</strong> - Complete instruction set reference
<strong>Appendix B</strong> - System call reference <strong>Appendix
C</strong> - Symbol table (sysmap) <strong>Appendix D</strong> -
Glossary of terms <strong>Appendix E</strong> - Index <strong>Appendix
F</strong> - Bibliography and references <strong>Appendix G</strong> -
Complete source code listings</p>
<h2 data-number="1.8" id="begin-your-journey"><span class="header-section-number">1.8</span> Begin Your Journey</h2>
<p>You are about to explore one of computing‚Äôs greatest treasures‚Äîthe
source code that started the Unix revolution. Whether you‚Äôre a student,
professional programmer, computer historian, or simply curious, this
journey will deepen your understanding of how computers really work.</p>
<p>In the following chapters, we‚Äôll examine every line of code, every
system call, every clever optimization. We‚Äôll see how Thompson and
Ritchie achieved the seemingly impossible: a complete, self-hosting
operating system in just 8,000 lines of assembly code.</p>
<p>Welcome to the genesis of Unix.</p>
<hr/>
<p><em>‚ÄúUnix is simple and coherent, but it takes a genius (or at any
rate a programmer) to understand and appreciate the simplicity.‚Äù</em> ‚Äî
Dennis Ritchie, 1984</p>
<h1 data-number="2" id="chapter-2-pdp-7-hardware-architecture"><span class="header-section-number">2</span> Chapter 2: PDP-7 Hardware
Architecture</h1>
<h2 data-number="2.1" id="introduction"><span class="header-section-number">2.1</span> Introduction</h2>
<p>To understand PDP-7 Unix, you must first understand the machine it
ran on. The <strong>Digital Equipment Corporation PDP-7</strong> was a
minicomputer introduced in 1964, part of DEC‚Äôs revolutionary Programmed
Data Processor series. While obsolete by 1969, its unique architecture
profoundly influenced Unix‚Äôs design.</p>
<p>This chapter provides a complete technical reference to the PDP-7
hardware. By the end, you will understand:</p>
<ul>
<li>How 18-bit words shaped every aspect of Unix</li>
<li>The elegant simplicity of a 16-instruction computer</li>
<li>Memory addressing techniques that maximized limited resources</li>
<li>I/O mechanisms for peripheral devices</li>
<li>Assembly language programming for the PDP-7</li>
</ul>
<p>Understanding this hardware is essential‚ÄîUnix wasn‚Äôt designed
<em>despite</em> the PDP-7‚Äôs constraints, but <em>because of them</em>.
The hardware‚Äôs limitations forced Thompson and Ritchie to create
elegant, minimal solutions that became Unix‚Äôs defining
characteristics.</p>
<hr/>
<h2 data-number="2.2" id="cpu-architecture"><span class="header-section-number">2.2</span> 1. CPU Architecture</h2>
<h3 data-number="2.2.1" id="the-18-bit-word"><span class="header-section-number">2.2.1</span> The 18-Bit Word</h3>
<p>The PDP-7‚Äôs most distinctive feature was its <strong>18-bit word
size</strong>. This wasn‚Äôt arbitrary‚ÄîDEC chose 18 bits to efficiently
encode both data and instructions:</p>
<pre><code>18-bit word structure:
‚îå‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚îê
‚îÇ17‚îÇ16‚îÇ15‚îÇ14‚îÇ13‚îÇ12‚îÇ11‚îÇ10‚îÇ9‚îÇ8‚îÇ7‚îÇ6‚îÇ5‚îÇ4‚îÇ3‚îÇ2‚îÇ1‚îÇ0‚îÇ  Bit positions
‚îî‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚îò

Octal representation (6 digits):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 5  ‚îÇ 4  ‚îÇ 3  ‚îÇ 2  ‚îÇ 1  ‚îÇ 0  ‚îÇ  Octal digit positions
‚îÇbits‚îÇbits‚îÇbits‚îÇbits‚îÇbits‚îÇbits‚îÇ
‚îÇ17-‚îÇ15-‚îÇ12-‚îÇ 9- ‚îÇ 6- ‚îÇ 3- ‚îÇ
‚îÇ 16‚îÇ 14‚îÇ 11‚îÇ 8  ‚îÇ 5  ‚îÇ 2  ‚îÇ 0‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
<p><strong>Why 18 bits?</strong></p>
<ol type="1">
<li><strong>Instruction encoding</strong>: 3 bits for opcode + 1 bit for
indirect + 1 bit for index + 13 bits for address</li>
<li><strong>Character storage</strong>: 9 bits per character (supporting
ASCII + extensions), 2 characters per word</li>
<li><strong>Numeric range</strong>: Signed: -131,072 to +131,071;
Unsigned: 0 to 262,143</li>
<li><strong>Octal notation</strong>: 18 bits = exactly 6 octal digits
(000000 to 777777)</li>
</ol>
<p><strong>Implications for Unix:</strong></p>
<pre class="assembly"><code>" Character packing example from cat.s
" Each word holds TWO 9-bit characters

   lac ipt           " Load input pointer
   ral               " Rotate accumulator left (bit 17 ‚Üí Link)
   lac ipt i         " Load word from memory
   szl               " Skip if Link is zero (even character)
   lrss 9            " Link-Right-Shift 9 bits (odd character)
   and o177          " Mask to 7-bit ASCII (0177 octal = 127 decimal)</code></pre>
<p>This code extracts individual characters from packed word storage: -
Bit 17 (Link after rotation) indicates which character (0=left, 1=right)
- Left character occupies bits 17-9 - Right character occupies bits 8-0
- Masking with <code>0177</code> strips to 7-bit ASCII</p>
<h3 data-number="2.2.2" id="register-set"><span class="header-section-number">2.2.2</span> Register Set</h3>
<p>The PDP-7 had a minimal register set‚Äîjust four programmer-visible
registers:</p>
<h4 data-number="2.2.2.1" id="ac-accumulator---18-bits"><span class="header-section-number">2.2.2.1</span> AC (Accumulator) - 18
bits</h4>
<p>The <strong>primary working register</strong> for all arithmetic and
logical operations.</p>
<pre class="assembly"><code>" AC examples from init.s

   lac d1            " Load AC with contents of location 'd1'
                     " (d1 contains constant 1)

   dac pid1          " Deposit AC to location 'pid1'
                     " (Store process ID)

   -1                " This is a literal: sets AC to -1 (777777 octal)
                     " In two's complement: all bits set

   cla               " Clear AC (set to 0)</code></pre>
<p><strong>AC operations:</strong> - <code>lac</code> (Load AC): AC ‚Üê
memory[address] - <code>dac</code> (Deposit AC): memory[address] ‚Üê AC -
<code>cla</code> (Clear AC): AC ‚Üê 0 - Arithmetic results always go to AC
- Logical operations operate on AC</p>
<h4 data-number="2.2.2.2" id="mq-multiplier-quotient---18-bits"><span class="header-section-number">2.2.2.2</span> MQ (Multiplier-Quotient) -
18 bits</h4>
<p>The <strong>secondary register</strong> for double-precision
operations, multiply, divide, and shifts.</p>
<pre class="assembly"><code>" MQ examples from init.s

   lacq              " Load AC from MQ (AC ‚Üê MQ)

   lmq               " Load MQ from AC (MQ ‚Üê AC)

   " Character conversion using MQ
   tad om60          " Add -060 (octal) to AC
   lmq               " Save in MQ
   lac nchar         " Load previous value
   cll; als 3        " Clear Link; Arithmetic Left Shift 3 bits
   omq               " OR with MQ
   dac nchar         " Store result</code></pre>
<p><strong>MQ operations:</strong> - <code>lmq</code> (Load MQ): MQ ‚Üê AC
- <code>lacq</code> (Load AC from MQ): AC ‚Üê MQ - <code>omq</code> (OR
with MQ): AC ‚Üê AC | MQ - Used for: shift operations, multiplication,
division, temporary storage</p>
<h4 data-number="2.2.2.3" id="link-1-bit"><span class="header-section-number">2.2.2.3</span> Link (1 bit)</h4>
<p>The <strong>carry/overflow bit</strong> for arithmetic and the
<strong>17th bit</strong> for rotations.</p>
<pre class="assembly"><code>" Link examples from cat.s

   cll               " Clear Link (Link ‚Üê 0)

   rcr               " Rotate Combined Right
                     " (Link, AC) right 1 bit: Link ‚Üê AC[0], AC ‚Üê Link,AC[17:1]

   ral               " Rotate AC Left
                     " Link ‚Üê AC[17], AC ‚Üê AC[16:0],Link

   szl               " Skip if Link Zero
   snl               " Skip if Link Non-zero</code></pre>
<p><strong>Link uses:</strong> 1. <strong>Carry flag</strong>:
Addition/subtraction carry/borrow 2. <strong>Rotation bit</strong>:
19-bit rotate (Link + 18-bit AC) 3. <strong>Condition testing</strong>:
Skip instructions test Link state 4. <strong>Character
selection</strong>: Odd/even character in word</p>
<p>Example showing Link in arithmetic:</p>
<pre class="assembly"><code>" Adding two double-precision numbers (36 bits each)
" Low word addition
   lac num1_low      " Load low word of first number
   tad num2_low      " Add low word of second number
                     " Link receives carry-out
   dac result_low    " Store low word result

" High word addition (with carry)
   lac num1_high     " Load high word of first number
   tad num2_high     " Add high word of second number
                     " Link from previous add is carry-in
   dac result_high   " Store high word result</code></pre>
<h4 data-number="2.2.2.4" id="pc-program-counter---13-bits"><span class="header-section-number">2.2.2.4</span> PC (Program Counter) - 13
bits</h4>
<p>The <strong>instruction pointer</strong>, automatically incremented
after each instruction fetch.</p>
<p><strong>PC characteristics:</strong> - <strong>13 bits wide</strong>
(addresses 0 to 07777 octal = 8191 decimal) - <strong>Maximum
memory</strong>: 8K words (8192 words = 16 KB) -
<strong>Auto-increment</strong>: PC ‚Üê PC + 1 after fetch -
<strong>Branch target</strong>: Jump/JMS instructions load new value
into PC</p>
<pre class="assembly"><code>" PC manipulation (implicit in all code)

loop:                 " Label defines address
   lac counter        " PC = address of 'lac counter'
   tad d1             " PC = PC + 1 (points to 'tad d1')
   dac counter        " PC = PC + 1 (points to 'dac counter')
   sad limit          " PC = PC + 1 (points to 'sad limit')
   jmp loop           " PC ‚Üê address of 'loop' (branch taken)
                      " or PC = PC + 1 (branch not taken)</code></pre>
<p><strong>PC cannot be directly accessed</strong> by programs. Only
branch instructions modify it.</p>
<h4 data-number="2.2.2.5" id="ma-memory-address-register---13-bits"><span class="header-section-number">2.2.2.5</span> MA (Memory Address
Register) - 13 bits</h4>
<p>The <strong>internal register</strong> holding the current memory
address being accessed. Not directly programmer-visible.</p>
<p><strong>MA is automatically set by:</strong> 1. Instruction fetch: MA
‚Üê PC 2. Memory reference: MA ‚Üê instruction address field 3. Indirect
addressing: MA ‚Üê memory[MA] 4. Auto-increment: MA ‚Üê memory[MA],
memory[MA] ‚Üê memory[MA] + 1</p>
<h3 data-number="2.2.3" id="auto-increment-registers"><span class="header-section-number">2.2.3</span> Auto-Increment Registers</h3>
<p>The PDP-7 implemented a clever optimization: <strong>memory locations
010 through 017 (octal) auto-increment when used
indirectly</strong>.</p>
<pre><code>Auto-increment locations (octal):
010, 011, 012, 013, 014, 015, 016, 017

These are normal memory locations, but with special behavior:
- Direct access: Normal read/write
- Indirect access: Read value, then increment location</code></pre>
<p><strong>Example from cat.s:</strong></p>
<pre class="assembly"><code>" Setup: Location 8 (010 octal) contains 4096
" Goal: Zero out 64 words starting at address 4096

   law 4096-1        " Load AC with 4096-1 = 4095
   dac 8             " Store in location 010 (octal) = 8 (decimal)
                     " Register 8 now points to address 4095

1:
   dzm 8 i           " Deposit Zero to Memory at address in loc 8
                     " 1st iteration: zeros memory[4095], then 8 ‚Üê 8+1 = 4096
                     " 2nd iteration: zeros memory[4096], then 8 ‚Üê 8+1 = 4097
                     " 3rd iteration: zeros memory[4097], then 8 ‚Üê 8+1 = 4098
                     " ... and so on

   isz tal           " Increment and Skip if Zero (loop control)
   lac tal           " Load counter
   sad ebufp         " Skip if AC equals end pointer
   skp               " Skip next instruction
   jmp 1b            " Jump back to label 1</code></pre>
<p><strong>Why auto-increment locations 10-17?</strong></p>
<pre><code>Octal 010-017 = Binary 001000 through 001111
                              ‚Üë
                        Bit pattern: 001xxx

PDP-7 hardware checks if address bits [15:13] = 001
If YES and INDIRECT addressing: auto-increment
If NO or DIRECT addressing: normal access</code></pre>
<p><strong>Detailed mechanics:</strong></p>
<pre class="assembly"><code>" Normal memory location (example: location 100 octal)
   lac 100           " AC ‚Üê memory[100]
   lac 100 i         " AC ‚Üê memory[memory[100]]  (indirect)
                     " memory[100] unchanged

" Auto-increment location (example: location 010 octal = location 8)
   lac 8             " AC ‚Üê memory[8]  (direct - no increment!)
   lac 8 i           " AC ‚Üê memory[memory[8]]  (indirect - increments!)
                     " THEN: memory[8] ‚Üê memory[8] + 1</code></pre>
<p><strong>Common usage patterns:</strong></p>
<pre class="assembly"><code>" Pattern 1: Array traversal
   law array-1       " Start one before array
   dac 10            " Use location 10 (auto-increment register)
loop:
   lac 10 i          " Get next array element, auto-increment
   " ... process element ...
   jmp loop          " Repeat

" Pattern 2: String copy
   law source-1
   dac 8             " R8 = source pointer
   law dest-1
   dac 9             " R9 = destination pointer
copy:
   lac 8 i           " Get source character, increment source
   dac 9 i           " Store to destination, increment destination
   sna               " Skip if Not zero (AC != 0)
   jmp done          " If zero, done
   jmp copy          " Continue copying</code></pre>
<p>From <strong>init.s</strong>, actual Unix kernel code:</p>
<pre class="assembly"><code>" Copy boot code to high memory (017700 octal)
   law 017700        " Load AC with address 017700
   dac 9             " R9 = destination (017700)
   law boot-1        " Start one before 'boot' label
   dac 8             " R8 = source pointer
1:
   lac 8 i           " Load from source, auto-increment R8
   dac 9 i           " Store to destination, auto-increment R9
   sza               " Skip if Zero
   jmp 1b            " Continue until zero word encountered
   jmp 017701        " Jump to copied code</code></pre>
<p>This compact loop copies an entire code segment with just 6
instructions!</p>
<p><strong>All 8 auto-increment registers:</strong></p>
<table>
<thead>
<tr>
<th>Octal</th>
<th>Decimal</th>
<th>Typical Use in Unix</th>
</tr>
</thead>
<tbody>
<tr>
<td>010</td>
<td>8</td>
<td>General pointer (R8)</td>
</tr>
<tr>
<td>011</td>
<td>9</td>
<td>General pointer (R9)</td>
</tr>
<tr>
<td>012</td>
<td>10</td>
<td>Stack pointer / Array index</td>
</tr>
<tr>
<td>013</td>
<td>11</td>
<td>String pointer</td>
</tr>
<tr>
<td>014</td>
<td>12</td>
<td>Buffer pointer</td>
</tr>
<tr>
<td>015</td>
<td>13</td>
<td>Temporary pointer</td>
</tr>
<tr>
<td>016</td>
<td>14</td>
<td>Loop counter</td>
</tr>
<tr>
<td>017</td>
<td>15</td>
<td>Saved pointer</td>
</tr>
</tbody>
</table>
<p><strong>Performance benefit:</strong></p>
<p>Without auto-increment:</p>
<pre class="assembly"><code>loop:
   lac ptr           " Load pointer (1 instruction)
   dac tempaddr      " Store as address (1 instruction)
   lac tempaddr i    " Load indirect (1 instruction)
   " ... process ...
   isz ptr           " Increment pointer (1 instruction)
   jmp loop          " 4 instructions per iteration</code></pre>
<p>With auto-increment:</p>
<pre class="assembly"><code>loop:
   lac 8 i           " Load indirect with auto-increment (1 instruction)
   " ... process ...
   jmp loop          " 1 instruction per iteration</code></pre>
<p><strong>4√ó reduction in instructions for pointer-heavy
code!</strong></p>
<hr/>
<h2 data-number="2.3" id="instruction-set-architecture"><span class="header-section-number">2.3</span> 2. Instruction Set
Architecture</h2>
<p>The PDP-7 achieved remarkable simplicity with just <strong>16
instructions</strong>‚Äîyet provided enough power to build a complete
operating system.</p>
<h3 data-number="2.3.1" id="instruction-encoding-format"><span class="header-section-number">2.3.1</span> Instruction Encoding
Format</h3>
<p>Every instruction occupies one 18-bit word:</p>
<pre><code>Memory Reference Instructions (OPR, LAC, DAC, XOR, ADD, TAD, ISZ, AND, SAD, JMP):
‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇOPR‚îÇI‚îÇX‚îÇ   ADDRESS      ‚îÇ  18 bits total
‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 3b  1b 1b     13 bits

OPR (bits 17-15): Operation code (3 bits = 8 possible operations)
I   (bit 14):     Indirect bit (0=direct, 1=indirect)
X   (bit 13):     Index bit (used in some machines, usually 0 on PDP-7)
ADDRESS (12-0):   Memory address (13 bits = 8192 words)

Microprogrammed Instructions (OPR):
‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ110‚îÇ  MICROCODE BITS   ‚îÇ  18 bits total
‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 3b        15 bits

OPR=110 (octal 6): Signals microprogrammed operation
MICROCODE: Bit pattern selects operation(s)</code></pre>
<p><strong>Instruction format examples:</strong></p>
<pre class="assembly"><code>" Memory reference instruction breakdown:
   lac 4096          " Load AC from address 4096

Binary encoding:
   001 0 0 0001000000000000
   ‚îÇ   ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
   ‚îÇ   ‚îÇ ‚îÇ      4096 decimal = 010000 octal
   ‚îÇ   ‚îÇ ‚îî‚îÄ X bit = 0 (no indexing)
   ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ I bit = 0 (direct addressing)
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ OPR = 001 (LAC opcode)

Octal representation: 010000
                      ‚îÇ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îò
                      ‚îÇ  address
                      ‚îî‚îÄ opcode + mode bits

" Indirect addressing:
   lac 100 i         " Load AC from memory[memory[100]]

Binary encoding:
   001 1 0 0000000001000000
       ‚Üë
   I bit = 1 (indirect)

Octal representation: 030100
                      ‚îÇ‚îÇ
                      ‚îÇ‚îî‚îÄ address = 100 octal
                      ‚îî‚îÄ‚îÄ opcode=01, I=1 = 03 octal

" Microprogrammed instruction:
   cla               " Clear AC

Binary encoding:
   110 000000100000000
   ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
   ‚îÇ        bit 11 = 1 (CLA operation)
   ‚îî‚îÄ OPR = 110 (microcode)

Octal representation: 600400</code></pre>
<h3 data-number="2.3.2" id="complete-16-instruction-set"><span class="header-section-number">2.3.2</span> Complete 16-Instruction
Set</h3>
<h4 data-number="2.3.2.1" id="group-1-memory-reference-instructions-8-instructions"><span class="header-section-number">2.3.2.1</span> Group 1: Memory Reference
Instructions (8 instructions)</h4>
<p>These instructions access memory and have the general format:
<code>opcode [i] address</code></p>
<h5 data-number="2.3.2.1.1" id="lac---load-ac"><span class="header-section-number">2.3.2.1.1</span> 1. LAC - Load AC</h5>
<p><strong>Encoding:</strong> <code>001</code> (octal
<code>02xxxx</code> direct, <code>03xxxx</code> indirect)
<strong>Operation:</strong> <code>AC ‚Üê memory[address]</code>
<strong>Flags affected:</strong> None</p>
<pre class="assembly"><code>" Examples from cat.s and init.s

   lac d1            " Load AC with contents of address 'd1'
                     " AC ‚Üê memory[d1]  (d1 contains value 1)

   lac 017777 i      " Load AC with memory[memory[017777]]
                     " Indirect: AC ‚Üê memory[memory[017777]]
                     " Used to access command-line argument count

   lac ipt           " Load input pointer
                     " AC ‚Üê memory[ipt]</code></pre>
<p><strong>Use cases:</strong> - Loading variables into AC for
processing - Reading pointers for indirect addressing - Retrieving
constants - Reading from I/O device registers</p>
<h5 data-number="2.3.2.1.2" id="dac---deposit-ac"><span class="header-section-number">2.3.2.1.2</span> 2. DAC - Deposit AC</h5>
<p><strong>Encoding:</strong> <code>021</code> (octal
<code>04xxxx</code> direct, <code>05xxxx</code> indirect)
<strong>Operation:</strong> <code>memory[address] ‚Üê AC</code>
<strong>Flags affected:</strong> None</p>
<pre class="assembly"><code>" Examples from actual Unix code

   dac fi            " Store AC to file descriptor variable
                     " memory[fi] ‚Üê AC

   dac 017777 i      " Store AC to memory[memory[017777]]
                     " Indirect: memory[memory[017777]] ‚Üê AC

   dac 8 i           " Store to address in location 8, then increment loc 8
                     " memory[memory[8]] ‚Üê AC
                     " memory[8] ‚Üê memory[8] + 1  (auto-increment!)</code></pre>
<p><strong>Use cases:</strong> - Storing computation results - Writing
to variables - Saving pointers - Writing to I/O device registers -
Building data structures with auto-increment</p>
<h5 data-number="2.3.2.1.3" id="isz---increment-and-skip-if-zero"><span class="header-section-number">2.3.2.1.3</span> 3. ISZ - Increment and
Skip if Zero</h5>
<p><strong>Encoding:</strong> <code>041</code> (octal
<code>10xxxx</code> direct, <code>11xxxx</code> indirect)
<strong>Operation:</strong>
<code>memory[address] ‚Üê memory[address] + 1; if result == 0 then PC ‚Üê PC + 1</code>
<strong>Flags affected:</strong> None (skip is side effect)</p>
<pre class="assembly"><code>" Example: Loop counting down from -64 to 0

   -64               " Load AC with -64 (negative count)
   dac count         " Store as counter

loop:
   " ... do work ...

   isz count         " Increment count: -64‚Üí-63‚Üí...‚Üí-1‚Üí0
                     " When count reaches 0, skip next instruction
   jmp loop          " Jump back to loop (skipped when count = 0)

   " ... continue after loop ...

count: 0

" Example from cat.s: Buffer management
   isz noc           " Increment number of characters
   lac noc           " Load count
   sad d128          " Skip if AC Different from 128
   skp               " Skip next
   jmp putc i        " Return if count &lt; 128

   " Flush buffer when count reaches 128
   lac fo
   sys write; iopt+1; 64</code></pre>
<p><strong>Use cases:</strong> - Loop counters (count up from negative)
- Reference counting - Buffer management - State machines</p>
<p><strong>Why count from negative to zero?</strong></p>
<pre class="assembly"><code>" Method 1: Counting down (requires ISZ + compare)
   lac limit         " Load limit (e.g., 64)
   dac count         " count = 64
loop1:
   " ... work ...
   -1
   tad count         " count = count - 1
   dac count
   sna               " Skip if Non-zero
   jmp done          " If zero, done
   jmp loop1         " Loop
done:
   " 6 instructions per iteration

" Method 2: Counting up from negative (requires only ISZ)
   -64               " Load -64
   dac count         " count = -64
loop2:
   " ... work ...
   isz count         " count++, skip if zero
   jmp loop2         " Loop
   " 2 instructions per iteration - 3√ó more efficient!</code></pre>
<h5 data-number="2.3.2.1.4" id="xor---exclusive-or"><span class="header-section-number">2.3.2.1.4</span> 4. XOR - Exclusive
OR</h5>
<p><strong>Encoding:</strong> <code>061</code> (octal
<code>14xxxx</code> direct, <code>15xxxx</code> indirect)
<strong>Operation:</strong> <code>AC ‚Üê AC ‚äï memory[address]</code>
<strong>Flags affected:</strong> None</p>
<pre class="assembly"><code>" Examples from init.s

   lac nchar i       " Load character word
   and o777000       " Mask upper 9 bits (left character)
   xor char          " XOR with new character
   dac nchar i       " Store result
                     " Effect: Replace lower 9 bits with 'char'

" Character packing example:
" Pack two 9-bit characters into one word

   lac char1         " Load first character (bits 8-0)
   alss 9            " Shift left 9 bits (now bits 17-9)
   xor char2         " XOR with second character (bits 8-0)
   dac word          " Store packed word

   " Result: [char1][char2] in bits [17-9][8-0]</code></pre>
<p><strong>Use cases:</strong> - Bit manipulation - Character
packing/unpacking - Toggling flags - Data encryption (simple XOR cipher)
- Checksums</p>
<p><strong>XOR properties:</strong></p>
<pre><code>A ‚äï 0 = A           " Identity
A ‚äï A = 0           " Self-inverse
A ‚äï B ‚äï B = A       " Cancellation</code></pre>
<h5 data-number="2.3.2.1.5" id="add---add-to-ac"><span class="header-section-number">2.3.2.1.5</span> 5. ADD - Add to AC</h5>
<p><strong>Encoding:</strong> <code>101</code> (octal
<code>20xxxx</code> direct, <code>21xxxx</code> indirect)
<strong>Operation:</strong> <code>AC ‚Üê AC + memory[address]</code> (no
Link update!) <strong>Flags affected:</strong> None (Link not
affected)</p>
<pre class="assembly"><code>" Note: ADD doesn't update Link (carry)
" Rarely used in PDP-7 Unix - TAD preferred

   lac value1        " Load first value
   add value2        " Add second value (no carry)
   dac result        " Store sum</code></pre>
<p><strong>ADD vs TAD:</strong> - <code>ADD</code>: Does NOT affect Link
(carry bit) - <code>TAD</code>: DOES affect Link (carry bit) - Unix code
almost always uses TAD - ADD exists for specific cases where Link must
be preserved</p>
<h5 data-number="2.3.2.1.6" id="tad---twos-complement-add"><span class="header-section-number">2.3.2.1.6</span> 6. TAD - Two‚Äôs complement
Add</h5>
<p><strong>Encoding:</strong> <code>121</code> (octal
<code>24xxxx</code> direct, <code>25xxxx</code> indirect)
<strong>Operation:</strong>
<code>{Link, AC} ‚Üê AC + memory[address]</code> (Link receives carry)
<strong>Flags affected:</strong> Link (carry/borrow)</p>
<pre class="assembly"><code>" Examples from Unix kernel (s1.s)

   lac dot+1         " Load current address
   tad d1            " Add 1 (increment)
   dac dot+1         " Store incremented value

   " Negative addition (subtraction)
   -1                " AC ‚Üê -1 (all bits set)
   tad u.rq+8        " AC ‚Üê AC + memory[u.rq+8] = -1 + address
   " Result: address - 1

   " Building addresses from base + offset
   lac name          " Load base address
   tad d4            " Add offset of 4 words
   dac name          " Store new address

" Multi-word arithmetic example:
" Add two 36-bit numbers (two words each)

   cll               " Clear Link
   lac num1_low      " Load low word of first number
   tad num2_low      " Add low word of second (Link = carry)
   dac result_low    " Store low result

   lac num1_high     " Load high word of first
   tad num2_high     " Add high word (Link from previous add is carry-in)
   dac result_high   " Store high result</code></pre>
<p><strong>Subtraction using TAD:</strong></p>
<pre class="assembly"><code>" To compute A - B, use A + (-B) with two's complement:

   lac minuend       " Load A
   -value            " This is a literal negative number
   dac result        " result = A - value

" Alternative: explicit negation
   lac subtrahend    " Load B
   cma               " Complement (one's complement)
   tad d1            " Add 1 (now two's complement: -B)
   tad minuend       " Add A
   dac result        " result = A - B</code></pre>
<h5 data-number="2.3.2.1.7" id="sad---skip-if-ac-different"><span class="header-section-number">2.3.2.1.7</span> 7. SAD - Skip if AC
Different</h5>
<p><strong>Encoding:</strong> <code>141</code> (octal
<code>30xxxx</code> direct, <code>31xxxx</code> indirect)
<strong>Operation:</strong>
<code>if AC ‚â† memory[address] then PC ‚Üê PC + 1</code> <strong>Flags
affected:</strong> None (skip is side effect)</p>
<pre class="assembly"><code>" Examples from cat.s

   lac char          " Load character just read
   sad d4            " Skip if AC Different from 4 (EOF marker)
   jmp done          " If not EOF, jump to done
   " ... handle EOF ...
done:

" Comparison pattern:
   lac value1
   sad value2        " Skip if different
   jmp equal_case    " Not skipped = equal
   jmp not_equal     " Skipped = different
equal_case:

" Loop termination:
loop:
   lac counter
   sad limit         " Skip if counter ‚â† limit
   jmp done          " Equal: exit loop
   " ... loop body ...
   jmp loop
done:</code></pre>
<p><strong>Comparison logic:</strong></p>
<pre><code>SAD compares AC with memory
Result = different ‚Üí Skip next instruction
Result = equal ‚Üí Execute next instruction

To skip on EQUAL, use double-skip pattern:
   sad value
   skp              " Skip if different (inverts logic)
   jmp equal_label  " Executed only if equal</code></pre>
<h5 data-number="2.3.2.1.8" id="jmp---jump"><span class="header-section-number">2.3.2.1.8</span> 8. JMP - Jump</h5>
<p><strong>Encoding:</strong> <code>161</code> (octal
<code>34xxxx</code> direct, <code>35xxxx</code> indirect)
<strong>Operation:</strong> <code>PC ‚Üê address</code> (direct) or
<code>PC ‚Üê memory[address]</code> (indirect) <strong>Flags
affected:</strong> None</p>
<pre class="assembly"><code>" Direct jump (unconditional branch)
loop:
   " ... code ...
   jmp loop          " PC ‚Üê address of 'loop'

" Indirect jump (jump to address in variable)
   lac return_addr   " Load return address
   dac temp          " Store temporarily
   jmp temp i        " PC ‚Üê memory[temp] (jump to return address)

" Jump table (switch/case implementation)
   lac selector      " Load case number (0, 1, 2, ...)
   tad jumptable     " Add to base of jump table
   dac temp          " Store address
   jmp temp i        " Jump indirect through table

jumptable:
   case0             " Address of case 0 handler
   case1             " Address of case 1 handler
   case2             " Address of case 2 handler

case0:
   " ... handle case 0 ...
case1:
   " ... handle case 1 ...
case2:
   " ... handle case 2 ...

" Conditional jump pattern:
   lac value
   sza               " Skip if Zero
   jmp nonzero       " Taken if value ‚â† 0
   " ... handle zero case ...
   jmp continue
nonzero:
   " ... handle nonzero case ...
continue:</code></pre>
<h4 data-number="2.3.2.2" id="group-2-microprogrammed-instructions-8-instructions"><span class="header-section-number">2.3.2.2</span> Group 2: Microprogrammed
Instructions (8 instructions)</h4>
<p>These instructions use opcode <code>110</code> (octal
<code>6xxxxx</code>) with remaining bits specifying micro-operations.
Multiple micro-operations can be combined in a single instruction!</p>
<p><strong>General format:</strong></p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚îê
‚îÇ110‚îÇCLA‚îÇCMA‚îÇCLL‚îÇCML‚îÇRAR‚îÇRAL‚îÇ skip ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚îò
  3b  1b 1b 1b 1b 1b 1b      9 bits

Bits can be combined (OR'd together):
Example: CLA + CLL = 600400 | 600200 = 600600</code></pre>
<h5 data-number="2.3.2.2.1" id="cla---clear-ac"><span class="header-section-number">2.3.2.2.1</span> 9. CLA - Clear AC</h5>
<p><strong>Encoding:</strong> <code>600400</code> (bit 11 = 1)
<strong>Operation:</strong> <code>AC ‚Üê 0</code> <strong>Flags
affected:</strong> None</p>
<pre class="assembly"><code>   cla               " AC ‚Üê 0

" Often combined with other operations:
   sna cla           " Skip if Non-zero, then Clear AC
                     " (Tests old value, clears regardless)</code></pre>
<h5 data-number="2.3.2.2.2" id="cma---complement-ac"><span class="header-section-number">2.3.2.2.2</span> 10. CMA - Complement
AC</h5>
<p><strong>Encoding:</strong> <code>601000</code> (bit 12 = 1)
<strong>Operation:</strong> <code>AC ‚Üê ~AC</code> (one‚Äôs complement)
<strong>Flags affected:</strong> None</p>
<pre class="assembly"><code>" Bitwise NOT operation
   lac value         " AC ‚Üê 0123456 (octal example)
   cma               " AC ‚Üê ~AC = 0654321 (one's complement)

" Two's complement negation:
   lac value
   cma               " One's complement
   tad d1            " Add 1
   " AC now contains -value</code></pre>
<p><strong>One‚Äôs vs Two‚Äôs complement:</strong></p>
<pre><code>Original:  0000005 (octal) = 000000000000000101 (binary) = 5
One's:     0777772 (octal) = 111111111111111010 (binary) = ~5
Two's:     0777773 (octal) = 111111111111111011 (binary) = -5

One's complement: Flip all bits
Two's complement: Flip all bits + 1</code></pre>
<h5 data-number="2.3.2.2.3" id="cll---clear-link"><span class="header-section-number">2.3.2.2.3</span> 11. CLL - Clear Link</h5>
<p><strong>Encoding:</strong> <code>600200</code> (bit 10 = 1)
<strong>Operation:</strong> <code>Link ‚Üê 0</code> <strong>Flags
affected:</strong> Link</p>
<pre class="assembly"><code>   cll               " Link ‚Üê 0

" Often used before shifts/rotates:
   cll; als 3        " Clear Link, then Arithmetic Left Shift 3</code></pre>
<h5 data-number="2.3.2.2.4" id="cml---complement-link"><span class="header-section-number">2.3.2.2.4</span> 12. CML - Complement
Link</h5>
<p><strong>Encoding:</strong> <code>601400</code> (bit 13 = 1)
<strong>Operation:</strong> <code>Link ‚Üê ~Link</code> <strong>Flags
affected:</strong> Link</p>
<pre class="assembly"><code>   cml               " Toggle Link (0‚Üí1, 1‚Üí0)

" Can be combined:
   cla cml           " AC ‚Üê 0, Link ‚Üê ~Link</code></pre>
<h5 data-number="2.3.2.2.5" id="rotate-and-shift-instructions"><span class="header-section-number">2.3.2.2.5</span> 13. Rotate and Shift
Instructions</h5>
<p><strong>RAR - Rotate AC Right</strong> <strong>Encoding:</strong>
<code>602000</code> (bit 14 = 1) <strong>Operation:</strong>
<code>{AC, Link} ‚Üê {Link, AC} &gt;&gt; 1</code> (19-bit rotate)</p>
<p><strong>RAL - Rotate AC Left</strong> <strong>Encoding:</strong>
<code>604000</code> (bit 15 = 1) <strong>Operation:</strong>
<code>{Link, AC} ‚Üê {Link, AC} &lt;&lt; 1</code> (19-bit rotate)</p>
<pre class="assembly"><code>" Rotate examples from cat.s

   lac ipt           " Load pointer (18 bits)
   ral               " Rotate left 1 bit
                     " Bit 17 ‚Üí Link, Bits 16-0 ‚Üí AC[17-1], Link ‚Üí AC[0]

" Extract left character from packed word:
   lac word          " Load word: [char1][char2]
                     "            bits 17‚îÄ9‚îÇ8‚îÄ‚îÄ‚îÄ0
   lrss 9            " Link-Right-Shift 9 bits
                     " AC[8-0] ‚Üê AC[17-9] (left character)
   and o177          " Mask to 7 bits

" Extract right character:
   lac word          " Load word
   ral               " Bit 17 ‚Üí Link (determines odd/even)
   lac word          " Reload
   szl               " Skip if Link Zero (even character)
   lrss 9            " If odd, shift right 9
   and o177          " Mask to 7 bits</code></pre>
<p><strong>Other shift/rotate variants:</strong></p>
<pre class="assembly"><code>" Combinations create different shifts:

" RTL - Rotate Two Left (double rotate)
   ral; ral          " Left shift 2 positions

" RTR - Rotate Two Right
   rar; rar          " Right shift 2 positions

" LRSS - Link-Right-Shift-9 (from assembler)
   lrss 9            " Special form: right shift 9 bits

" ALSS - Arithmetic Left Shift (from assembler)
   alss 9            " Special form: left shift 9 bits
                     " Sign bit preserved in signed arithmetic

" Example: Multiply by 8 (shift left 3)
   lac value
   cll               " Clear Link (ensure 0 shifted in)
   ral; ral; ral     " Shift left 3 positions
                     " AC ‚Üê AC * 8</code></pre>
<h5 data-number="2.3.2.2.6" id="skip-instructions"><span class="header-section-number">2.3.2.2.6</span> 14-16. Skip
Instructions</h5>
<p>These test AC and/or Link and conditionally skip the next
instruction.</p>
<p><strong>SZA - Skip if AC Zero</strong> <strong>Encoding:</strong>
<code>640100</code> <strong>Operation:</strong>
<code>if AC == 0 then PC ‚Üê PC + 1</code></p>
<p><strong>SNA - Skip if AC Non-zero</strong> <strong>Encoding:</strong>
<code>640200</code> <strong>Operation:</strong>
<code>if AC ‚â† 0 then PC ‚Üê PC + 1</code></p>
<p><strong>SZL - Skip if Link Zero</strong> <strong>Encoding:</strong>
<code>640400</code> <strong>Operation:</strong>
<code>if Link == 0 then PC ‚Üê PC + 1</code></p>
<p><strong>SNL - Skip if Link Non-zero</strong>
<strong>Encoding:</strong> <code>641000</code>
<strong>Operation:</strong>
<code>if Link ‚â† 0 then PC ‚Üê PC + 1</code></p>
<p><strong>SPA - Skip if AC Positive</strong> <strong>Encoding:</strong>
<code>640010</code> <strong>Operation:</strong>
<code>if AC ‚â• 0 then PC ‚Üê PC + 1</code> (bit 17 == 0)</p>
<p><strong>SMA - Skip if AC Minus</strong> <strong>Encoding:</strong>
<code>640020</code> <strong>Operation:</strong>
<code>if AC &lt; 0 then PC ‚Üê PC + 1</code> (bit 17 == 1)</p>
<pre class="assembly"><code>" Examples from Unix source

" Check file open success
   sys open; name; 0
   spa               " Skip if Positive (AC ‚â• 0)
   jmp error         " Negative file descriptor = error
   dac fd            " Positive = success

" Test for zero
   lac count
   sza               " Skip if Zero
   jmp nonzero       " Count ‚â† 0
   " ... handle zero case ...
   jmp continue
nonzero:
   " ... handle nonzero case ...
continue:

" Double-skip pattern (skip if NOT zero)
   lac value
   sna cla           " Skip if Non-zero, then Clear AC
   jmp zero_case     " Executed only if value was zero
   " ... nonzero case ...
zero_case:

" Link testing for character packing
   lac ptr
   ral               " Bit 17 ‚Üí Link
   lac ptr i         " Reload word
   szl               " Skip if Link Zero
   lrss 9            " If Link=1, shift right 9 (odd character)</code></pre>
<p><strong>Skip instruction combinations:</strong></p>
<pre class="assembly"><code>" Skip instructions can be combined with CLA:

   sza cla           " Skip if Zero, then Clear (tests, then clears)
   sna cla           " Skip if Non-zero, then Clear

" This allows:
   lac variable
   sna cla           " Skip if non-zero, clear AC
   jmp was_zero      " Taken only if AC was zero
   " ... non-zero case ...
was_zero:
   " AC is now 0 in both paths</code></pre>
<h3 data-number="2.3.3" id="special-instructions"><span class="header-section-number">2.3.3</span> Special Instructions</h3>
<p>Beyond the basic 16, the PDP-7 has several special-purpose
instructions:</p>
<h4 data-number="2.3.3.1" id="jms---jump-to-subroutine"><span class="header-section-number">2.3.3.1</span> JMS - Jump to
Subroutine</h4>
<p><strong>Encoding:</strong> <code>041</code> (octal
<code>10xxxx</code> direct, <code>11xxxx</code> indirect)
<strong>Operation:</strong></p>
<pre><code>memory[address] ‚Üê PC  (save return address)
PC ‚Üê address + 1      (jump to subroutine body)</code></pre>
<p><strong>This is THE subroutine call mechanism.</strong> Critical to
understand!</p>
<pre class="assembly"><code>" Subroutine definition:
getc: 0               " First word: return address stored here
   lac ipt            " Subroutine body starts at getc+1
   sad eipt
   jmp 1f
   " ... more code ...
   jmp getc i         " Return: JMP indirect through getc (first word)

" Calling the subroutine:
   jms getc           " memory[getc] ‚Üê PC, PC ‚Üê getc+1
   " Execution continues here after subroutine returns</code></pre>
<p><strong>Step-by-step JMS execution:</strong></p>
<pre><code>Before call:
   PC = 1000         " Calling instruction at address 1000
   getc = 500        " Subroutine at address 500
   memory[500] = 0   " First word of subroutine

Execute: jms getc (at address 1000)
   1. memory[500] ‚Üê 1001  (save return address)
   2. PC ‚Üê 501           (jump to subroutine body)

Execute: jmp getc i (at end of subroutine)
   1. PC ‚Üê memory[500] = 1001 (return)</code></pre>
<p><strong>Complete subroutine example from cat.s:</strong></p>
<pre class="assembly"><code>" PUTC - Output one character to buffer
" Call: jms putc (with character in AC)
" Returns: AC preserved, character added to buffer

putc: 0               " Return address stored here
   and o177           " Mask to 7-bit ASCII
   dac 2f+1           " Save character temporarily
   lac opt            " Load output pointer
   dac 2f             " Save pointer
   add o400000        " Increment pointer (by adding 0400000)
   dac opt            " Store incremented pointer
   spa                " Skip if Positive (even character)
   jmp 1f             " Odd character: branch

   " Even character (left side of word)
   lac 2f i           " Load existing word
   xor 2f+1           " XOR with character (merges into bits 8-0)
   jmp 3f

1: " Odd character (right side of word)
   lac 2f+1           " Load character
   alss 9             " Shift left 9 bits (bits 17-9)

3:
   dac 2f i           " Store merged word
   isz noc            " Increment character count
   lac noc
   sad d128           " Skip if Different from 128
   skp                " Skip
   jmp putc i         " Return if count &lt; 128

   " Flush buffer when full
   lac fo
   sys write; iopt+1; 64
   lac iopt
   dac opt
   dzm noc            " Reset count
   jmp putc i         " Return

2: 0;0                " Temporary storage (2 words)</code></pre>
<p><strong>Non-reentrant subroutines:</strong></p>
<p>This JMS mechanism has a critical limitation:</p>
<pre class="assembly"><code>sub1: 0
   jms sub2           " Call sub2 (overwrites sub2's return address)
   jmp sub1 i         " Return from sub1

sub2: 0
   jms sub2           " RECURSIVE CALL
                      " Problem: Overwrites memory[sub2] with new return!
                      " Original return address is LOST!
   jmp sub2 i         " Returns to wrong place!</code></pre>
<p><strong>PDP-7 subroutines are NOT reentrant:</strong> - Cannot call
themselves recursively - Cannot be called from interrupt handlers if
already executing - Return address stored in first word (destroyed by
re-entry)</p>
<p><strong>This limitation is fundamental to PDP-7 Unix
architecture.</strong></p>
<h4 data-number="2.3.3.2" id="iot---inputoutput-transfer"><span class="header-section-number">2.3.3.2</span> IOT - Input/Output
Transfer</h4>
<p><strong>Encoding:</strong> <code>700000 - 777777</code> (octal,
opcode bits = <code>111</code>) <strong>Operation:</strong>
Device-specific I/O operations</p>
<pre class="assembly"><code>" IOT instruction format:
‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ111‚îÇ DEVICE  ‚îÇ FUNCTION‚îÇ  18 bits
‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 3b    6 bits    9 bits

Examples:
   iot 011      " Teleprinter input
   iot 012      " Teleprinter output
   iot 714      " Read DECtape block</code></pre>
<p>IOT instructions are covered in detail in Section 6 (I/O
Architecture).</p>
<h4 data-number="2.3.3.3" id="skp---skip-unconditionally"><span class="header-section-number">2.3.3.3</span> SKP - Skip
Unconditionally</h4>
<p><strong>Encoding:</strong> <code>640000</code>
<strong>Operation:</strong> <code>PC ‚Üê PC + 1</code> (always skip next
instruction)</p>
<pre class="assembly"><code>" Used to invert skip logic:
   lac value
   sad target        " Skip if AC Different from target
   skp               " Skip if equal (inverts the test)
   jmp different     " Taken if different
   " ... handle equal case ...
different:

" Another pattern:
   lac x
   sna               " Skip if Non-zero
   skp               " If zero, skip
   jmp nonzero       " Taken if non-zero
   " ... zero case ...
nonzero:</code></pre>
<h4 data-number="2.3.3.4" id="hlt---halt"><span class="header-section-number">2.3.3.4</span> HLT - Halt</h4>
<p><strong>Encoding:</strong> <code>600000</code>
<strong>Operation:</strong> Stop processor, wait for external
intervention</p>
<pre class="assembly"><code>" From s1.s (kernel initialization)
orig:
   hlt               " Halt (waits for power-on/reset)
   jmp pibreak       " After break, jump to interrupt handler</code></pre>
<p>Used at system initialization and for debugging.</p>
<h4 data-number="2.3.3.5" id="ioniof---interrupts-onoff"><span class="header-section-number">2.3.3.5</span> ION/IOF - Interrupts
On/Off</h4>
<p><strong>Encoding:</strong> ION = <code>600001</code>, IOF =
<code>600002</code> <strong>Operation:</strong> Enable/disable interrupt
system</p>
<pre class="assembly"><code>" Critical section protection from s1.s:
   iof               " Disable interrupts
   dac u.ac          " Save AC atomically
   " ... critical section code ...
   ion               " Re-enable interrupts</code></pre>
<hr/>
<h2 data-number="2.4" id="addressing-modes"><span class="header-section-number">2.4</span> 3. Addressing Modes</h2>
<p>The PDP-7 supports three addressing modes, selected by instruction
format:</p>
<h3 data-number="2.4.1" id="direct-addressing"><span class="header-section-number">2.4.1</span> Direct Addressing</h3>
<p>The instruction contains the actual memory address.</p>
<pre class="assembly"><code>   lac 4096          " AC ‚Üê memory[4096]

Encoding: 010000 (octal)
          ‚îÇ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îò
          ‚îÇ  4096 (address field)
          ‚îî‚îÄ 01 (LAC opcode, I=0)

Execution:
   1. Fetch instruction at PC
   2. Extract address field: 4096
   3. MA ‚Üê 4096
   4. AC ‚Üê memory[4096]
   5. PC ‚Üê PC + 1</code></pre>
<p><strong>Example: Simple variable access</strong></p>
<pre class="assembly"><code>" Increment a counter
   lac count         " Direct: AC ‚Üê memory[count]
   tad d1            " AC ‚Üê AC + 1
   dac count         " Direct: memory[count] ‚Üê AC

count: 0              " Variable storage
d1: 1                 " Constant 1</code></pre>
<h3 data-number="2.4.2" id="indirect-addressing"><span class="header-section-number">2.4.2</span> Indirect Addressing</h3>
<p>The instruction contains an address that contains the actual address
(pointer).</p>
<pre class="assembly"><code>   lac 100 i         " AC ‚Üê memory[memory[100]]

Encoding: 030100 (octal)
          ‚îÇ‚îÇ‚îî‚îÄ‚î¨‚îÄ‚îò
          ‚îÇ‚îÇ 100 (address field)
          ‚îÇ‚îî‚îÄ I=1 (indirect bit)
          ‚îî‚îÄ‚îÄ 01 (LAC opcode)

Execution:
   1. Fetch instruction at PC
   2. Extract address field: 100
   3. MA ‚Üê memory[100]  (read pointer)
   4. AC ‚Üê memory[MA]   (read data)
   5. PC ‚Üê PC + 1</code></pre>
<p><strong>Example: Pointer dereferencing</strong></p>
<pre class="assembly"><code>" Read from address stored in pointer
   lac ptr           " Load pointer value
   dac temp          " Store in temp location
   lac temp i        " Indirect: AC ‚Üê memory[memory[temp]]

" Alternative: direct indirect (if pointer is at fixed location)
   lac ptr i         " AC ‚Üê memory[memory[ptr]]

ptr: 4096             " Pointer: contains address 4096
temp: 0</code></pre>
<p><strong>Example from cat.s: Reading through pointer</strong></p>
<pre class="assembly"><code>" GETC - Get one character from input buffer
getc: 0
   lac ipt           " Load input pointer (direct)
   sad eipt          " Compare with end pointer
   jmp 1f            " If equal, refill buffer

   dac 2f            " Store pointer value
   add o400000       " Increment pointer
   dac ipt           " Save incremented pointer
   ral               " Rotate (bit 17 ‚Üí Link, selects character)
   lac 2f i          " INDIRECT: Read word at address in pointer
   szl               " Skip if Link Zero (even character)
   lrss 9            " If odd character, shift right 9
   and o177          " Mask to 7-bit ASCII
   jmp getc i        " Return

2: 0                 " Temporary storage for pointer
ipt: 0               " Input pointer variable
eipt: 0              " End pointer variable</code></pre>
<h3 data-number="2.4.3" id="auto-increment-addressing"><span class="header-section-number">2.4.3</span> Auto-Increment
Addressing</h3>
<p>Indirect addressing through locations 010-017 (octal) auto-increments
the pointer.</p>
<pre class="assembly"><code>   lac 8 i           " AC ‚Üê memory[memory[8]]
                     " THEN: memory[8] ‚Üê memory[8] + 1

Execution:
   1. Fetch instruction at PC
   2. Extract address field: 8 (010 octal)
   3. Check: Is address in range 010-017? YES
   4. MA ‚Üê memory[8]  (read pointer)
   5. AC ‚Üê memory[MA] (read data)
   6. memory[8] ‚Üê memory[8] + 1  (AUTO-INCREMENT!)
   7. PC ‚Üê PC + 1</code></pre>
<p><strong>Example: Array traversal</strong></p>
<pre class="assembly"><code>" Sum array of 100 elements
   -100              " Initialize counter (count up to 0)
   dac counter
   law array-1       " Point one before array
   dac 8             " Use auto-increment register 8
   cla               " Clear sum

loop:
   tad 8 i           " Add next array element, auto-increment pointer
   " AC now contains sum
   isz counter       " Increment counter, skip when 0
   jmp loop          " Continue

   dac sum           " Store final sum

counter: 0
sum: 0
array: .=.+100        " Reserve 100 words</code></pre>
<p><strong>Example: String copy from init.s</strong></p>
<pre class="assembly"><code>" Copy string from obuf to dir, character by character
   law dir-1         " Destination: one before 'dir'
   dac 8             " R8 = destination pointer
   law obuf-1        " Source: one before 'obuf'
   dac 9             " R9 = source pointer (could use non-auto-increment)

   dzm nchar         " Clear character counter

1:
   lac 9 i           " Load from source, R9 auto-increments
   sad o72           " Skip if AC Different from 072 (delimiter)
   jmp 1f            " If equal to 072, done

   dac char          " Save character
   lac nchar
   sza               " Skip if Zero (first character of pair)
   jmp 2f            " Already have first character

   " First character (left side of word)
   lac char
   alss 9            " Shift left 9 bits
   xor o40           " XOR with 040 (adjust)
   dac 8 i           " Store to destination, R8 auto-increments
   dac nchar         " Remember we have first character
   jmp 1b            " Continue

2: " Second character (right side of word)
   lac 8             " Load current destination pointer
   dac nchar         " Save it
   lac nchar i       " Load word at destination
   and o777000       " Keep left character (bits 17-9)
   xor char          " Merge right character (bits 8-0)
   dac nchar i       " Store merged word
   dzm nchar         " Clear state
   jmp 1b            " Continue
1:
   " String copy complete</code></pre>
<h3 data-number="2.4.4" id="addressing-mode-comparison"><span class="header-section-number">2.4.4</span> Addressing Mode
Comparison</h3>
<table>
<colgroup>
<col style="width: 13%"/>
<col style="width: 18%"/>
<col style="width: 25%"/>
<col style="width: 18%"/>
<col style="width: 23%"/>
</colgroup>
<thead>
<tr>
<th>Mode</th>
<th>Syntax</th>
<th>Operation</th>
<th>Cycles</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td>Direct</td>
<td><code>lac 100</code></td>
<td><code>AC ‚Üê memory[100]</code></td>
<td>1</td>
<td>Simple variables</td>
</tr>
<tr>
<td>Indirect</td>
<td><code>lac 100 i</code></td>
<td><code>AC ‚Üê memory[memory[100]]</code></td>
<td>2</td>
<td>Pointers, arrays</td>
</tr>
<tr>
<td>Auto-inc</td>
<td><code>lac 8 i</code></td>
<td><code>AC ‚Üê memory[memory[8]]</code><br/><code>memory[8]++</code></td>
<td>2</td>
<td>Sequential access</td>
</tr>
</tbody>
</table>
<p><strong>Performance implications:</strong></p>
<pre class="assembly"><code>" Task: Sum 100-element array

" Method 1: Direct addressing (SLOW)
   cla
   tad array+0
   tad array+1
   tad array+2
   " ... 100 instructions!
   tad array+99
   " 100 instructions, 100 memory cycles

" Method 2: Indirect addressing (MEDIUM)
   cla
   law array
   dac ptr
loop:
   tad ptr i         " Add element
   isz ptr           " Increment pointer
   " ... counter logic ...
   jmp loop
   " ~400 instructions total, slower

" Method 3: Auto-increment (FAST)
   -100
   dac counter
   law array-1
   dac 8             " Auto-increment register
   cla
loop:
   tad 8 i           " Add element, auto-increment
   isz counter       " Count
   jmp loop
   " 200 instructions total, fastest!</code></pre>
<p><strong>Auto-increment is 2√ó faster than manual pointer
arithmetic.</strong></p>
<hr/>
<h2 data-number="2.5" id="memory-organization"><span class="header-section-number">2.5</span> 4. Memory Organization</h2>
<h3 data-number="2.5.1" id="memory-map"><span class="header-section-number">2.5.1</span> Memory Map</h3>
<p>The PDP-7 addressed up to <strong>8K words</strong> (8192 words =
16,384 bytes equivalent).</p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê 017777 (8191 decimal)
‚îÇ                                          ‚îÇ
‚îÇ         User Space / High Memory         ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ    ‚Ä¢ Program code                        ‚îÇ
‚îÇ    ‚Ä¢ Program data                        ‚îÇ
‚îÇ    ‚Ä¢ Stack space                         ‚îÇ
‚îÇ    ‚Ä¢ Buffers                             ‚îÇ
‚îÇ                                          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                          ‚îÇ
‚îÇ         Kernel Space                     ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ    ‚Ä¢ System call handlers                ‚îÇ
‚îÇ    ‚Ä¢ Device drivers                      ‚îÇ
‚îÇ    ‚Ä¢ Process tables                      ‚îÇ
‚îÇ    ‚Ä¢ Buffer cache                        ‚îÇ
‚îÇ                                          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ 000100 (64 decimal)
‚îÇ         Interrupt Vectors                ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ    000020: System call trap              ‚îÇ
‚îÇ    000007: Hardware register             ‚îÇ
‚îÇ                                          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ 000017 (15 decimal)
‚îÇ    Auto-Increment Registers              ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ    000010-000017: R8-R15                 ‚îÇ
‚îÇ                                          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ 000007 (7 decimal)
‚îÇ         Special Locations                ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ    000000-000007: System use             ‚îÇ
‚îÇ                                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò 000000 (0 decimal)

Address Range    Octal        Decimal      Use
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
000000-000007    0-7          0-7          Special/Reserved
000010-000017    8-15         8-15         Auto-increment regs
000020-000077    16-63        16-63        Interrupt vectors
000100-003777    64-2047      64-2047      Kernel code/data
004000-017777    2048-8191    2048-8191    User space</code></pre>
<h3 data-number="2.5.2" id="special-memory-locations"><span class="header-section-number">2.5.2</span> Special Memory Locations</h3>
<p>Certain memory locations have special meanings:</p>
<pre class="assembly"><code>" Location 000000 (0): Origin/Halt location
orig = 0
   hlt               " Processor starts here on reset

" Location 000007 (-1): Special constant
. = 7
   -1                " Many programs expect -1 here

" Location 000020 (16): System call trap vector
. = 020
   system_call_entry " Saved PC for system calls

" Locations 000010-000017 (8-15): Auto-increment registers
" These are normal memory but auto-increment when used indirectly</code></pre>
<p><strong>From s1.s (kernel):</strong></p>
<pre class="assembly"><code>.. = 0
t = 0
orig:
   hlt               " Location 0: halt
   jmp pibreak       " Location 1: break handler

. = orig+7
   -1                " Location 7: constant -1

. = orig+020
   1f                " Location 020 (16): system call handler
   iof               " Disable interrupts
   dac u.ac          " Save accumulator
   lac 020           " Load return address
   dac 1f
   " ... system call processing ...</code></pre>
<h3 data-number="2.5.3" id="word-vs.-byte-addressing"><span class="header-section-number">2.5.3</span> Word vs.¬†Byte Addressing</h3>
<p><strong>Critical difference from modern architectures:</strong></p>
<p>Modern computers (8-bit byte addressing):</p>
<pre><code>Address    Content
0x0000     Byte 0
0x0001     Byte 1
0x0002     Byte 2
0x0003     Byte 3</code></pre>
<p>PDP-7 (18-bit word addressing):</p>
<pre><code>Address    Content (18 bits = 2 characters + 4 bits)
00000      Word 0 [char0][char1]
00001      Word 1 [char2][char3]
00002      Word 2 [char4][char5]
00003      Word 3 [char6][char7]</code></pre>
<p><strong>Implications:</strong></p>
<ol type="1">
<li><strong>No byte pointers</strong> - only word pointers</li>
<li><strong>Character access</strong> requires bit manipulation</li>
<li><strong>File sizes</strong> measured in words, not bytes</li>
<li><strong>Memory allocation</strong> in word units</li>
</ol>
<h3 data-number="2.5.4" id="character-packing"><span class="header-section-number">2.5.4</span> Character Packing</h3>
<p>The PDP-7 packed <strong>two 9-bit characters per 18-bit
word:</strong></p>
<pre><code>18-bit word structure for characters:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Char0  ‚îÇ  Char1  ‚îÇ
‚îÇ bits    ‚îÇ bits    ‚îÇ
‚îÇ 17-9    ‚îÇ  8-0    ‚îÇ
‚îÇ (left)  ‚îÇ (right) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Each character: 9 bits = 512 possible values
ASCII uses 7 bits = 128 values (0-127)
Remaining 2 bits: extensions or ignored</code></pre>
<p><strong>Character extraction from cat.s:</strong></p>
<pre class="assembly"><code>" GETC - Extract character from packed word storage
getc: 0
   lac ipt           " Load input pointer
   sad eipt          " Check if at end of buffer
   jmp refill        " If so, refill buffer

   " Save and increment pointer
   dac 2f            " Save pointer value
   add o400000       " Add 0400000 (increments by 1)
   dac ipt           " Store incremented pointer

   " Extract character based on odd/even
   ral               " Rotate: bit 17 ‚Üí Link
                     " Link=0: even pointer (left char)
                     " Link=1: odd pointer (right char)

   lac 2f i          " Load word at address (indirect)
                     " Word contains [left char][right char]

   szl               " Skip if Link Zero (even)
   lrss 9            " If odd, shift right 9 bits
                     " Moves bits 17-9 ‚Üí bits 8-0

   and o177          " Mask to 7-bit ASCII
                     " 0177 = 000 000 001 111 111 (binary)
                     "       keeps bits 6-0 only

   sna               " Skip if Non-zero
   jmp getc+1        " If null character, skip it

   jmp getc i        " Return with character in AC

2: 0                 " Temporary storage
o400000: 0400000     " Constant for pointer increment
o177: 0177           " ASCII mask</code></pre>
<p><strong>Step-by-step example:</strong></p>
<pre><code>Assume:
   ipt = 04000 (even address)
   memory[04000] = 0101102 (octal)
                 = 001 001 000 001 000 010 (binary)
                 = [char 'A'][char 'B']
                 = bits [17-9][8-0]
                 = [041][042] (octal)
                 = [65][66] (decimal)

First call (even):
   lac ipt           ‚Üí AC = 04000
   dac 2f            ‚Üí memory[2f] = 04000
   add o400000       ‚Üí AC = 04000 + 0400000 = 0404000
   dac ipt           ‚Üí ipt = 0404000 (incremented)
   ral               ‚Üí Link = 0 (bit 17 of 04000 = 0)
   lac 2f i          ‚Üí AC = memory[04000] = 0101102
   szl               ‚Üí Link = 0, so DON'T skip
   " (no shift)
   and o177          ‚Üí AC = 0101102 &amp; 0177 = 0102 = 'B' (right char)
   " Wait, this seems backwards!

Actually, the encoding is:
   Word: high 9 bits = left char, low 9 bits = right char
   0101102 = 010 110 010 (octal)
           = 000001 000001 001000 000010 (binary)

Let me recalculate:
   0101102 (octal) = 001 001 000 001 000 010 (binary, 18 bits)

   Left character (bits 17-9):  001001000 = 0110 (octal) = 72 (decimal) = 'H'
   Right character (bits 8-0):  001000010 = 0102 (octal) = 66 (decimal) = 'B'

The example shows that characters are tightly packed, and extraction
requires careful bit manipulation.</code></pre>
<p><strong>Character packing (storage) from init.s:</strong></p>
<pre class="assembly"><code>" Pack username characters into directory name
   law dir-1         " Destination pointer (before dir)
   dac 8             " R8 = destination (auto-increment)

   dzm nchar         " Clear character state (0 = need left char)

1:
   lac 9 i           " Get next input character (R9 auto-increments)
   sad o72           " Skip if AC Different from 072 (delimiter)
   jmp done          " If delimiter, done

   dac char          " Save character
   lac nchar         " Load state
   sza               " Skip if Zero (need left character)
   jmp pack_right    " Already have left, pack right

pack_left:
   " First character ‚Üí left side (bits 17-9)
   lac char          " Load character (bits 8-0)
   alss 9            " Arithmetic Left Shift 9 bits
                     " Character now in bits 17-9
   xor o40           " XOR with 040 (space character as filler)
   dac 8 i           " Store to destination, R8 auto-increments
   dac nchar         " Mark that we have left character
   jmp 1b            " Get next character

pack_right:
   " Second character ‚Üí right side (bits 8-0)
   lac 8             " Load current destination pointer
   dac nchar         " Save pointer
   lac nchar i       " Load existing word (has left character)
   and o777000       " Mask to keep bits 17-9 (left character)
                     " 0777000 = 111 111 111 000 000 000 (binary)
   xor char          " XOR with new character (bits 8-0)
                     " Merges character into bits 8-0
   dac nchar i       " Store merged word
   dzm nchar         " Clear state (ready for next left char)
   jmp 1b            " Get next character

done:
   " Characters packed

char: 0              " Temporary: current character
nchar: 0             " State: 0=need left, non-zero=have left
o72: 072             " Delimiter character
o40: 040             " Space character
o777000: 0777000     " Left character mask</code></pre>
<p><strong>Example packing ‚ÄúAB‚Äù into one word:</strong></p>
<pre><code>Step 1: Pack 'A' (065 octal = 000 000 101 binary in 9 bits)
   lac char          ‚Üí AC = 0000065 (18-bit word: 000 000 000 000 101)
   alss 9            ‚Üí AC = 0032040 (shifted left 9: 000 000 110 100 000)
                        Wait, that's not right. Let me recalculate:

   'A' = 065 octal = 053 decimal = 00 000 110 101 (binary, 9 bits)
   18-bit word: 000 000 000 000 110 101
   alss 9 (shift left 9):
      000 000 000 000 110 101 &lt;&lt; 9 = 000 110 101 000 000 000
      = 0032000 (octal)
   xor o40:
      0032000 XOR 0000040 = 0032040

   Stored word: 0032040 (has 'A' in bits 17-9, space in bits 8-0)

Step 2: Pack 'B' (066 octal)
   lac nchar i       ‚Üí AC = 0032040 (existing word)
   and o777000       ‚Üí AC = 0032000 (keep left character)
   xor char (066)    ‚Üí AC = 0032000 XOR 0000066 = 0032066

   Final word: 0032066 = [A][B] packed</code></pre>
<h3 data-number="2.5.5" id="file-io-and-character-handling"><span class="header-section-number">2.5.5</span> File I/O and Character
Handling</h3>
<p>Files on PDP-7 Unix are <strong>word-oriented</strong>, but programs
see <strong>character streams</strong>:</p>
<pre class="assembly"><code>" Reading characters from file (from cat.s)

" System call: read into buffer (in WORDS)
   lac fi            " Load file descriptor
   sys read; buffer; 64  " Read 64 WORDS (128 characters)
   sna               " Skip if Non-zero (successful)
   jmp eof           " Zero words read = EOF

   tad buffer        " AC = words_read
                     " Each word contains 2 characters
   " ... convert to character count ...

" Writing characters to file (buffered)

putc: 0              " Write one character
   and o177          " Mask to 7-bit ASCII
   " ... pack into word buffer ...
   isz noc           " Increment character count
   lac noc
   sad d128          " Skip if Different from 128
   skp
   jmp putc i        " Return if buffer not full

   " Buffer full (64 words = 128 characters)
   lac fo            " File descriptor
   sys write; buffer; 64  " Write 64 WORDS
   " ... reset buffer ...</code></pre>
<p><strong>File size measurement:</strong></p>
<pre><code>Unix command "ls -l" on PDP-7:
   -rw-r--r--  1 root  42  Jun 30 1970  file.txt

"42" = 42 WORDS = 84 bytes equivalent (not exactly bytes!)

Actual character count could be:
   - 84 characters (both chars used in each word)
   - 83 characters (last word half-empty)
   - 42 characters (only left chars used)</code></pre>
<p>This word-oriented design affects: - File sizes (in words) - I/O
performance (word transfers faster than byte) - Character processing
(always unpacking/packing) - Disk layout (block size in words)</p>
<hr/>
<h2 data-number="2.6" id="peripheral-devices"><span class="header-section-number">2.6</span> 5. Peripheral Devices</h2>
<p>The PDP-7 supported several peripheral devices essential for
interactive computing:</p>
<h3 data-number="2.6.1" id="device-overview"><span class="header-section-number">2.6.1</span> Device Overview</h3>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    PDP-7 CPU                    ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ   Registers: AC, MQ, Link, PC                   ‚îÇ
‚îÇ   Memory: 8K words                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚îÇ I/O Bus
         ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ           ‚îÇ         ‚îÇ         ‚îÇ          ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îê
‚îÇTeletype‚îÇ ‚îÇ Paper  ‚îÇ ‚îÇDECta-‚îÇ ‚îÇDisplay ‚îÇ ‚îÇ Real ‚îÇ
‚îÇ        ‚îÇ ‚îÇ  Tape  ‚îÇ ‚îÇ  pe  ‚îÇ ‚îÇ System ‚îÇ ‚îÇ Time ‚îÇ
‚îÇ Model  ‚îÇ ‚îÇReader &amp;‚îÇ ‚îÇ      ‚îÇ ‚îÇ        ‚îÇ ‚îÇClock ‚îÇ
‚îÇ 33/35  ‚îÇ ‚îÇ Punch  ‚îÇ ‚îÇ      ‚îÇ ‚îÇType340 ‚îÇ ‚îÇ      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

TTY Input    PTR: Read    DT: Mass    Display:    RTC:
TTY Output   PTP: Punch   Storage     Graphics    Timekeeping</code></pre>
<h3 data-number="2.6.2" id="teletype-tty"><span class="header-section-number">2.6.2</span> Teletype (TTY)</h3>
<p>The <strong>Teletype Model 33</strong> or <strong>Model 35</strong>
served as the primary console.</p>
<p><strong>Characteristics:</strong> - <strong>Speed</strong>: 10
characters/second (110 baud) - <strong>Character set</strong>: 7-bit
ASCII (uppercase only on Model 33) - <strong>Interface</strong>: Serial,
asynchronous - <strong>Duplex</strong>: Full duplex (simultaneous
send/receive) - <strong>Physical</strong>: Mechanical printer +
keyboard</p>
<p><strong>I/O Instructions:</strong></p>
<pre class="assembly"><code>" Teletype input (from init.s)
   cla               " Clear AC
   sys read; char; 1 " Read 1 word (2 characters) from TTY
   lac char          " Load character word
   lrss 9            " Shift right 9 bits (get left character)
                     " Characters arrive in left half of word

" Teletype output
   lac char          " Load character
   alss 9            " Shift to left half of word
   dac output        " Store
   lac d1            " File descriptor 1 (stdout)
   sys write; output; 1  " Write 1 word to TTY

" Direct IOT instructions (lower level)
   iot 011           " Read character from TTY (to AC)
   iot 012           " Write character from AC to TTY</code></pre>
<p><strong>Teletype files in Unix:</strong></p>
<pre class="assembly"><code>" From init.s - Opening TTY for process
ttyin:
   &lt;tt&gt;;&lt;yi&gt;;&lt;n 040;040040   " "ttyin  " filename (packed chars)
ttyout:
   &lt;tt&gt;;&lt;yo&gt;;&lt;ut&gt;; 040040    " "ttyout" filename

" Process initialization
   sys open; ttyin; 0    " File descriptor 0 (stdin)
   sys open; ttyout; 1   " File descriptor 1 (stdout)</code></pre>
<p><strong>TTY device behavior:</strong></p>
<pre><code>Input:
   1. User presses key
   2. Character sent to TTY input buffer
   3. Interrupt signals CPU
   4. Kernel reads character via IOT 011
   5. Character stored in kernel buffer
   6. sys read returns to user program

Output:
   1. Program calls sys write
   2. Kernel sends characters via IOT 012
   3. Teletype mechanical printer types
   4. ~100ms per character (10 chars/sec)
   5. Output buffer prevents CPU waiting</code></pre>
<p><strong>Echo handling:</strong></p>
<pre class="assembly"><code>" From user's perspective (init.s login prompt):
   lac d1
   sys write; m1; m1s    " Output "login: "
   jms rline             " Read line (with echo)

rline: 0
   law ibuf-1            " Input buffer pointer
   dac 8                 " R8 = pointer (auto-increment)
1:
   cla
   sys read; char; 1     " Read one word from TTY
   lac char
   lrss 9                " Extract character
   sad o100              " Skip if AC Different from 0100 (backspace)
   jmp rline+1           " Backspace: restart
   sad o43               " Skip if AC Different from 043 ('#' erase)
   jmp 2f                " Erase character
   dac 8 i               " Store character, increment pointer
   sad o12               " Skip if AC Different from 012 (newline)
   jmp rline i           " Return on newline
   jmp 1b                " Continue reading
2:
   " Handle erase
   law ibuf-1
   sad 8                 " Skip if AC Different from pointer
   jmp 1b                " At start, can't erase
   -1
   tad 8                 " Decrement pointer
   dac 8
   jmp 1b</code></pre>
<p><strong>Special characters:</strong></p>
<table>
<thead>
<tr>
<th>Octal</th>
<th>Decimal</th>
<th>ASCII</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>010</td>
<td>8</td>
<td>BS</td>
<td>Backspace</td>
</tr>
<tr>
<td>012</td>
<td>10</td>
<td>LF</td>
<td>Line feed (newline)</td>
</tr>
<tr>
<td>015</td>
<td>13</td>
<td>CR</td>
<td>Carriage return</td>
</tr>
<tr>
<td>043</td>
<td>35</td>
<td>#</td>
<td>Erase character</td>
</tr>
<tr>
<td>100</td>
<td>64</td>
<td>@</td>
<td>Kill line</td>
</tr>
<tr>
<td>177</td>
<td>127</td>
<td>DEL</td>
<td>Delete</td>
</tr>
</tbody>
</table>
<h3 data-number="2.6.3" id="paper-tape-reader-and-punch"><span class="header-section-number">2.6.3</span> Paper Tape Reader and
Punch</h3>
<p><strong>Paper tape</strong> was the primary storage medium for
programs and data before DECtape.</p>
<p><strong>Characteristics:</strong> - <strong>Width</strong>: 1 inch
(25.4mm) - <strong>Holes</strong>: 8 channels (7 data + 1 sprocket) -
<strong>Format</strong>: Binary or ASCII - <strong>Speed</strong>:
Reader: 300 chars/sec, Punch: 10-50 chars/sec -
<strong>Durability</strong>: Can tear; must be handled carefully</p>
<p><strong>Physical format:</strong></p>
<pre><code>Paper tape (view from top):
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ  ‚óè   ‚óè   ‚óè   ‚óè   ‚óè   ‚óè   ‚óè   ‚óè  ‚îÇ  Channel 8 (parity)
    ‚îÇ     ‚óè       ‚óè           ‚óè       ‚îÇ  Channel 7 (bit 6)
    ‚îÇ  ‚óè       ‚óè       ‚óè   ‚óè       ‚óè  ‚îÇ  Channel 6 (bit 5)
    ‚îÇ     ‚óè   ‚óè   ‚óè   ‚óè   ‚óè   ‚óè   ‚óè  ‚îÇ  Channel 5 (bit 4)
    ‚îÇ  ‚óè   ‚óè   ‚óè   ‚óè   ‚óè   ‚óè   ‚óè   ‚óè  ‚îÇ  Channel 4 (bit 3)
    ‚îÇ     ‚óè   ‚óè       ‚óè       ‚óè       ‚îÇ  Channel 3 (bit 2)
    ‚îÇ  ‚óè       ‚óè   ‚óè       ‚óè   ‚óè   ‚óè  ‚îÇ  Channel 2 (bit 1)
    ‚îÇ     ‚óè       ‚óè   ‚óè   ‚óè       ‚óè   ‚îÇ  Channel 1 (bit 0)
    ‚îÇ  ‚óè   ‚óè   ‚óè   ‚óè   ‚óè   ‚óè   ‚óè   ‚óè  ‚îÇ  Sprocket (feed)
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       Frame (one character per frame)</code></pre>
<p><strong>I/O operations:</strong></p>
<pre class="assembly"><code>" Read from paper tape reader (PTR)
   iot 001           " Read PTR, character ‚Üí AC

" Punch to paper tape (PTP)
   lac char          " Load character
   iot 002           " Punch character

" Binary tape format (18-bit words):
" Each word encoded as 3 frames (6 bits each):
" Frame 1: bits 17-12
" Frame 2: bits 11-6
" Frame 3: bits 5-0</code></pre>
<p><strong>Cross-development workflow (early Unix):</strong></p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  GE 635 Mainframe (GECOS)               ‚îÇ
‚îÇ                                         ‚îÇ
‚îÇ  1. Edit source code                    ‚îÇ
‚îÇ  2. Cross-assemble for PDP-7            ‚îÇ
‚îÇ  3. Generate binary output              ‚îÇ
‚îÇ  4. Punch to paper tape                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
                  ‚îÇ  Paper tape (physical medium)
                  ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  PDP-7                                  ‚îÇ
‚îÇ                                         ‚îÇ
‚îÇ  1. Load paper tape into reader         ‚îÇ
‚îÇ  2. Read binary into memory             ‚îÇ
‚îÇ  3. Execute program                     ‚îÇ
‚îÇ  4. Debug (if necessary, dump to tape)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
<p><strong>Loader from paper tape:</strong></p>
<pre class="assembly"><code>" Simple paper tape binary loader
" Format: Each word on tape is 3 6-bit frames

loader:
   law 4096-1        " Load address for code
   dac 8             " R8 = destination pointer

load_loop:
   iot 001           " Read frame 1 (bits 17-12)
   alss 6            " Shift left 6 bits
   dac temp          " Save

   iot 001           " Read frame 2 (bits 11-6)
   xor temp          " Merge
   alss 6            " Shift left 6 bits
   dac temp          " Save

   iot 001           " Read frame 3 (bits 5-0)
   xor temp          " Merge all 18 bits

   sna               " Skip if Non-zero
   jmp done          " Zero = end of tape

   dac 8 i           " Store word, increment pointer
   jmp load_loop     " Continue

done:
   jmp 4096          " Execute loaded program

temp: 0</code></pre>
<h3 data-number="2.6.4" id="dectape-mass-storage"><span class="header-section-number">2.6.4</span> DECtape (Mass Storage)</h3>
<p><strong>DECtape</strong> was the first mass storage device, providing
reliable file storage.</p>
<p><strong>Characteristics:</strong> - <strong>Capacity</strong>: ~144K
words (288 KB equivalent) - <strong>Speed</strong>: ~5K words/second
transfer - <strong>Format</strong>: 256-word blocks -
<strong>Reliability</strong>: Block checksums, bidirectional read -
<strong>Mounting</strong>: Removable 4-inch reels -
<strong>Durability</strong>: Magnetic tape, more robust than paper
tape</p>
<p><strong>Block structure:</strong></p>
<pre><code>DECtape format:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Block 0: Bootstrap                     ‚îÇ  256 words
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Block 1: Superblock / File system info ‚îÇ  256 words
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Block 2: Inode table                   ‚îÇ  256 words
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Block 3: Inode table (continued)       ‚îÇ  256 words
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Block 4: Data blocks begin             ‚îÇ  256 words
‚îÇ  ...                                    ‚îÇ
‚îÇ  Block N: More data                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Total: ~550 blocks √ó 256 words = ~144K words</code></pre>
<p><strong>I/O operations (from s1.s):</strong></p>
<pre class="assembly"><code>" DECtape I/O (simplified from dskio routine)

dskio: 0              " Read/write disk block
   " AC contains block number on entry

   dac dskaddr       " Save block address
   lac dskbuf        " Load buffer address
   dac dma_addr      " Set DMA address

   lac dskaddr
   alss 8            " Block number √ó 256 words/block
   dac block_addr    " Compute byte offset

   " Issue IOT sequence for DECtape
   lac block_addr
   iot 714           " Select block
   iot 715           " Start read operation

wait_complete:
   iot 716           " Check status
   spa               " Skip if Positive (complete)
   jmp wait_complete " Wait for completion

   jmp dskio i       " Return

dskaddr: 0
dma_addr: 0
block_addr: 0</code></pre>
<p><strong>File system on DECtape:</strong></p>
<p>The Unix file system resided on DECtape blocks:</p>
<pre class="assembly"><code>" Block allocation (conceptual):
" Block 0:    Boot block (bootstrap loader)
" Block 1:    Superblock (free block list, inode count)
" Blocks 2-7: Inode table (file metadata)
" Blocks 8+:  Data blocks (file contents)

" Inode structure (simplified):
i.flgs: 0            " Flags (allocated, directory, etc.)
i.nlks: 0            " Number of links
i.uid:  0            " User ID
i.size: 0            " File size in words
i.addr: .=.+8        " 8 block addresses (direct blocks only)
i.mtim: .=.+2        " Modification time (2 words)
" Total: ~13 words per inode</code></pre>
<h3 data-number="2.6.5" id="display-system-type-340"><span class="header-section-number">2.6.5</span> Display System (Type
340)</h3>
<p>The <strong>DEC Type 340 Precision CRT Display</strong> enabled
vector graphics‚Äîcrucial for Space Travel!</p>
<p><strong>Characteristics:</strong> - <strong>Resolution</strong>: 1024
√ó 1024 addressable points - <strong>Type</strong>: Vector display (draws
lines, not pixels) - <strong>Speed</strong>: ~100,000 points/second -
<strong>Persistence</strong>: Phosphor fades quickly (needs refresh) -
<strong>Interface</strong>: Direct memory access (DMA)</p>
<p><strong>Display operations:</strong></p>
<pre class="assembly"><code>" Display file format: sequence of commands in memory
" Commands: move, draw, character, intensity

" Display file example (draw square):
display_file:
   0040000         " Move to (0, 0)
   0000000         " X=0, Y=0
   0140000         " Draw to (512, 0)
   0020000         " X=512, Y=0
   0140000         " Draw to (512, 512)
   0020020         " X=512, Y=512
   0140000         " Draw to (0, 512)
   0000020         " X=0, Y=512
   0140000         " Draw to (0, 0)
   0000000         " X=0, Y=0
   0000001         " Stop display file

" Activate display:
   law display_file
   iot 007         " Set display file pointer
   iot 017         " Start display</code></pre>
<p><strong>Space Travel game (the reason Unix exists!):</strong></p>
<pre class="assembly"><code>" Simplified Space Travel display logic
" (Actual game code is lost)

game_loop:
   jms calculate_positions  " Update planet/ship positions
   jms build_display_file   " Create drawing commands
   jms activate_display     " Show on screen
   jms read_keyboard        " Get user input
   jms update_physics       " Apply thrust, gravity
   jmp game_loop

calculate_positions: 0
   " Newtonian physics calculations
   " F = ma, orbits, thrust vectors
   " ...
   jmp calculate_positions i

build_display_file: 0
   law display_mem      " Display file location
   dac 8                " R8 = pointer (auto-increment)

   " Draw sun
   lac sun_x
   dac 8 i              " X coordinate
   lac sun_y
   dac 8 i              " Y coordinate

   " Draw planets (loop through planet table)
   " ...

   " Draw spacecraft
   lac ship_x
   dac 8 i
   lac ship_y
   dac 8 i

   " End display file
   lac d1
   dac 8 i              " Stop command

   jmp build_display_file i</code></pre>
<p><strong>Display device file (from init.s):</strong></p>
<pre class="assembly"><code>displ:
   &lt;di&gt;;&lt;sp&gt;;&lt;la&gt;;&lt;y 040   " "display" filename

" Process using display:
   sys open; displ; 1   " File descriptor 1 (stdout ‚Üí display)
   " Now sys write outputs to display instead of TTY!</code></pre>
<h3 data-number="2.6.6" id="real-time-clock"><span class="header-section-number">2.6.6</span> Real-Time Clock</h3>
<p>Provided timekeeping and periodic interrupts.</p>
<p><strong>Characteristics:</strong> - <strong>Frequency</strong>: 60 Hz
(16.67ms per tick) - <strong>Interrupt</strong>: Timer interrupt every
tick - <strong>Use</strong>: Process scheduling, time measurement</p>
<p><strong>Clock handling (from s1.s):</strong></p>
<pre class="assembly"><code>" Clock interrupt handler (called 60 times/second)

clock_interrupt:
   iof               " Disable interrupts
   dac u.ac          " Save AC

   isz uquant        " Increment user quantum
   lac uquant
   sad maxquant      " Skip if AC Different from max
   jms swap          " Quantum expired: swap process

   " Update system time
   isz u.time
   lac u.time
   sna
   isz u.time+1      " 36-bit time counter

   ion               " Re-enable interrupts
   jmp restore_state " Return from interrupt

uquant: 0            " Current quantum count
maxquant: 020        " Maximum quantum (20 ticks)</code></pre>
<hr/>
<h2 data-number="2.7" id="io-architecture"><span class="header-section-number">2.7</span> 6. I/O Architecture</h2>
<h3 data-number="2.7.1" id="iot-inputoutput-transfer-instructions"><span class="header-section-number">2.7.1</span> IOT (Input/Output Transfer)
Instructions</h3>
<p>The PDP-7 used <strong>IOT instructions</strong> for all device I/O.
Each device had unique IOT codes.</p>
<p><strong>IOT instruction format:</strong></p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ111‚îÇ DEVICE  ‚îÇ  PULSE  ‚îÇ  18 bits
‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 3b    6 bits    9 bits

Opcode (111): All IOT instructions have opcode 7 (octal)
Device (6 bits): Selects device (64 possible devices)
Pulse (9 bits): Device-specific command

Octal encoding: 7DDDPP
   7: IOT opcode
   DDD: Device code
   PP: Pulse/function code</code></pre>
<p><strong>Common IOT instructions:</strong></p>
<table>
<thead>
<tr>
<th>Octal</th>
<th>Device</th>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>700001</td>
<td>00</td>
<td>ION</td>
<td>Interrupts on</td>
</tr>
<tr>
<td>700002</td>
<td>00</td>
<td>IOF</td>
<td>Interrupts off</td>
</tr>
<tr>
<td>700201</td>
<td>01</td>
<td>PTR</td>
<td>Read paper tape reader</td>
</tr>
<tr>
<td>700202</td>
<td>01</td>
<td>PTP</td>
<td>Punch paper tape</td>
</tr>
<tr>
<td>700311</td>
<td>01</td>
<td>TTI</td>
<td>Read teletype input</td>
</tr>
<tr>
<td>700312</td>
<td>01</td>
<td>TTO</td>
<td>Write teletype output</td>
</tr>
<tr>
<td>700714</td>
<td>03</td>
<td>DTRA</td>
<td>DECtape read address</td>
</tr>
<tr>
<td>700715</td>
<td>03</td>
<td>DTRD</td>
<td>DECtape read data</td>
</tr>
<tr>
<td>700716</td>
<td>03</td>
<td>DTST</td>
<td>DECtape status</td>
</tr>
</tbody>
</table>
<p><strong>Device register model:</strong></p>
<p>Each device has control/status/data registers accessed via IOT:</p>
<pre><code>Teletype device (conceptual):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  TTY Controller                    ‚îÇ
‚îÇ                                    ‚îÇ
‚îÇ  Input Buffer:   [char] (1 word)   ‚îÇ
‚îÇ  Output Buffer:  [char] (1 word)   ‚îÇ
‚îÇ  Status Reg:     [flags]           ‚îÇ
‚îÇ    - Input ready                   ‚îÇ
‚îÇ    - Output ready                  ‚îÇ
‚îÇ    - Error flags                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

IOT 011: Read Input Buffer ‚Üí AC
IOT 012: AC ‚Üí Output Buffer
IOT 013: Status ‚Üí AC</code></pre>
<h3 data-number="2.7.2" id="programmed-io"><span class="header-section-number">2.7.2</span> Programmed I/O</h3>
<p><strong>Programmed I/O</strong> means the CPU directly controls data
transfer (no DMA).</p>
<p><strong>Example: Character output to TTY</strong></p>
<pre class="assembly"><code>" Output one character via programmed I/O
" Character in AC

tty_out: 0
   dac char          " Save character

wait_ready:
   iot 013           " Read TTY status
   and o200          " Mask output-ready bit
   sza               " Skip if Zero (not ready)
   jmp wait_ready    " Wait until ready

   lac char          " Load character
   iot 012           " Send to TTY

   jmp tty_out i     " Return

char: 0
o200: 0200           " Output-ready bit mask</code></pre>
<p><strong>Performance implications:</strong></p>
<pre><code>Character output at 10 chars/sec (TTY):
   - 100ms per character
   - CPU must wait ~175,000 cycles per character!
   - Wastes CPU time in wait loop

Solution: Buffering + interrupts</code></pre>
<h3 data-number="2.7.3" id="interrupt-driven-io"><span class="header-section-number">2.7.3</span> Interrupt-Driven I/O</h3>
<p><strong>Interrupts</strong> allow devices to signal the CPU when
ready, freeing CPU for other work.</p>
<p><strong>Interrupt mechanism:</strong></p>
<pre><code>1. Device completes operation (e.g., TTY ready for next char)
2. Device raises interrupt signal
3. CPU finishes current instruction
4. CPU saves PC and state
5. CPU jumps to interrupt vector (device-specific address)
6. Interrupt handler processes event
7. Handler executes ION; return instruction
8. CPU restores state and continues

Interrupt vectors (memory addresses):
   000020: System call
   000030: Clock (60 Hz)
   000040: TTY input
   000050: TTY output
   000060: Paper tape
   000070: DECtape
   000100: Display</code></pre>
<p><strong>Interrupt handler example (from s1.s):</strong></p>
<pre class="assembly"><code>" TTY input interrupt handler

. = 000040            " Interrupt vector for TTY input
   tty_in_handler     " Address of handler

tty_in_handler:
   iof               " Disable further interrupts
   dac save_ac       " Save AC

   iot 011           " Read character from TTY
   dac char          " Store in buffer

   " Add to input queue
   lac inq_tail      " Load queue tail pointer
   dac 8             " R8 = pointer
   lac char
   dac 8 i           " Store character, increment pointer
   lac 8
   dac inq_tail      " Update tail

   lac save_ac       " Restore AC
   ion               " Re-enable interrupts
   jmp save_pc i     " Return from interrupt

save_ac: 0
save_pc: 0
char: 0
inq_tail: 0</code></pre>
<p><strong>Programmed I/O vs Interrupt-Driven:</strong></p>
<pre class="assembly"><code>" Method 1: Programmed I/O (POLLING)
output_char_polling:
1:
   iot 013           " Check TTY status
   and o200          " Output ready?
   sza
   jmp 1b            " Wait (wastes CPU cycles)
   iot 012           " Output character
   " 100ms of CPU time wasted per character!

" Method 2: Interrupt-Driven (EFFICIENT)
output_char_interrupt:
   lac char
   dac outq_tail i   " Add to output queue
   isz outq_tail
   " ... CPU continues other work ...
   " Interrupt fires when TTY ready
   " Handler sends next character from queue
   " ~0ms CPU wait time!</code></pre>
<h3 data-number="2.7.4" id="data-transfer-mechanisms"><span class="header-section-number">2.7.4</span> Data Transfer Mechanisms</h3>
<h4 data-number="2.7.4.1" id="character-io-single-character"><span class="header-section-number">2.7.4.1</span> Character I/O (Single
Character)</h4>
<pre class="assembly"><code>" Read one character (blocking)
   cla
   sys read; buffer; 1   " Read 1 word (2 chars)
   lac buffer
   lrss 9                " Extract left character
   and o177              " Mask to ASCII</code></pre>
<h4 data-number="2.7.4.2" id="block-io-disk"><span class="header-section-number">2.7.4.2</span> Block I/O (Disk)</h4>
<pre class="assembly"><code>" Read disk block (256 words)
   lac block_num     " Block number (0-N)
   jms dskio         " Disk I/O routine
   " On return, dskbuf contains 256 words

" dskio routine (simplified):
dskio: 0
   alss 8            " Block √ó 256 = word offset
   dac addr          " Store address
   law dskbuf        " Buffer address
   dac dma_ptr       " DMA pointer
   lac addr
   iot 714           " DECtape: select block
   iot 715           " DECtape: start read
1:
   iot 716           " Check status
   spa               " Skip if Positive (done)
   jmp 1b            " Wait for completion
   jmp dskio i       " Return</code></pre>
<h4 data-number="2.7.4.3" id="buffered-io"><span class="header-section-number">2.7.4.3</span> Buffered I/O</h4>
<p>All Unix I/O is buffered for efficiency:</p>
<pre class="assembly"><code>" Character output buffering (from cat.s)

putc: 0              " Output one character
   and o177          " Mask character
   dac char          " Save

   lac noc           " Number of chars in buffer
   sad d128          " Skip if Different from 128
   jmp flush         " Buffer full: flush

   " Add character to buffer
   lac opt           " Output pointer
   dac 8             " R8 = pointer
   lac char
   dac 8 i           " Store char, increment
   lac 8
   dac opt           " Update pointer

   isz noc           " Increment count
   jmp putc i        " Return

flush:
   lac fo            " File descriptor
   sys write; outbuf; 64  " Write 64 words (128 chars)
   dzm noc           " Reset count
   lac outbuf
   dac opt           " Reset pointer
   jmp putc+1        " Re-add character

noc: 0               " Number of characters
opt: 0               " Output pointer
char: 0
fo: 1                " File descriptor (stdout)
d128: 128
outbuf: .=.+64       " Output buffer (64 words = 128 chars)</code></pre>
<p><strong>Buffering benefits:</strong></p>
<pre><code>Without buffering:
   - 128 system calls to write 128 characters
   - 128 √ó (trap overhead + driver overhead) = ~12,800 cycles

With buffering:
   - 1 system call to write 128 characters
   - 1 √ó (trap overhead + driver overhead) = ~100 cycles
   - 128√ó speedup!</code></pre>
<hr/>
<h2 data-number="2.8" id="technical-specifications"><span class="header-section-number">2.8</span> 7. Technical
Specifications</h2>
<h3 data-number="2.8.1" id="complete-hardware-specifications"><span class="header-section-number">2.8.1</span> Complete Hardware
Specifications</h3>
<table>
<thead>
<tr>
<th>Component</th>
<th>Specification</th>
<th>Details</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CPU</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Word size</td>
<td>18 bits</td>
<td>All operations on 18-bit words</td>
</tr>
<tr>
<td>Instruction set</td>
<td>16 instructions</td>
<td>Plus IOT variants</td>
</tr>
<tr>
<td>Instruction format</td>
<td>1 word</td>
<td>3-bit opcode + addressing</td>
</tr>
<tr>
<td>Cycle time</td>
<td>1.75 Œºs</td>
<td>~570,000 instructions/sec max</td>
</tr>
<tr>
<td>Registers</td>
<td>4 visible</td>
<td>AC, MQ, Link, PC (13-bit)</td>
</tr>
<tr>
<td><strong>Memory</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Maximum</td>
<td>8K words</td>
<td>8,192 words = 16,384 bytes</td>
</tr>
<tr>
<td>Typical</td>
<td>4K-8K words</td>
<td>8,192-16,384 bytes</td>
</tr>
<tr>
<td>Access time</td>
<td>1.75 Œºs</td>
<td>Same as cycle time</td>
</tr>
<tr>
<td>Word organization</td>
<td>18 bits</td>
<td>Not byte-addressable</td>
</tr>
<tr>
<td>Auto-increment</td>
<td>8 locations</td>
<td>Locations 010-017 (octal)</td>
</tr>
<tr>
<td><strong>Storage</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>DECtape capacity</td>
<td>~144K words</td>
<td>~288 KB, removable reels</td>
</tr>
<tr>
<td>Block size</td>
<td>256 words</td>
<td>512 bytes equivalent</td>
</tr>
<tr>
<td>Transfer rate</td>
<td>~5K words/sec</td>
<td>~10 KB/sec</td>
</tr>
<tr>
<td><strong>I/O Devices</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Teletype</td>
<td>110 baud</td>
<td>10 chars/sec, Model 33/35</td>
</tr>
<tr>
<td>Paper tape reader</td>
<td>300 chars/sec</td>
<td>8-channel tape</td>
</tr>
<tr>
<td>Paper tape punch</td>
<td>10-50 chars/sec</td>
<td>8-channel output</td>
</tr>
<tr>
<td>Display</td>
<td>340 Precision</td>
<td>1024√ó1024 vector display</td>
</tr>
<tr>
<td>Clock</td>
<td>60 Hz</td>
<td>Programmable interval timer</td>
</tr>
<tr>
<td><strong>Physical</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Dimensions</td>
<td>Varies</td>
<td>Cabinet + peripherals</td>
</tr>
<tr>
<td>Power</td>
<td>~2 KW</td>
<td>115V AC</td>
</tr>
<tr>
<td>Weight</td>
<td>~250 kg</td>
<td>~550 lbs</td>
</tr>
<tr>
<td>Cooling</td>
<td>Forced air</td>
<td>Fans required</td>
</tr>
<tr>
<td><strong>Cost</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>System price (1965)</td>
<td>~$72,000</td>
<td>Equivalent to ~$650,000 in 2025</td>
</tr>
<tr>
<td>Educational discount</td>
<td>~$50,000</td>
<td>Universities paid less</td>
</tr>
</tbody>
</table>
<h3 data-number="2.8.2" id="performance-characteristics"><span class="header-section-number">2.8.2</span> Performance
Characteristics</h3>
<p><strong>Instruction timing (in microseconds):</strong></p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Cycles</th>
<th>Time (Œºs)</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>LAC (direct)</td>
<td>1</td>
<td>1.75</td>
<td>Single memory fetch</td>
</tr>
<tr>
<td>LAC (indirect)</td>
<td>2</td>
<td>3.50</td>
<td>Two memory accesses</td>
</tr>
<tr>
<td>DAC (direct)</td>
<td>1</td>
<td>1.75</td>
<td>Single memory store</td>
</tr>
<tr>
<td>DAC (indirect)</td>
<td>2</td>
<td>3.50</td>
<td>Two memory accesses</td>
</tr>
<tr>
<td>ISZ</td>
<td>2</td>
<td>3.50</td>
<td>Read + modify + write</td>
</tr>
<tr>
<td>TAD</td>
<td>1</td>
<td>1.75</td>
<td>Add with memory</td>
</tr>
<tr>
<td>JMP</td>
<td>1</td>
<td>1.75</td>
<td>Branch</td>
</tr>
<tr>
<td>JMS</td>
<td>2</td>
<td>3.50</td>
<td>Save + branch</td>
</tr>
<tr>
<td>CLA</td>
<td>1</td>
<td>1.75</td>
<td>Microcode</td>
</tr>
<tr>
<td>RAL</td>
<td>1</td>
<td>1.75</td>
<td>Microcode</td>
</tr>
<tr>
<td>Auto-increment</td>
<td>+0.5</td>
<td>+0.875</td>
<td>Extra half-cycle</td>
</tr>
</tbody>
</table>
<p><strong>Example: Subroutine call overhead</strong></p>
<pre class="assembly"><code>" Calling overhead:
   jms sub           " 2 cycles = 3.50 Œºs
   " ... subroutine body ...
   jmp sub i         " 2 cycles = 3.50 Œºs

" Total overhead: 4 cycles = 7.00 Œºs
" At 60 calls/sec: 0.042% overhead
" At 10,000 calls/sec: 7% overhead</code></pre>
<p><strong>System call overhead (from measurements):</strong></p>
<pre><code>sys read system call:
   1. User trap: ~10 cycles (17.5 Œºs)
   2. Kernel dispatch: ~20 cycles (35 Œºs)
   3. Buffer management: ~30 cycles (52.5 Œºs)
   4. Device I/O: varies (0-100ms for TTY)
   5. Return to user: ~10 cycles (17.5 Œºs)

Total (excluding I/O): ~70 cycles = ~122 Œºs
Total (with TTY I/O): ~100,000 Œºs = 100ms</code></pre>
<h3 data-number="2.8.3" id="memory-bandwidth"><span class="header-section-number">2.8.3</span> Memory Bandwidth</h3>
<pre><code>Memory bandwidth:
   Cycle time: 1.75 Œºs
   Word size: 18 bits = 2.25 bytes

   Max bandwidth = 2.25 bytes / 1.75 Œºs
                 = 1.29 MB/sec (theoretical)

   Realistic (with instruction overhead):
   ~0.5 MB/sec for data transfers</code></pre>
<p><strong>Comparison to modern systems (2025):</strong></p>
<table>
<thead>
<tr>
<th>Metric</th>
<th>PDP-7 (1965)</th>
<th>Modern CPU (2025)</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cycle time</td>
<td>1.75 Œºs</td>
<td>0.3 ns</td>
<td>5,833√ó faster</td>
</tr>
<tr>
<td>Memory</td>
<td>16 KB</td>
<td>64 GB</td>
<td>4,000,000√ó more</td>
</tr>
<tr>
<td>Disk</td>
<td>288 KB</td>
<td>4 TB</td>
<td>14,000,000√ó more</td>
</tr>
<tr>
<td>Cost</td>
<td>$72,000</td>
<td>$1,500</td>
<td>48√ó cheaper</td>
</tr>
<tr>
<td>Power</td>
<td>2,000 W</td>
<td>150 W</td>
<td>13√ó less</td>
</tr>
</tbody>
</table>
<hr/>
<h2 data-number="2.9" id="assembly-language-syntax-1"><span class="header-section-number">2.9</span> 8. Assembly Language
Syntax</h2>
<h3 data-number="2.9.1" id="octal-notation-1"><span class="header-section-number">2.9.1</span> Octal Notation</h3>
<p><strong>All numbers in PDP-7 assembly are octal (base 8) unless
specified.</strong></p>
<pre class="assembly"><code>" Octal constants (default):
   lac 177          " Octal 177 = 127 decimal = 0b1111111
   dac 10000        " Octal 10000 = 4096 decimal

" Decimal constants (special notation in some assemblers):
   -64              " Negative decimal (assembler converts)

" Octal-decimal conversion:
   Octal 100 = (1√ó8¬≤) + (0√ó8¬π) + (0√ó8‚Å∞) = 64 decimal
   Octal 377 = (3√ó8¬≤) + (7√ó8¬π) + (7√ó8‚Å∞) = 255 decimal
   Octal 177777 = 65535 decimal (16-bit max)</code></pre>
<p><strong>Common octal values:</strong></p>
<table>
<thead>
<tr>
<th>Octal</th>
<th>Binary</th>
<th>Decimal</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>000</td>
<td>0</td>
<td>Zero</td>
</tr>
<tr>
<td>1</td>
<td>001</td>
<td>1</td>
<td>One</td>
</tr>
<tr>
<td>7</td>
<td>111</td>
<td>7</td>
<td>Low 3 bits set</td>
</tr>
<tr>
<td>10</td>
<td>001000</td>
<td>8</td>
<td>Eight (R8)</td>
</tr>
<tr>
<td>17</td>
<td>001111</td>
<td>15</td>
<td>Last auto-inc reg</td>
</tr>
<tr>
<td>20</td>
<td>010000</td>
<td>16</td>
<td>Interrupt vector</td>
</tr>
<tr>
<td>40</td>
<td>100000</td>
<td>32</td>
<td>Space character</td>
</tr>
<tr>
<td>100</td>
<td>001000000</td>
<td>64</td>
<td>Common limit</td>
</tr>
<tr>
<td>177</td>
<td>001111111</td>
<td>127</td>
<td>7-bit mask (ASCII)</td>
</tr>
<tr>
<td>377</td>
<td>011111111</td>
<td>255</td>
<td>8-bit mask</td>
</tr>
<tr>
<td>777</td>
<td>111111111</td>
<td>511</td>
<td>9-bit mask</td>
</tr>
<tr>
<td>7777</td>
<td>0111111111111</td>
<td>4095</td>
<td>12-bit mask</td>
</tr>
<tr>
<td>17777</td>
<td>001111111111111</td>
<td>8191</td>
<td>13-bit mask (address)</td>
</tr>
<tr>
<td>77777</td>
<td>00111111111111111</td>
<td>32767</td>
<td>15-bit max positive</td>
</tr>
<tr>
<td>177777</td>
<td>001111111111111111</td>
<td>65535</td>
<td>16-bit max</td>
</tr>
<tr>
<td>777777</td>
<td>111111111111111111</td>
<td>262143</td>
<td>18-bit max</td>
</tr>
</tbody>
</table>
<h3 data-number="2.9.2" id="instruction-syntax"><span class="header-section-number">2.9.2</span> Instruction Syntax</h3>
<p><strong>Basic format:</strong></p>
<pre class="assembly"><code>[label:] opcode [i] operand [; comment]

Components:
   label:    Optional identifier (ends with colon)
   opcode:   Instruction mnemonic (lac, dac, jmp, etc.)
   i:        Optional indirect suffix
   operand:  Address, register, or value
   comment:  Optional (starts with " or ;)</code></pre>
<p><strong>Examples with syntax breakdown:</strong></p>
<pre class="assembly"><code>" Labels define addresses
start:             " Label 'start' = current address
   lac d1          " Load AC from address 'd1'
                   "   Opcode: lac (load AC)
                   "   Operand: d1 (symbol)

loop:              " Label 'loop'
   tad value       " Add 'value' to AC
   dac result      " Store AC to 'result'
   jmp loop        " Jump to 'loop' (infinite loop!)

" Indirect addressing (i suffix)
   lac ptr         " Direct: load from 'ptr'
   lac ptr i       " Indirect: load from address in 'ptr'

" Literals (constants)
   lac 4096        " Load literal value 4096 (octal)
   -1              " Load literal -1 (all bits set)

" Auto-increment registers
   lac 8 i         " Load from address in R8, increment R8
   dac 9 i         " Store to address in R9, increment R9

" System calls
   sys read; buffer; 64
   " Expands to:
   "    jms .read
   "    buffer
   "    64</code></pre>
<h3 data-number="2.9.3" id="labels-and-symbols"><span class="header-section-number">2.9.3</span> Labels and Symbols</h3>
<pre class="assembly"><code>" Labels (address definitions):
start:             " Absolute address label
   lac count

count: 0           " Data label with initial value
max: 100           " Constant label

" Local labels (numeric):
1:                 " Local label '1'
   lac counter
   isz counter
   jmp 1b          " Jump back to label '1' above (1 backward)

   jms sub
   " ... code ...
   jmp 1f          " Jump forward to label '1' below (1 forward)

1:                 " Another local label '1'
   " ... code ...

" Assembler directives:
. = 4096           " Set location counter to 4096
buffer: .=.+64     " Reserve 64 words (label + advance counter)

" Symbol definition:
d1 = 1             " Define constant symbol
MAXBUF = 128       " Named constant</code></pre>
<h3 data-number="2.9.4" id="comments"><span class="header-section-number">2.9.4</span> Comments</h3>
<pre class="assembly"><code>" Comment style 1: Double-quote (traditional)
   lac value       " This is a comment

; Comment style 2: Semicolon (alternate)
   dac result      ; This is also a comment

" Multi-line comments:
"
" This is a longer comment
" explaining the following code
" in more detail.
"
   jms complex_routine</code></pre>
<h3 data-number="2.9.5" id="assembler-directives"><span class="header-section-number">2.9.5</span> Assembler Directives</h3>
<pre class="assembly"><code>" Location counter:
. = 1000           " Set address to 1000 (octal)
   lac d1          " This instruction at address 1000

" Space reservation:
buffer: .=.+64     " Reserve 64 words (buffer label)
   " Current address now 64 words higher

" Data initialization:
message:
   &lt;he&gt;;&lt;ll&gt;;&lt;o 040  " Packed characters "hello"
   012                 " Newline character

" Constants:
d1: 1              " Word containing 1
d10: 10            " Word containing 10 (octal) = 8 decimal
minus1: -1         " Word containing -1 (777777 octal)

" Expressions:
limit: buffer+64   " Address arithmetic
mask: 0177         " Octal constant

" Include files (some assemblers):
include "defs.s"   " Include external definitions</code></pre>
<hr/>
<h2 data-number="2.10" id="subroutine-linkage"><span class="header-section-number">2.10</span> 9. Subroutine Linkage</h2>
<h3 data-number="2.10.1" id="jms-mechanism"><span class="header-section-number">2.10.1</span> JMS Mechanism</h3>
<p>The <strong>JMS (Jump to Subroutine)</strong> instruction is Unix‚Äôs
primary subroutine mechanism.</p>
<p><strong>Calling convention:</strong></p>
<pre class="assembly"><code>" Subroutine structure:
subname: 0         " First word: return address storage
   " ... subroutine body ...
   jmp subname i   " Return: indirect jump through first word

" Calling:
   jms subname     " Call subroutine
   " Execution continues here after return</code></pre>
<p><strong>Detailed execution:</strong></p>
<pre class="assembly"><code>" Complete example:

main:
   lac value       " Address 1000: Load value
   jms double      " Address 1001: Call subroutine
   dac result      " Address 1002: Store result
   " ... continue ...

double: 0          " Address 2000: Return address space
   tad value       " Address 2001: Subroutine body
   jmp double i    " Address 2002: Return

value: 5
result: 0

" Execution trace:
" 1. PC=1000: lac value ‚Üí AC=5
" 2. PC=1001: jms double
"    - memory[2000] ‚Üê 1002 (save return address)
"    - PC ‚Üê 2001 (jump to subroutine body)
" 3. PC=2001: tad value ‚Üí AC=10
" 4. PC=2002: jmp double i
"    - PC ‚Üê memory[2000] = 1002 (return)
" 5. PC=1002: dac result ‚Üí memory[result]=10</code></pre>
<h3 data-number="2.10.2" id="parameter-passing"><span class="header-section-number">2.10.2</span> Parameter Passing</h3>
<p><strong>Method 1: Global variables (most common)</strong></p>
<pre class="assembly"><code>" Globals for parameters
param1: 0
param2: 0
result: 0

" Caller:
   lac x
   dac param1
   lac y
   dac param2
   jms add_sub
   lac result       " Get result

" Subroutine:
add_sub: 0
   lac param1
   tad param2
   dac result
   jmp add_sub i</code></pre>
<p><strong>Method 2: AC/MQ register passing</strong></p>
<pre class="assembly"><code>" Caller:
   lac x            " First parameter in AC
   lmq              " Second parameter from MQ
   jms multiply
   " Result in AC

" Subroutine:
multiply: 0
   " AC contains multiplicand
   " MQ contains multiplier
   mul              " (Hypothetical multiply instruction)
   jmp multiply i</code></pre>
<p><strong>Method 3: Inline parameters</strong></p>
<pre class="assembly"><code>" Caller:
   jms function
   x                " Parameter 1 (inline after call)
   y                " Parameter 2
   " Return here (function adjusts return address)

" Subroutine:
function: 0
   dac save_ac      " Save AC
   lac function     " Load return address
   dac ptr          " Save as pointer
   lac ptr i        " Get parameter 1 (auto-increment)
   dac param1
   lac ptr i        " Get parameter 2 (auto-increment)
   dac param2
   lac ptr          " Load adjusted return address
   dac function     " Update return address (skip parameters)
   lac save_ac      " Restore AC
   " ... function body ...
   jmp function i   " Return past parameters

save_ac: 0
ptr: 0
param1: 0
param2: 0</code></pre>
<p><strong>Method 4: Auto-increment registers</strong></p>
<pre class="assembly"><code>" Caller:
   law args-1       " Point to argument list
   dac 8            " R8 = argument pointer
   jms process_args
   " ...

args:
   arg1
   arg2
   arg3
   0                " Null terminator

" Subroutine:
process_args: 0
loop:
   lac 8 i          " Get next argument, auto-increment
   sza              " Skip if Zero (end marker)
   jmp done
   " ... process argument in AC ...
   jmp loop
done:
   jmp process_args i</code></pre>
<h3 data-number="2.10.3" id="return-values"><span class="header-section-number">2.10.3</span> Return Values</h3>
<p><strong>Method 1: AC register</strong></p>
<pre class="assembly"><code>" Most common: return in AC
getchar: 0
   " ... read character ...
   lac char         " Return value in AC
   jmp getchar i

" Caller:
   jms getchar
   dac save_char    " AC contains return value</code></pre>
<p><strong>Method 2: Global variable</strong></p>
<pre class="assembly"><code>" Return via global
readblock: 0
   " ... read data ...
   lac bytes_read
   dac result       " Store result in global
   jmp readblock i

result: 0

" Caller:
   jms readblock
   lac result       " Get return value from global</code></pre>
<p><strong>Method 3: Status in Link</strong></p>
<pre class="assembly"><code>" Use Link for success/failure
openfile: 0
   " ... attempt to open file ...
   " If success: cll (Link=0)
   " If failure: cml (Link=1)
   jmp openfile i

" Caller:
   jms openfile
   snl              " Skip if Link Non-zero (error)
   jmp success
   " ... handle error ...
success:
   " ... file opened ...</code></pre>
<h3 data-number="2.10.4" id="non-reentrant-limitation"><span class="header-section-number">2.10.4</span> Non-Reentrant
Limitation</h3>
<p><strong>Critical constraint: PDP-7 subroutines cannot call
themselves.</strong></p>
<pre class="assembly"><code>" Problem: Recursive call destroys return address

factorial: 0         " Return address storage
   lac n
   sad d1            " Skip if AC Different from 1
   jmp base_case

   " Recursive case: n * factorial(n-1)
   -1
   tad n
   dac n             " n = n - 1
   jms factorial     " PROBLEM: Overwrites factorial[0]!
                     " Original return address LOST!
   " ... multiply ...

base_case:
   lac d1
   jmp factorial i   " Returns to WRONG address

" After first recursive call:
" factorial[0] no longer contains original return address!
" It contains return address from recursive call!</code></pre>
<p><strong>Workaround: Manual stack (rarely used,
expensive)</strong></p>
<pre class="assembly"><code>" Simulate stack for recursion
STACK_SIZE = 100
stack: .=.+STACK_SIZE
sp: stack-1          " Stack pointer

" Push return address:
push_return: 0
   lac sp
   dac 8             " R8 = stack pointer
   lac factorial     " Load return address from subroutine
   dac 8 i           " Push to stack, increment SP
   lac 8
   dac sp            " Update stack pointer
   jmp push_return i

" Pop return address:
pop_return: 0
   -1
   tad sp            " Decrement SP
   dac sp
   dac 8             " R8 = decremented SP
   lac 8 i           " Pop from stack
   dac factorial     " Restore return address
   jmp pop_return i

" Recursive subroutine using manual stack:
factorial: 0
   jms push_return   " Save return address
   " ... recursive logic ...
   jms pop_return    " Restore return address
   jmp factorial i   " Return

" Problems:
" 1. Overhead: 20+ instructions per recursion level
" 2. Complexity: Manual stack management
" 3. Stack limit: Fixed size (overflow risk)
" Result: Recursion rarely used in PDP-7 Unix</code></pre>
<p><strong>Unix solution: Avoid recursion entirely</strong></p>
<pre><code>Unix design principle:
   "Use iteration, not recursion."

Examples:
   - Directory traversal: Iterative with queue
   - Expression evaluation: Iterative with stack
   - Tree walking: Iterative with explicit stack

This limitation influenced Unix's iterative design patterns!</code></pre>
<hr/>
<h2 data-number="2.11" id="hardware-constraints-and-their-impact-on-unix"><span class="header-section-number">2.11</span> 10. Hardware Constraints and
Their Impact on Unix</h2>
<p>The PDP-7‚Äôs limitations profoundly shaped Unix‚Äôs design.
Understanding these constraints explains <em>why</em> Unix works the way
it does.</p>
<h3 data-number="2.11.1" id="bit-architecture-impact"><span class="header-section-number">2.11.1</span> 18-Bit Architecture
Impact</h3>
<p><strong>Character encoding:</strong></p>
<pre class="assembly"><code>" 9-bit characters supported extended ASCII:
" Bits 8-7: Extension bits (case, graphics)
" Bits 6-0: Standard ASCII

" Examples:
" 'A' = 0101 (octal) = 065 (decimal) = uppercase
" 'a' = 0141 (octal) = 097 (decimal) = lowercase
"       ‚Üë bit 8 indicates lowercase

" This 9-bit encoding allowed:
" - Upper and lowercase (128 + 128 = 256 chars)
" - Graphics characters
" - Control characters
" - Extended symbols

" But caused problems:
" - Not compatible with later 8-bit systems
" - Character masking required (and o177)
" - Conversion needed for 7-bit ASCII</code></pre>
<p><strong>Word-oriented I/O:</strong></p>
<pre class="assembly"><code>" Files measured in WORDS, not bytes:
" Problem: File size ambiguous

" Example: 3-character file "cat"
" Storage: [ca][t ]  (2 words, 4 characters)
" File size: 2 words
" Actual data: 3 characters
" Wasted space: 1 character slot

" Solution in Unix:
" - Store character count separately
" - Inode contains size in WORDS
" - Application tracks actual character count
" - Inefficient for small files

i.size: 2            " File size in words (from inode)
" Actual characters: Unknown (could be 3 or 4)</code></pre>
<h3 data-number="2.11.2" id="memory-limitations"><span class="header-section-number">2.11.2</span> Memory Limitations</h3>
<p><strong>8K words = 16 KB total addressable</strong></p>
<pre class="assembly"><code>" Memory allocation (approximate):
"
" 0000-0377:   256 words   Kernel vectors/data
" 0400-3777:   3584 words  Kernel code
" 4000-7777:   4096 words  User space
" Total:       8192 words  (16 KB)

" Implications:
" 1. Kernel must be &lt; 3.5K words (~7 KB)
" 2. User programs must be &lt; 4K words (~8 KB)
" 3. No room for large buffers
" 4. No room for multiple processes in memory simultaneously

" Solution: Swapping
" - Only ONE user process in memory at a time
" - Other processes swapped to disk
" - Context switch = disk I/O (slow!)</code></pre>
<p><strong>Swapping mechanics from s1.s:</strong></p>
<pre class="assembly"><code>swap: 0
   ion               " Enable interrupts

   " Find process to swap in
1:
   jms lookfor; 3    " Look for out/ready process
   jmp found
   jms lookfor; 1    " Look for in/ready process
   skp
   jmp 1b            " Keep searching

found:
   " Save current process to disk
   iof               " Disable interrupts
   lac u.ulistp i    " Mark process as 'swapped out'
   tad o200000
   dac u.ulistp i
   ion               " Re-enable interrupts

   jms dskswap; 07000  " Write process to disk (block 07000)

   " Load new process from disk
   jms dskswap; 06000  " Read process from disk (block 06000)

   " Update process status
   lac o600000
   tad new_proc
   dac new_proc      " Mark as 'swapped in'

   jmp swap i        " Return

" Swap overhead:
" - Save: ~256 words to disk (~50ms)
" - Load: ~256 words from disk (~50ms)
" - Total: ~100ms per context switch!
" Compare to modern: &lt; 1Œºs</code></pre>
<h3 data-number="2.11.3" id="io-limitations"><span class="header-section-number">2.11.3</span> I/O Limitations</h3>
<p><strong>Slow peripherals:</strong></p>
<pre><code>Device speeds:
   Teletype:       10 chars/sec    (100ms per char)
   Paper tape:     300 chars/sec   (3.3ms per char)
   DECtape:        5K words/sec    (0.2ms per word)
   Display:        100K points/sec (10Œºs per point)

CPU speed:        570K inst/sec   (1.75Œºs per inst)

Mismatch:
   CPU can execute 57,000 instructions while waiting
   for ONE character from teletype!</code></pre>
<p><strong>Solution: Buffering and interrupts</strong></p>
<pre class="assembly"><code>" Without buffering:
" Write 100 characters to TTY

   lac buffer_ptr
   dac 8             " R8 = pointer
   -100
   dac counter
loop:
   lac 8 i           " Get character
   jms tty_out       " Output (waits ~100ms)
   isz counter
   jmp loop
   " Total time: 100 √ó 100ms = 10 seconds

" With buffering and interrupts:
" Write 100 characters to TTY

   lac fo
   sys write; buffer; 50  " Write 50 words (100 chars)
   " System call queues data and returns immediately
   " Interrupt handler sends characters in background
   " Total blocking time: &lt; 1ms (system call overhead)
   " Actual output time: still 10 seconds, but CPU free!</code></pre>
<h3 data-number="2.11.4" id="performance-constraints"><span class="header-section-number">2.11.4</span> Performance Constraints</h3>
<p><strong>Instruction timing matters:</strong></p>
<pre class="assembly"><code>" Example: Zero 100 words
" Method 1: Direct (simple but slow)
   -100
   dac counter
loop1:
   dzm array+0      " 2 cycles each (direct addressing)
   dzm array+1
   dzm array+2
   " ... 100 instructions ...
   dzm array+99
   " Total: 200 cycles = 350 Œºs

" Method 2: Loop (smaller but slower)
   -100
   dac counter
   law array
   dac ptr
loop2:
   dzm ptr i        " 3 cycles (indirect addressing)
   isz ptr          " 2 cycles (increment)
   isz counter      " 2 cycles (count)
   jmp loop2        " 1 cycle (branch)
   " Total: 100 √ó 8 = 800 cycles = 1,400 Œºs (4√ó slower!)

" Method 3: Auto-increment (optimal)
   -100
   dac counter
   law array-1
   dac 8            " Use auto-increment register
loop3:
   dzm 8 i          " 2.5 cycles (auto-increment)
   isz counter      " 2 cycles
   jmp loop3        " 1 cycle
   " Total: 100 √ó 5.5 = 550 cycles = 962 Œºs (2√ó slower than direct)

" Lesson: Unrolled loops are fastest, but waste memory
" Unix uses auto-increment as compromise</code></pre>
<p><strong>Real example from Unix (copy.s):</strong></p>
<pre class="assembly"><code>" Copy memory block (optimized for speed)
copy: 0
   " Called with: jms copy; source; dest; count

   lac copy         " Get return address
   dac 8            " R8 = parameter pointer

   lac 8 i          " Get source address
   dac 9            " R9 = source (auto-increment)

   lac 8 i          " Get dest address
   dac 10           " R10 = dest (auto-increment)

   lac 8 i          " Get count
   cma              " Complement (for negative counting)
   tad d1           " Add 1 (two's complement)
   dac counter      " counter = -count

   lac 8
   dac copy         " Update return address (skip parameters)

loop:
   lac 9 i          " Load from source, increment R9
   dac 10 i         " Store to dest, increment R10
   isz counter      " Increment counter (counts toward 0)
   jmp loop         " Continue until counter = 0

   jmp copy i       " Return

counter: 0

" This routine appears 50+ times in Unix kernel
" Optimization saved ~30% of kernel memory access time!</code></pre>
<h3 data-number="2.11.5" id="design-principles-emerging-from-constraints"><span class="header-section-number">2.11.5</span> Design Principles Emerging
from Constraints</h3>
<p><strong>1. Minimalism</strong></p>
<pre><code>Constraint: 8K words total memory
Result: Every instruction must justify its existence
Example: Kernel is 2,500 lines (incredibly compact)

Modern comparison:
   Linux kernel: 30 million lines
   PDP-7 Unix kernel: 2,500 lines
   Ratio: 12,000√ó larger!

Yet PDP-7 Unix was a complete, self-hosting OS.</code></pre>
<p><strong>2. Simplicity</strong></p>
<pre><code>Constraint: No recursion (non-reentrant subroutines)
Result: Simple, iterative algorithms
Example: Directory traversal uses queue, not recursion

Benefit: Easier to understand, debug, and verify
Drawback: Some algorithms more verbose</code></pre>
<p><strong>3. Efficiency</strong></p>
<pre><code>Constraint: 1.75 Œºs cycle time (slow by modern standards)
Result: Extreme optimization (auto-increment, buffering)
Example: All I/O buffered, minimal system call overhead

Benchmark:
   Unbuffered I/O: 100 system calls/sec max
   Buffered I/O: 10,000 system calls/sec
   100√ó improvement from buffering!</code></pre>
<p><strong>4. Orthogonality</strong></p>
<pre><code>Constraint: Only 16 instructions
Result: Each instruction does ONE thing well
Example:
   LAC: Load ONLY
   DAC: Store ONLY
   TAD: Add ONLY

No complex instructions like:
   "Load, increment, store, and branch if overflow"

Benefit: Simple to learn, compose, and optimize</code></pre>
<p><strong>5. Everything is a file</strong></p>
<pre><code>Constraint: Word-oriented I/O, limited instructions
Result: Unified I/O model for all devices
Example: Same sys read/write for:
   - Regular files
   - Directories
   - Teletype
   - Paper tape
   - DECtape
   - Display

Implementation:
   All devices expose character/block interface
   Kernel translates to device-specific IOT instructions

Benefit: Programs device-independent</code></pre>
<p><strong>6. Pipes and filters (later Unix)</strong></p>
<pre><code>Constraint: Limited memory, slow I/O
Result: Small programs composed via pipes
Example: cat file | grep pattern | sort

This emerged from PDP-11 Unix, but principles from PDP-7:
   - Small, focused tools
   - Character streams
   - Composition over monolithic design</code></pre>
<hr/>
<h2 data-number="2.12" id="conclusion"><span class="header-section-number">2.12</span> Conclusion</h2>
<p>The PDP-7 was a minimal machine‚Äîjust 18-bit words, 16 instructions,
8K words of memory, and primitive I/O. Yet from these constraints
emerged Unix: elegant, powerful, and enduring.</p>
<p>Understanding the PDP-7 hardware reveals <em>why</em> Unix became
what it is:</p>
<ul>
<li><strong>Minimalism</strong>: Limited memory forced economy of
expression</li>
<li><strong>Simplicity</strong>: Small instruction set demanded clever
composition</li>
<li><strong>Orthogonality</strong>: Each operation does one thing
perfectly</li>
<li><strong>Buffering</strong>: Slow I/O necessitated efficient
caching</li>
<li><strong>Files everywhere</strong>: Word-oriented I/O unified device
access</li>
<li><strong>Iterative design</strong>: Non-reentrant subroutines
prevented recursion</li>
</ul>
<p>These weren‚Äôt abstract design principles‚Äîthey were <strong>necessary
adaptations</strong> to hardware constraints. Thompson and Ritchie
didn‚Äôt choose minimalism; the PDP-7 <em>forced</em> it. And in that
forcing, they discovered principles that would shape computing for the
next 50 years.</p>
<p>In the next chapter, we‚Äôll explore PDP-7 assembly language
programming in depth, building on the architectural foundation
established here. We‚Äôll write complete programs, examine real Unix
source code, and learn to think like a PDP-7 programmer.</p>
<p>The hardware constraints that limited the PDP-7 became the
philosophical constraints that liberated Unix.</p>
<hr/>
<p><strong>Next: <a href="03-assembly.md">Chapter 3 - Assembly Language
Programming</a></strong></p>
<p><strong>References:</strong> - DEC PDP-7 Handbook (1965) - Unix
Programmer‚Äôs Manual, First Edition (1971) - Dennis M. Ritchie, ‚ÄúThe
Evolution of the Unix Time-sharing System‚Äù (1984) - PDP-7 Unix source
code (reconstructed 2019)</p>
<h1 data-number="3" id="chapter-3-assembly-language-and-programming"><span class="header-section-number">3</span> Chapter 3: Assembly Language and
Programming</h1>
<h2 data-number="3.1" id="introduction-1"><span class="header-section-number">3.1</span> Introduction</h2>
<p>Assembly language is the bridge between human thought and machine
execution‚Äîa symbolic representation of the binary instructions that the
CPU actually executes. For PDP-7 Unix, assembly wasn‚Äôt just a tool; it
was the <em>only</em> tool. Every line of the operating system, every
utility, every tool was hand-crafted in PDP-7 assembly language.</p>
<p>This chapter will teach you PDP-7 assembly language programming from
first principles. By the end, you‚Äôll be able to read and write PDP-7
assembly code, understand the Unix source code in detail, and appreciate
the elegant solutions that Thompson and Ritchie created under severe
constraints.</p>
<h3 data-number="3.1.1" id="why-assembly-for-unix"><span class="header-section-number">3.1.1</span> Why Assembly for Unix?</h3>
<p>In 1969, there were compelling reasons to write an operating system
in assembly language:</p>
<p><strong>Performance Requirements:</strong> - <strong>Direct hardware
control</strong> - Operating systems need access to CPU registers,
memory management hardware, and I/O devices - <strong>No
overhead</strong> - High-level languages added layers of abstraction
that consumed precious memory and CPU cycles - <strong>Predictable
timing</strong> - Interrupt handlers and device drivers required precise
control over execution timing</p>
<p><strong>Resource Constraints:</strong> - <strong>8K words of
memory</strong> (16 KB total) - No room for a compiler, runtime library,
or generated code overhead - <strong>Limited development tools</strong>
- C didn‚Äôt exist yet; BCPL was available but too large for the PDP-7 -
<strong>Self-hosting requirement</strong> - The system had to be able to
assemble itself, which meant the assembler itself had to fit in
memory</p>
<p><strong>Cultural Context:</strong> - <strong>Standard
practice</strong> - In 1969, all operating systems were written in
assembly - <strong>Expertise available</strong> - Thompson and Ritchie
were expert assembly programmers - <strong>Tools existed</strong> -
Assemblers were simple, well-understood tools</p>
<p>The Unix assembler (<code>as.s</code>) is itself a marvel of compact
design‚Äîa complete two-pass assembler in approximately 800 lines of
assembly code.</p>
<h3 data-number="3.1.2" id="the-relationship-to-machine-code"><span class="header-section-number">3.1.2</span> The Relationship to Machine
Code</h3>
<p>Assembly language and machine code are nearly identical‚Äîassembly is
just the human-readable form:</p>
<pre><code>Assembly         Machine Code      Meaning
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
lac 100          020100           Load AC from location 100
dac result       040567           Store AC to location named 'result'
tad d1           140023           Add contents of 'd1' to AC
jmp loop         120045           Jump to address labeled 'loop'</code></pre>
<p>The assembler‚Äôs job is simple: convert symbolic names to numeric
addresses and translate mnemonics to opcodes.</p>
<p><strong>Without assembly (pure machine code):</strong></p>
<pre><code>020100    " What does this mean? You have to know!
140023    " What's at location 023? A constant? A variable?
040567    " Where is 567? What's stored there?
120045    " Is this a jump? To where?</code></pre>
<p><strong>With assembly (symbolic):</strong></p>
<pre class="assembly"><code>   lac count      " Load the counter - clear intent
   tad d1         " Add 1 to it - obvious purpose
   dac count      " Store it back - straightforward
   jmp loop       " Jump to loop - explicit destination</code></pre>
<p>Assembly provides: 1. <strong>Symbolic labels</strong> instead of
numeric addresses 2. <strong>Mnemonic opcodes</strong> instead of binary
codes 3. <strong>Comments</strong> for documentation 4.
<strong>Expressions</strong> for calculations (e.g.,
<code>buffer+64</code>) 5. <strong>Pseudo-operations</strong> for data
definition and assembly control</p>
<h3 data-number="3.1.3" id="the-unix-assembler-capabilities"><span class="header-section-number">3.1.3</span> The Unix Assembler
Capabilities</h3>
<p>The PDP-7 Unix assembler (<code>as.s</code>) supports:</p>
<p><strong>Basic Features:</strong> - <strong>Two-pass assembly</strong>
- First pass builds symbol table, second pass generates code -
<strong>Local and global labels</strong> - Numeric labels (1:, 2:) for
local scope, alphanumeric for global - <strong>Forward
references</strong> - Can jump to labels defined later in the source -
<strong>Expression evaluation</strong> - Arithmetic on symbols and
constants - <strong>Multiple files</strong> - Can assemble and link
separate source files</p>
<p><strong>Directives:</strong> - <code>.=.+n</code> - Reserve space
(increment location counter by n) - <code>.=addr</code> - Set location
counter to absolute address - <code>name = value</code> - Define
symbolic constant - <code>i</code> suffix - Indirect addressing (e.g.,
<code>lac 100 i</code>)</p>
<p><strong>Advanced Features:</strong> - <strong>System call
macro</strong> - <code>sys</code> generates proper system call sequence
- <strong>String packing</strong> - Assembler packs two 9-bit characters
per word - <strong>Octal constants</strong> - Native format for 18-bit
words - <strong>Symbol table output</strong> - For debugging (used by
<code>db.s</code>)</p>
<h3 data-number="3.1.4" id="what-youll-learn-1"><span class="header-section-number">3.1.4</span> What You‚Äôll Learn</h3>
<p>This chapter progresses through:</p>
<ol type="1">
<li><strong>Fundamentals</strong> - Number systems, instruction formats,
basic operations</li>
<li><strong>Core Programming</strong> - Data manipulation, control flow,
subroutines</li>
<li><strong>Advanced Techniques</strong> - Multi-precision arithmetic,
bit manipulation, optimization</li>
<li><strong>System Integration</strong> - System calls, calling
conventions, library usage</li>
<li><strong>Complete Programs</strong> - Full working examples you can
study and modify</li>
</ol>
<p>Each section builds on the previous, with extensive code examples
drawn from actual Unix sources and original tutorial programs.</p>
<p>Let‚Äôs begin.</p>
<hr/>
<h2 data-number="3.2" id="number-systems-and-notation"><span class="header-section-number">3.2</span> 1. Number Systems and
Notation</h2>
<p>Before writing assembly code, you must become fluent in
<strong>octal</strong> (base-8) notation. While decimal is natural for
humans and hexadecimal is common today, octal was the lingua franca of
PDP-7 programming.</p>
<h3 data-number="3.2.1" id="why-octal-for-18-bit-words"><span class="header-section-number">3.2.1</span> Why Octal for 18-Bit
Words?</h3>
<p>The PDP-7‚Äôs 18-bit word size made octal the natural choice:</p>
<pre><code>Binary (18 bits):    001 010 011 100 101 110
                     ‚îî‚îÄ‚îò ‚îî‚îÄ‚îò ‚îî‚îÄ‚îò ‚îî‚îÄ‚îò ‚îî‚îÄ‚îò ‚îî‚îÄ‚îò
Octal (6 digits):     1   2   3   4   5   6

18 bits = exactly 6 octal digits (000000 to 777777)</code></pre>
<p><strong>Compare the alternatives:</strong></p>
<pre><code>Decimal: 18 bits = 0 to 262,143 (6 digits, awkward)
         No clean relationship between bits and digits
         Hard to see bit patterns

Octal:   18 bits = 000000 to 777777 (6 digits, perfect)
         Each digit represents exactly 3 bits
         Bit patterns immediately visible

Hex:     18 bits = 0x00000 to 0x3FFFF (5 digits, odd)
         Last digit only uses 2 bits (0-3)
         Awkward for 18-bit word boundaries</code></pre>
<p><strong>Examples showing octal‚Äôs advantage:</strong></p>
<pre class="assembly"><code>" Setting specific bits is intuitive in octal:
   lac 0177        " Binary: 000 000 001 111 111
                   "           0   0   1   7   7
                   " Sets bits 0-6 (useful for masking 7-bit ASCII)

   lac 0600000     " Binary: 110 000 000 000 000
                   "           6   0   0   0   0
                   " Sets bits 17-16 (high-order flags)

   lac 0707070     " Binary: 111 000 111 000 111 000
                   "           7   0   7   0   7   0
                   " Every other 3-bit group set</code></pre>
<h3 data-number="3.2.2" id="octal-digit-values"><span class="header-section-number">3.2.2</span> Octal Digit Values</h3>
<p>Each octal digit represents a 3-bit binary value:</p>
<table>
<thead>
<tr>
<th>Octal</th>
<th>Binary</th>
<th>Decimal</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>000</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>001</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>010</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>011</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>100</td>
<td>4</td>
</tr>
<tr>
<td>5</td>
<td>101</td>
<td>5</td>
</tr>
<tr>
<td>6</td>
<td>110</td>
<td>6</td>
</tr>
<tr>
<td>7</td>
<td>111</td>
<td>7</td>
</tr>
</tbody>
</table>
<p><strong>Reading 18-bit octal numbers:</strong></p>
<pre><code>Octal:    123456
Digits:   1  2  3  4  5  6
Bits:    17 14 11  8  5  2
         ‚Üì  ‚Üì  ‚Üì  ‚Üì  ‚Üì  ‚Üì
Binary:  001 010 011 100 101 110
Bit #:   ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ
         17‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ0

Decimal: 1√ó8^5 + 2√ó8^4 + 3√ó8^3 + 4√ó8^2 + 5√ó8^1 + 6√ó8^0
       = 1√ó32768 + 2√ó4096 + 3√ó512 + 4√ó64 + 5√ó8 + 6√ó1
       = 32768 + 8192 + 1536 + 256 + 40 + 6
       = 42798 (decimal)</code></pre>
<h3 data-number="3.2.3" id="converting-between-number-systems"><span class="header-section-number">3.2.3</span> Converting Between Number
Systems</h3>
<h4 data-number="3.2.3.1" id="octal-to-decimal"><span class="header-section-number">3.2.3.1</span> Octal to Decimal</h4>
<p>Multiply each digit by its positional value (powers of 8):</p>
<pre><code>Example: 01234 (octal) to decimal

01234‚Çà = 1√ó8¬≥ + 2√ó8¬≤ + 3√ó8¬π + 4√ó8‚Å∞
       = 1√ó512 + 2√ó64 + 3√ó8 + 4√ó1
       = 512 + 128 + 24 + 4
       = 668‚ÇÅ‚ÇÄ</code></pre>
<h4 data-number="3.2.3.2" id="decimal-to-octal"><span class="header-section-number">3.2.3.2</span> Decimal to Octal</h4>
<p>Repeatedly divide by 8, collecting remainders:</p>
<pre><code>Example: 1000 (decimal) to octal

1000 √∑ 8 = 125 remainder 0    ‚îÄ‚îê
 125 √∑ 8 =  15 remainder 5     ‚îÇ
  15 √∑ 8 =   1 remainder 7     ‚îÇ Read upward
   1 √∑ 8 =   0 remainder 1    ‚îÄ‚îò

Result: 1750‚Çà

Verify: 1√ó512 + 7√ó64 + 5√ó8 + 0√ó1 = 512 + 448 + 40 = 1000 ‚úì</code></pre>
<h4 data-number="3.2.3.3" id="octal-to-binary"><span class="header-section-number">3.2.3.3</span> Octal to Binary</h4>
<p>Each octal digit converts directly to 3 bits:</p>
<pre><code>Example: 07654 (octal) to binary

0 7 6 5 4
‚Üì ‚Üì ‚Üì ‚Üì ‚Üì
000 111 110 101 100

Result: 000 111 110 101 100 (binary)
Grouped: 000111110101100 (binary)</code></pre>
<h4 data-number="3.2.3.4" id="binary-to-octal"><span class="header-section-number">3.2.3.4</span> Binary to Octal</h4>
<p>Group binary digits by threes, starting from the right:</p>
<pre><code>Example: 1101110101 (binary) to octal

  1 101 110 101
  ‚Üì  ‚Üì   ‚Üì   ‚Üì
  1  5   6   5

Result: 1565‚Çà</code></pre>
<h3 data-number="3.2.4" id="common-octal-values-in-unix"><span class="header-section-number">3.2.4</span> Common Octal Values in
Unix</h3>
<p>Memorizing these common values will speed your reading of Unix source
code:</p>
<p><strong>Powers of 2:</strong></p>
<pre><code>Decimal    Octal      Binary (18-bit)        Usage
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1          000001     000 000 000 000 001    Bit 0
2          000002     000 000 000 000 010    Bit 1
4          000004     000 000 000 000 100    Bit 2
8          000010     000 000 000 001 000    Bit 3
16         000020     000 000 000 010 000    Bit 4
32         000040     000 000 000 100 000    Bit 5
64         000100     000 000 001 000 000    Bit 6
128        000200     000 000 010 000 000    Bit 7
256        000400     000 000 100 000 000    Bit 8
512        001000     000 001 000 000 000    Bit 9
1024       002000     000 010 000 000 000    Bit 10
2048       004000     000 100 000 000 000    Bit 11
4096       010000     001 000 000 000 000    Bit 12
8192       020000     010 000 000 000 000    Bit 13</code></pre>
<p><strong>Character values (7-bit ASCII):</strong></p>
<pre><code>Decimal    Octal      Character
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
0          000        NUL (null)
8          010        BS (backspace)
9          011        HT (tab)
10         012        LF (line feed / newline)
13         015        CR (carriage return)
32         040        SP (space)
48         060        '0'
57         071        '9'
65         0101       'A'
90         0132       'Z'
97         0141       'a'
122        0172       'z'
127        0177       DEL (delete)</code></pre>
<p><strong>Memory addresses:</strong></p>
<pre><code>Octal      Decimal    Usage in Unix
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
000000     0          Low memory start
000010     8          Auto-increment register 0
000017     15         Auto-increment register 7
000020     16         System call trap vector
007777     4095       End of 4K page
010000     4096       Start of second 4K page
017700     8176       Disk buffer (dskbuf)
017777     8191       Highest address in 8K memory</code></pre>
<p><strong>Bit masks:</strong></p>
<pre><code>Octal      Binary (18-bit)         Usage
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
000001     000 000 000 000 001     Bit 0 only
000177     000 000 001 111 111     Bits 0-6 (7-bit ASCII)
000377     000 000 011 111 111     Bits 0-7 (8-bit byte)
001777     000 001 111 111 111     Bits 0-9 (10 bits)
007777     000 111 111 111 111     Bits 0-11 (12 bits)
017777     001 111 111 111 111     Bits 0-13 (13 bits)
037777     011 111 111 111 111     Bits 0-14 (14 bits)
077777     111 111 111 111 111     Bits 0-15 (15 bits)
177777     All bits except 17      Sign bit mask (negative)
777777     111 111 111 111 111     All bits (also -1 in two's complement)</code></pre>
<h3 data-number="3.2.5" id="practice-exercises"><span class="header-section-number">3.2.5</span> Practice Exercises</h3>
<p>Test your understanding with these conversions:</p>
<p><strong>Exercise 1:</strong> Convert octal to decimal</p>
<pre><code>a) 0100 octal = ?        (Answer: 64)
b) 0777 octal = ?        (Answer: 511)
c) 010000 octal = ?      (Answer: 4096)
d) 077777 octal = ?      (Answer: 32767)</code></pre>
<p><strong>Exercise 2:</strong> Convert decimal to octal</p>
<pre><code>a) 100 decimal = ?       (Answer: 0144)
b) 256 decimal = ?       (Answer: 0400)
c) 1000 decimal = ?      (Answer: 01750)
d) 8191 decimal = ?      (Answer: 017777)</code></pre>
<p><strong>Exercise 3:</strong> Identify what these octal numbers
represent</p>
<pre><code>a) 000177               (Answer: 7-bit ASCII mask, decimal 127)
b) 000012               (Answer: Line feed character '\n', decimal 10)
c) 017700               (Answer: Disk buffer address, decimal 8176)
d) 777777               (Answer: -1 in two's complement, all bits set)</code></pre>
<h3 data-number="3.2.6" id="twos-complement-negative-numbers"><span class="header-section-number">3.2.6</span> Two‚Äôs Complement Negative
Numbers</h3>
<p>The PDP-7 uses <strong>two‚Äôs complement</strong> representation for
negative numbers:</p>
<pre><code>Positive numbers:    0 (000000) to +131071 (377777)
Bit 17 = 0          Sign bit clear

Negative numbers:    -1 (777777) to -131072 (400000)
Bit 17 = 1          Sign bit set</code></pre>
<p><strong>Converting positive to negative:</strong></p>
<p>Method 1: Invert all bits and add 1</p>
<pre><code>+5 in binary:    000 000 000 000 101 (000005 octal)
Invert bits:     111 111 111 111 010
Add 1:           111 111 111 111 011 (777773 octal) = -5</code></pre>
<p>Method 2: Subtract from 2^18</p>
<pre><code>-5 = 2^18 - 5 = 262144 - 5 = 262139 = 777773 octal</code></pre>
<p><strong>Common negative values:</strong></p>
<pre><code>Decimal    Octal      Binary (18-bit)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
-1         777777     111 111 111 111 111
-2         777776     111 111 111 111 110
-4         777774     111 111 111 111 100
-8         777770     111 111 111 111 000
-16        777760     111 111 111 110 000
-64        777700     111 111 111 000 000
-128       777600     111 111 110 000 000
-256       777400     111 111 100 000 000
-512       777000     111 111 000 000 000
-1024      776000     111 110 000 000 000</code></pre>
<p><strong>Using negative constants for countdown loops:</strong></p>
<pre class="assembly"><code>" Loop 10 times using negative counter
   -10                " Load AC with -10 (777766 octal)
   dac count          " Initialize counter

loop:
   " ... body of loop ...

   isz count          " Increment: -10 ‚Üí -9 ‚Üí ... ‚Üí -1 ‚Üí 0
                      " When reaches 0, skip next instruction
   jmp loop           " Jump back (skipped when count = 0)

   " ... continue after loop ...

count: 0</code></pre>
<p>This technique is ubiquitous in Unix source code because it‚Äôs more
efficient than comparing to a positive limit.</p>
<hr/>
<h2 data-number="3.3" id="basic-instruction-tutorial"><span class="header-section-number">3.3</span> 2. Basic Instruction
Tutorial</h2>
<p>Let‚Äôs learn PDP-7 assembly by writing actual code, starting with the
simplest operations and building to complete programs.</p>
<h3 data-number="3.3.1" id="your-first-instruction-lac-load-ac"><span class="header-section-number">3.3.1</span> Your First Instruction: LAC
(Load AC)</h3>
<p>The most fundamental operation is loading a value into the
Accumulator (AC):</p>
<pre class="assembly"><code>" Load a constant
   lac d1            " Load AC with contents of location 'd1'
                     " If d1 contains the value 1, AC becomes 1

" The constant definition
d1: 1                " Location labeled 'd1' contains value 1</code></pre>
<p><strong>Execution trace:</strong></p>
<pre><code>Before:  AC = ??????? (unknown)
         Memory[d1] = 1

Execute: lac d1

After:   AC = 1
         Memory[d1] = 1 (unchanged)</code></pre>
<p><strong>Common usage pattern:</strong></p>
<pre class="assembly"><code>" Constants defined at end of program
d0: 0
d1: 1
d2: 2
d8: 8
dm1: -1              " Negative one (777777 octal)

" Used throughout the code
   lac d1            " Load 1
   lac d8            " Load 8
   lac dm1           " Load -1</code></pre>
<p>This pattern appears throughout Unix because literal constants aren‚Äôt
directly supported‚Äîyou must load from memory.</p>
<h3 data-number="3.3.2" id="dac-deposit-ac---storing-values"><span class="header-section-number">3.3.2</span> DAC (Deposit AC) - Storing
Values</h3>
<p>Once you have a value in AC, you store it with DAC:</p>
<pre class="assembly"><code>" Store AC to a variable
   lac d1            " Load 1 into AC
   dac count         " Store AC (value 1) to location 'count'

" Memory allocation
count: 0             " Reserve one word, initialize to 0</code></pre>
<p><strong>Execution trace:</strong></p>
<pre><code>Before:  AC = 1
         Memory[count] = 0

Execute: dac count

After:   AC = 1 (unchanged)
         Memory[count] = 1</code></pre>
<h3 data-number="3.3.3" id="tad-twos-complement-add---addition"><span class="header-section-number">3.3.3</span> TAD (Two‚Äôs Complement Add) -
Addition</h3>
<p>Add a value to AC:</p>
<pre class="assembly"><code>" Add 1 to AC
   lac count         " Load current count (assume it's 5)
   tad d1            " Add 1 to AC
   dac count         " Store result back (now 6)

" Constants
count: 5
d1: 1</code></pre>
<p><strong>Execution trace:</strong></p>
<pre><code>Before:  AC = 5
         Memory[d1] = 1

Execute: tad d1

After:   AC = 6 (5 + 1)
         Link = 0 (no carry)</code></pre>
<p><strong>Addition with carry:</strong></p>
<pre class="assembly"><code>" Adding two large numbers that produce carry
   lac value1        " Load 0400000 (131072 decimal)
   tad value2        " Add 0400000 (131072 decimal)
                     " Result = 262144, but max positive = 131071
                     " So: AC = 0 (overflow), Link = 1 (carry)

value1: 0400000
value2: 0400000</code></pre>
<h3 data-number="3.3.4" id="a-complete-example-increment-a-variable"><span class="header-section-number">3.3.4</span> A Complete Example: Increment
a Variable</h3>
<pre class="assembly"><code>" Program: Increment a counter
" Loads count, adds 1, stores result

start:
   lac count         " Load current value of count
   tad d1            " Add 1
   dac count         " Store new value
   hlt               " Halt (stop execution)

" Data area
count: 0             " Counter variable (starts at 0)
d1: 1                " Constant 1

" Result: count becomes 1</code></pre>
<p><strong>Step-by-step execution:</strong></p>
<pre><code>1. lac count    : AC ‚Üê 0         (load initial value)
2. tad d1       : AC ‚Üê 0 + 1 = 1 (add one)
3. dac count    : count ‚Üê 1      (store result)
4. hlt          : Stop</code></pre>
<h3 data-number="3.3.5" id="subtraction-using-twos-complement"><span class="header-section-number">3.3.5</span> Subtraction Using Two‚Äôs
Complement</h3>
<p>There‚Äôs no subtract instruction‚Äîuse negative constants:</p>
<pre class="assembly"><code>" Decrement a counter
   lac count         " Load count (assume 10)
   tad dm1           " Add -1 (same as subtract 1)
   dac count         " Store result (now 9)

count: 10
dm1: -1              " 777777 octal</code></pre>
<p><strong>Why this works:</strong></p>
<pre><code>10 + (-1) = 9

In binary (simplified to show concept):
  00001010  (10)
+ 11111111  (-1 in two's complement)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  00001001  (9)</code></pre>
<h3 data-number="3.3.6" id="simple-arithmetic-examples"><span class="header-section-number">3.3.6</span> Simple Arithmetic
Examples</h3>
<p><strong>Example 1: Add two numbers</strong></p>
<pre class="assembly"><code>" Compute: result = a + b

   lac a             " Load first number
   tad b             " Add second number
   dac result        " Store sum

a: 42                " First number
b: 17                " Second number
result: 0            " Will contain 59</code></pre>
<p><strong>Example 2: Compute expression (a + b) - c</strong></p>
<pre class="assembly"><code>" result = (a + b) - c

   lac a             " Load a
   tad b             " Add b (AC = a + b)
   tad neg_c         " Add -c (AC = a + b - c)
   dac result        " Store result

a: 100
b: 50
neg_c: -30           " Negative c
result: 0            " Will contain 120</code></pre>
<p><strong>Example 3: Add three numbers</strong></p>
<pre class="assembly"><code>" sum = a + b + c

   lac a             " Load a
   tad b             " Add b
   tad c             " Add c
   dac sum           " Store sum

a: 10
b: 20
c: 30
sum: 0               " Will contain 60</code></pre>
<h3 data-number="3.3.7" id="cla-clear-ac---starting-fresh"><span class="header-section-number">3.3.7</span> CLA (Clear AC) - Starting
Fresh</h3>
<p>Often you need to zero the AC:</p>
<pre class="assembly"><code>" Clear AC to zero
   cla               " AC ‚Üê 0

" Common pattern: clear and add
   cla               " Start with 0
   tad value1        " AC = 0 + value1 = value1
   tad value2        " AC = value1 + value2
   dac sum           " Store sum</code></pre>
<p>This is more efficient than loading zero from memory.</p>
<h3 data-number="3.3.8" id="las-load-ac-with-switches---reading-input"><span class="header-section-number">3.3.8</span> LAS (Load AC with Switches) -
Reading Input</h3>
<p>On the PDP-7, the front panel had 18 toggle switches:</p>
<pre class="assembly"><code>" Read switch register into AC
   las               " AC ‚Üê switch register value

" Typical use: manual program input
start:
   las               " Read number from switches
   dac number        " Store it
   hlt               " Halt for next input

number: 0</code></pre>
<p>Operators could manually enter numbers by setting switches and
running the program.</p>
<h3 data-number="3.3.9" id="practice-programs"><span class="header-section-number">3.3.9</span> Practice Programs</h3>
<p><strong>Program 1: Simple calculator</strong></p>
<pre class="assembly"><code>" Add two numbers from switches

   las               " Read first number from switches
   dac operand1      " Store it
   hlt               " Halt (operator sets second number)

   las               " Read second number
   dac operand2      " Store it

   lac operand1      " Load first number
   tad operand2      " Add second number
   dac result        " Store sum
   hlt               " Halt (result available)

operand1: 0
operand2: 0
result: 0</code></pre>
<p><strong>Program 2: Accumulate sum</strong></p>
<pre class="assembly"><code>" Add numbers until total reaches 100

start:
   cla               " Start with sum = 0
   dac sum           " Initialize sum

loop:
   lac sum           " Load current sum
   tad increment     " Add 5
   dac sum           " Store new sum

   lac limit         " Load limit (100)
   tad neg_sum       " Subtract sum (limit - sum)
   sma               " Skip if minus (sum &gt; limit)
   jmp loop          " Continue if sum &lt;= limit

   hlt               " Done

sum: 0
increment: 5
limit: 100
neg_sum: 0           " Updated each iteration</code></pre>
<p>(We‚Äôll learn SMA and JMP in the Control Flow section)</p>
<hr/>
<h2 data-number="3.4" id="addressing-modes-in-practice"><span class="header-section-number">3.4</span> 3. Addressing Modes in
Practice</h2>
<p>The PDP-7 supports several addressing modes that dramatically affect
how you write code. Understanding these modes is crucial for reading
Unix source code.</p>
<h3 data-number="3.4.1" id="direct-addressing-default-mode"><span class="header-section-number">3.4.1</span> Direct Addressing (Default
Mode)</h3>
<p><strong>Direct addressing</strong> means the instruction contains the
actual memory address:</p>
<pre class="assembly"><code>   lac 1000          " Load AC from address 1000 (octal)
                     " AC ‚Üê Memory[1000]</code></pre>
<p><strong>Visual representation:</strong></p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Instruction  ‚îÇ  lac 1000
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚Üì
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
Address  ‚îÇ  1000   ‚îÇ  Value: 42
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚Üì
           AC = 42</code></pre>
<p><strong>Usage in code:</strong></p>
<pre class="assembly"><code>" Direct addressing with labels
   lac counter       " Load from address of 'counter'
   dac result        " Store to address of 'result'

counter: 5
result: 0</code></pre>
<p>The assembler resolves labels to addresses, so
<code>lac counter</code> becomes <code>lac 0234</code> if counter is at
address 0234.</p>
<h3 data-number="3.4.2" id="indirect-addressing-i-suffix"><span class="header-section-number">3.4.2</span> Indirect Addressing (i
Suffix)</h3>
<p><strong>Indirect addressing</strong> means the instruction points to
a location containing the <em>address</em> of the data:</p>
<pre class="assembly"><code>   lac 1000 i        " Load AC from Memory[Memory[1000]]
                     " AC ‚Üê Memory[Memory[1000]]</code></pre>
<p><strong>Visual representation:</strong></p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Instruction  ‚îÇ  lac 1000 i
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚Üì
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
Address  ‚îÇ  1000   ‚îÇ  Value: 2500  ‚Üê Points to another address
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                     ‚Üì
                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
Address         ‚îÇ  2500   ‚îÇ  Value: 42  ‚Üê Actual data
                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚Üì
                  AC = 42</code></pre>
<p><strong>Why indirect addressing?</strong></p>
<ol type="1">
<li><strong>Pointers</strong> - Access data through a pointer
variable</li>
<li><strong>Dynamic addressing</strong> - Address computed at
runtime</li>
<li><strong>Arrays</strong> - Traverse data structures</li>
<li><strong>Function parameters</strong> - Pass addresses as
arguments</li>
</ol>
<p><strong>Example: Using a pointer</strong></p>
<pre class="assembly"><code>" Direct vs. Indirect

" Direct: Access 'value' directly
   lac value         " AC ‚Üê Memory[value] = 42

" Indirect: Access 'value' through 'ptr'
   lac ptr i         " AC ‚Üê Memory[Memory[ptr]]
                     " Memory[ptr] = address of 'value'
                     " Memory[value] = 42
                     " So: AC ‚Üê 42

value: 42
ptr: value           " ptr contains address of value</code></pre>
<p><strong>Example: Changing what pointer points to</strong></p>
<pre class="assembly"><code>" Setup
   law value1        " Load address of value1
   dac ptr           " ptr now points to value1

   lac ptr i         " AC ‚Üê Memory[Memory[ptr]] = 10

   law value2        " Load address of value2
   dac ptr           " ptr now points to value2

   lac ptr i         " AC ‚Üê Memory[Memory[ptr]] = 20

value1: 10
value2: 20
ptr: 0</code></pre>
<h3 data-number="3.4.3" id="law-load-address-word---loading-addresses"><span class="header-section-number">3.4.3</span> LAW (Load Address Word) -
Loading Addresses</h3>
<p>To work with pointers, you need to load addresses:</p>
<pre class="assembly"><code>" LAW loads an address into AC
   law array         " AC ‚Üê address of 'array'
                     " NOT the contents of array!

" Now use it as a pointer
   dac ptr           " ptr ‚Üê address of array
   lac ptr i         " AC ‚Üê array[0] (first element)

array: 1; 2; 3; 4; 5
ptr: 0</code></pre>
<p><strong>LAW vs LAC:</strong></p>
<pre class="assembly"><code>   law value         " AC ‚Üê address of value (e.g., 1000)
   lac value         " AC ‚Üê contents of value (e.g., 42)

value: 42            " Stored at address 1000 (example)</code></pre>
<h3 data-number="3.4.4" id="auto-increment-addressing-locations-8-15"><span class="header-section-number">3.4.4</span> Auto-Increment Addressing
(Locations 8-15)</h3>
<p><strong>The most powerful feature</strong> of the PDP-7: locations
010-017 (octal) automatically increment when used indirectly.</p>
<p><strong>Memory locations 8-15 (decimal) = 010-017
(octal):</strong></p>
<pre class="assembly"><code>" Setup: Use location 8 as auto-increment pointer
   law array-1       " Load address one before array
   dac 8             " Store in location 8 (010 octal)

" Now each access increments the pointer
   lac 8 i           " 1st access: AC ‚Üê array[0], then 8 ‚Üê 8+1
   lac 8 i           " 2nd access: AC ‚Üê array[1], then 8 ‚Üê 8+1
   lac 8 i           " 3rd access: AC ‚Üê array[2], then 8 ‚Üê 8+1

array: 10; 20; 30; 40; 50</code></pre>
<p><strong>Step-by-step execution:</strong></p>
<pre><code>Initial state:
   Location 8 = address of array-1 = 999 (example)
   Memory[1000] = 10
   Memory[1001] = 20
   Memory[1002] = 30

Instruction: lac 8 i

Step 1: Read Memory[8] = 999
Step 2: Increment Memory[8] ‚Üê 1000 (auto-increment!)
Step 3: Load AC ‚Üê Memory[999+1] = Memory[1000] = 10

Next instruction: lac 8 i

Step 1: Read Memory[8] = 1000
Step 2: Increment Memory[8] ‚Üê 1001
Step 3: Load AC ‚Üê Memory[1001] = 20

And so on...</code></pre>
<p><strong>Why start at array-1?</strong></p>
<p>The auto-increment happens <em>before</em> the access, so we start
one before to hit the first element:</p>
<pre class="assembly"><code>" Method 1: Start one before (standard Unix practice)
   law array-1       " Point to array-1
   dac 8
   lac 8 i           " Increments to array, reads array[0]

" Method 2: Start at first element (alternative)
   law array         " Point to array[0]
   dac 8
   lac 8 i           " Reads array[0], increments to array[1]
   lac 8 i           " Reads array[1], increments to array[2]</code></pre>
<p>Both work; Unix code consistently uses Method 1.</p>
<h3 data-number="3.4.5" id="array-processing-with-auto-increment"><span class="header-section-number">3.4.5</span> Array Processing with
Auto-Increment</h3>
<p><strong>Example: Sum an array</strong></p>
<pre class="assembly"><code>" Sum 5 numbers in an array

   cla               " sum = 0
   dac sum

   law array-1       " Setup pointer
   dac 8

   -5                " Loop counter (count down from -5)
   dac count

loop:
   lac sum           " Load current sum
   tad 8 i           " Add next array element (auto-increments!)
   dac sum           " Store new sum

   isz count         " Increment count: -5 ‚Üí -4 ‚Üí ... ‚Üí 0
   jmp loop          " Continue while count &lt; 0

   hlt               " Done, sum contains result

array: 10; 20; 30; 40; 50
sum: 0
count: 0

" Result: sum = 150</code></pre>
<p><strong>Execution trace:</strong></p>
<pre><code>Loop iteration 1:
   sum = 0
   8 i reads array[0]=10, increments pointer
   sum = 10
   count: -5 ‚Üí -4

Loop iteration 2:
   sum = 10
   8 i reads array[1]=20, increments pointer
   sum = 30
   count: -4 ‚Üí -3

Loop iteration 3:
   sum = 30
   8 i reads array[2]=30, increments pointer
   sum = 60
   count: -3 ‚Üí -2

Loop iteration 4:
   sum = 60
   8 i reads array[3]=40, increments pointer
   sum = 100
   count: -2 ‚Üí -1

Loop iteration 5:
   sum = 100
   8 i reads array[4]=50, increments pointer
   sum = 150
   count: -1 ‚Üí 0 (triggers skip)

Loop exits</code></pre>
<h3 data-number="3.4.6" id="two-pointers-array-copy"><span class="header-section-number">3.4.6</span> Two Pointers: Array Copy</h3>
<p>Use multiple auto-increment registers for complex operations:</p>
<pre class="assembly"><code>" Copy source array to destination array

   law source-1      " Source pointer
   dac 8

   law dest-1        " Destination pointer
   dac 9

   -10               " Copy 10 elements
   dac count

loop:
   lac 8 i           " Read from source (auto-increment)
   dac 9 i           " Write to dest (auto-increment)

   isz count         " Decrement counter
   jmp loop          " Continue

   hlt               " Done

source: 1; 2; 3; 4; 5; 6; 7; 8; 9; 10
dest: .=.+10         " Reserve 10 words
count: 0</code></pre>
<p><strong>Why this is elegant:</strong></p>
<p>Without auto-increment, you‚Äôd need:</p>
<pre class="assembly"><code>" Manual pointer increment (inefficient)
loop:
   lac src_ptr       " Load source address (1 instruction)
   dac temp          " Store to temp (1 instruction)
   lac temp i        " Load value (1 instruction)
   dac value         " Save value (1 instruction)

   lac dst_ptr       " Load dest address (1 instruction)
   dac temp          " Store to temp (1 instruction)
   lac value         " Load value (1 instruction)
   dac temp i        " Store value (1 instruction)

   lac src_ptr       " Increment source (1 instruction)
   tad d1
   dac src_ptr       " (3 instructions)

   lac dst_ptr       " Increment dest (1 instruction)
   tad d1
   dac dst_ptr       " (3 instructions)

   " Total: 16 instructions per iteration!</code></pre>
<p>With auto-increment:</p>
<pre class="assembly"><code>loop:
   lac 8 i           " Read and increment (1 instruction)
   dac 9 i           " Write and increment (1 instruction)

   " Total: 2 instructions per iteration</code></pre>
<p><strong>8√ó more efficient!</strong></p>
<h3 data-number="3.4.7" id="when-to-use-each-mode"><span class="header-section-number">3.4.7</span> When to Use Each Mode</h3>
<p><strong>Direct addressing:</strong> - Accessing global variables -
Reading constants - Simple variable access</p>
<pre class="assembly"><code>   lac counter
   tad increment
   dac counter</code></pre>
<p><strong>Indirect addressing:</strong> - Following pointers -
Accessing through computed addresses - Function parameters</p>
<pre class="assembly"><code>   lac file_ptr i    " Access file through pointer</code></pre>
<p><strong>Auto-increment (locations 8-15):</strong> - Array traversal -
String processing - Block copy operations - Sequential data access</p>
<pre class="assembly"><code>   lac 8 i           " Traverse array
   dac 9 i           " Copy to another array</code></pre>
<h3 data-number="3.4.8" id="all-eight-auto-increment-registers"><span class="header-section-number">3.4.8</span> All Eight Auto-Increment
Registers</h3>
<p>Unix code uses a convention for these precious registers:</p>
<table>
<thead>
<tr>
<th>Octal</th>
<th>Decimal</th>
<th>Typical Use</th>
</tr>
</thead>
<tbody>
<tr>
<td>010</td>
<td>8</td>
<td>Primary pointer (arrays, strings)</td>
</tr>
<tr>
<td>011</td>
<td>9</td>
<td>Secondary pointer (destination)</td>
</tr>
<tr>
<td>012</td>
<td>10</td>
<td>Temporary pointer</td>
</tr>
<tr>
<td>013</td>
<td>11</td>
<td>String pointer</td>
</tr>
<tr>
<td>014</td>
<td>12</td>
<td>Buffer pointer</td>
</tr>
<tr>
<td>015</td>
<td>13</td>
<td>Stack pointer</td>
</tr>
<tr>
<td>016</td>
<td>14</td>
<td>Loop counter</td>
</tr>
<tr>
<td>017</td>
<td>15</td>
<td>Saved pointer</td>
</tr>
</tbody>
</table>
<p>This isn‚Äôt enforced by hardware, but Unix source code follows these
conventions consistently.</p>
<h3 data-number="3.4.9" id="real-unix-example-character-packing"><span class="header-section-number">3.4.9</span> Real Unix Example: Character
Packing</h3>
<p>From Unix <code>cat.s</code>, showing practical use:</p>
<pre class="assembly"><code>" Pack two characters into one word
" Characters are 9 bits each (PDP-7 uses 9-bit chars)

   lac ipt           " Load input pointer
   ral               " Rotate AC left (bit 17 ‚Üí Link)
   lac ipt i         " Load word from input buffer
   szl               " Skip if Link Zero (even character)
   lrss 9            " Shift right 9 bits (get odd character)
   and o177          " Mask to 7-bit ASCII
   dac char          " Store character

ipt: buffer          " Input pointer
char: 0
o177: 0177           " Octal 177 = binary 001111111 (7 bits)
buffer: 0</code></pre>
<p>This extracts individual characters from packed 18-bit
words‚Äîessential for Unix‚Äôs file I/O.</p>
<hr/>
<h2 data-number="3.5" id="control-flow"><span class="header-section-number">3.5</span> 4. Control Flow</h2>
<p>Sequential execution is insufficient for real programs. You need
branches, loops, and subroutines.</p>
<h3 data-number="3.5.1" id="unconditional-jump-jmp"><span class="header-section-number">3.5.1</span> Unconditional Jump: JMP</h3>
<p>The simplest control flow is the unconditional jump:</p>
<pre class="assembly"><code>" Infinite loop
loop:
   " ... do something ...
   jmp loop          " Jump back to 'loop' label

" Skip code
   jmp skip          " Jump over next section
   lac value1        " This is skipped
   dac result        " This is skipped
skip:
   lac value2        " Execution resumes here</code></pre>
<p><strong>Execution:</strong></p>
<pre><code>jmp loop ‚Üí PC ‚Üê address of 'loop' label</code></pre>
<p>The Program Counter (PC) is set to the target address, and execution
continues there.</p>
<h3 data-number="3.5.2" id="skip-instructions-building-conditional-logic"><span class="header-section-number">3.5.2</span> Skip Instructions: Building
Conditional Logic</h3>
<p>The PDP-7 has no compare instruction. Instead, it has <strong>skip
instructions</strong> that conditionally skip the next instruction:</p>
<p><strong>Skip instructions:</strong> - <code>sza</code> - Skip if AC
Zero - <code>sna</code> - Skip if AC Not zero (AC ‚â† 0) -
<code>sma</code> - Skip if AC Minus (AC &lt; 0, bit 17 = 1) -
<code>spa</code> - Skip if AC Plus (AC ‚â• 0, bit 17 = 0) -
<code>szl</code> - Skip if Link Zero - <code>snl</code> - Skip if Link
Not zero</p>
<p><strong>Basic pattern:</strong></p>
<pre class="assembly"><code>   lac value         " Load value
   sza               " Skip next instruction if AC = 0
   jmp nonzero       " This executes if AC ‚â† 0

   " Code for AC = 0 case
   jmp continue

nonzero:
   " Code for AC ‚â† 0 case

continue:
   " Execution continues</code></pre>
<h3 data-number="3.5.3" id="conditional-execution-examples"><span class="header-section-number">3.5.3</span> Conditional Execution
Examples</h3>
<p><strong>Example 1: If-Then</strong></p>
<pre class="assembly"><code>" If count == 0, reset it to 10

   lac count         " Load count
   sza               " Skip if zero
   jmp continue      " Not zero, skip reset

   " This executes only if count was 0
   lac d10           " Load 10
   dac count         " Store to count

continue:
   " ... rest of program ...

count: 0
d10: 10</code></pre>
<p><strong>Example 2: If-Then-Else</strong></p>
<pre class="assembly"><code>" If value &lt; 0, set result = -1, else result = +1

   lac value         " Load value
   sma               " Skip if minus (negative)
   jmp positive      " Value is positive or zero

negative:
   " Value is negative
   lac dm1           " Load -1
   dac result
   jmp continue

positive:
   " Value is positive or zero
   lac d1            " Load +1
   dac result

continue:
   " ... rest of program ...

value: -5            " Example: negative value
result: 0
d1: 1
dm1: -1</code></pre>
<p><strong>Example 3: Multiple conditions</strong></p>
<pre class="assembly"><code>" Classify value: negative, zero, or positive

   lac value         " Load value
   sza               " Skip if zero
   jmp notzero

iszero:
   lac msg_zero      " Handle zero case
   jmp continue

notzero:
   sma               " Skip if minus
   jmp positive

negative:
   lac msg_neg       " Handle negative case
   jmp continue

positive:
   lac msg_pos       " Handle positive case

continue:
   " ... continue ...

value: 42
msg_neg: -1
msg_zero: 0
msg_pos: 1</code></pre>
<h3 data-number="3.5.4" id="sad-skip-if-ac-different---comparison"><span class="header-section-number">3.5.4</span> SAD (Skip if AC Different) -
Comparison</h3>
<p>Compare AC to a memory value:</p>
<pre class="assembly"><code>   lac count         " Load count
   sad limit         " Skip if AC ‚â† Memory[limit]
   jmp equal         " AC = limit, jump to equal

notequal:
   " AC ‚â† limit
   jmp continue

equal:
   " AC = limit

continue:
   " ...

count: 10
limit: 10</code></pre>
<p><strong>Inverted logic (skip if equal):</strong></p>
<pre class="assembly"><code>" Skip if AC = limit (by inverting logic)

   lac count
   sad limit         " Skip if different
   skp               " Skip next instruction (only if equal)
   jmp different     " Jumped to if different

equal:
   " AC = limit
   jmp continue

different:
   " AC ‚â† limit

continue:
   " ...</code></pre>
<p>Wait, what‚Äôs <code>skp</code>? That‚Äôs our next topic!</p>
<h3 data-number="3.5.5" id="skp-skip-unconditionally"><span class="header-section-number">3.5.5</span> SKP (Skip
Unconditionally)</h3>
<p><code>skp</code> always skips the next instruction:</p>
<pre class="assembly"><code>   skp               " Always skip next instruction
   lac value1        " This is skipped
   lac value2        " Execution resumes here</code></pre>
<p><strong>Why is this useful?</strong></p>
<p>Combined with conditional skips for inverted logic:</p>
<pre class="assembly"><code>" Standard: Skip if zero
   lac count
   sza               " Skip if AC = 0
   jmp nonzero       " Execute if AC ‚â† 0
   " ... code for AC = 0 ...

" Inverted: Don't skip if zero
   lac count
   sza               " Skip if AC = 0
   skp               " Skipped if AC = 0, so only executes if AC ‚â† 0
   jmp zero          " Execute if AC = 0
   " ... code for AC ‚â† 0 ...</code></pre>
<p>This pattern appears frequently in Unix code for cleaner logic
flow.</p>
<h3 data-number="3.5.6" id="isz-increment-and-skip-if-zero---counting-loops"><span class="header-section-number">3.5.6</span> ISZ (Increment and Skip if
Zero) - Counting Loops</h3>
<p>The most important loop instruction:</p>
<pre class="assembly"><code>" ISZ: Memory[addr] ‚Üê Memory[addr] + 1
"      If result = 0, skip next instruction

   -10               " Load -10 (negative count)
   dac count         " count = -10

loop:
   " ... loop body ...

   isz count         " Increment count (-10 ‚Üí -9 ‚Üí ... ‚Üí 0)
                     " When count reaches 0, skip next instruction
   jmp loop          " Jump back (skipped when count = 0)

   " ... continue after loop ...

count: 0</code></pre>
<p><strong>Execution trace:</strong></p>
<pre><code>count = -10
isz count ‚Üí count = -9 (not zero, don't skip)
jmp loop  ‚Üí repeat

count = -9
isz count ‚Üí count = -8 (not zero, don't skip)
jmp loop  ‚Üí repeat

...

count = -1
isz count ‚Üí count = 0 (zero! skip next instruction)
jmp loop  ‚Üí SKIPPED

Execution continues after jmp loop</code></pre>
<p><strong>Why use negative counters?</strong></p>
<p>Using positive counters would require comparison:</p>
<pre class="assembly"><code>" Inefficient: positive counter
   cla
   dac count         " count = 0

loop:
   " ... body ...

   lac count
   tad d1            " count++
   dac count

   sad limit         " Compare to limit
   skp
   jmp done          " Exit if equal
   jmp loop          " Continue

done:
   " ...

count: 0
limit: 10
d1: 1

" This requires 7 instructions for loop control!</code></pre>
<p>With negative counter and ISZ:</p>
<pre class="assembly"><code>" Efficient: negative counter
   -10
   dac count

loop:
   " ... body ...

   isz count         " Just 2 instructions
   jmp loop          " for loop control!

count: 0</code></pre>
<p><strong>This is why Unix code is full of negative loop
counters.</strong></p>
<h3 data-number="3.5.7" id="complete-loop-examples"><span class="header-section-number">3.5.7</span> Complete Loop Examples</h3>
<p><strong>Example 1: Count down from 100 to 0</strong></p>
<pre class="assembly"><code>start:
   -100              " Load -100
   dac counter       " Initialize counter

loop:
   " ... loop body (executes 100 times) ...

   isz counter       " -100 ‚Üí -99 ‚Üí ... ‚Üí -1 ‚Üí 0
   jmp loop          " Continue while counter &lt; 0

   hlt               " Done

counter: 0</code></pre>
<p><strong>Example 2: Array initialization</strong></p>
<pre class="assembly"><code>" Zero out 64 words starting at buffer

   law buffer-1      " Setup pointer
   dac 8

   -64               " 64 iterations
   dac count

loop:
   dzm 8 i           " Deposit zero to memory at pointer
                     " (auto-increments pointer)

   isz count         " Increment count
   jmp loop          " Continue

   hlt               " Done

buffer: .=.+64       " Reserve 64 words
count: 0</code></pre>
<p><strong>Example 3: Nested loops (2D array)</strong></p>
<pre class="assembly"><code>" Zero a 10√ó10 array

   -10               " Outer loop: 10 rows
   dac outer

   law array-1       " Array base pointer
   dac 8

outer_loop:
   -10               " Inner loop: 10 columns per row
   dac inner

inner_loop:
   dzm 8 i           " Zero element, advance pointer

   isz inner         " Inner loop control
   jmp inner_loop

   isz outer         " Outer loop control
   jmp outer_loop

   hlt               " Done

array: .=.+100       " 10√ó10 = 100 words
outer: 0
inner: 0</code></pre>
<h3 data-number="3.5.8" id="dzm-deposit-zero-to-memory---efficient-clearing"><span class="header-section-number">3.5.8</span> DZM (Deposit Zero to Memory)
- Efficient Clearing</h3>
<p>A special instruction for zeroing memory:</p>
<pre class="assembly"><code>   dzm location      " Memory[location] ‚Üê 0
                     " More efficient than:
                     "   cla
                     "   dac location</code></pre>
<p>Used extensively for initialization:</p>
<pre class="assembly"><code>" Clear multiple variables
   dzm sum
   dzm count
   dzm total
   dzm result</code></pre>
<h3 data-number="3.5.9" id="jms-jump-to-subroutine---function-calls"><span class="header-section-number">3.5.9</span> JMS (Jump to Subroutine) -
Function Calls</h3>
<p>The fundamental mechanism for subroutines:</p>
<pre class="assembly"><code>" Call a subroutine
   jms subr          " Jump to subroutine
   " Execution returns here

" Continue main program
   hlt

" Subroutine definition
subr: 0              " Return address stored here!
   " ... subroutine body ...
   jmp subr i        " Return (indirect jump through return address)</code></pre>
<p><strong>How JMS works:</strong></p>
<pre><code>Before JMS:
   PC = 100 (address of JMS instruction)

Execute: jms subr (assume subr is at address 500)

Step 1: Memory[500] ‚Üê 101 (next instruction after JMS)
Step 2: PC ‚Üê 501 (address after label 'subr:')
Step 3: Execute subroutine body starting at 501

When subroutine executes: jmp subr i

Step 1: Load address from Memory[500] = 101
Step 2: PC ‚Üê 101
Step 3: Execution resumes after original JMS</code></pre>
<p><strong>Visual representation:</strong></p>
<pre><code>Main program:
   100: jms subr     ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   101: next instr         ‚îÇ Return here
   102: ...                ‚îÇ
                           ‚îÇ
Subroutine:               ‚îÇ
   500: 0           ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Return address stored here
   501: lac x              ‚Üê Execution starts here
   502: tad y
   503: dac z
   504: jmp subr i        ‚îÄ‚Üí Indirect jump to Memory[500]</code></pre>
<h3 data-number="3.5.10" id="subroutine-examples"><span class="header-section-number">3.5.10</span> Subroutine Examples</h3>
<p><strong>Example 1: Simple subroutine</strong></p>
<pre class="assembly"><code>" Main program
start:
   lac d5            " Load parameter
   dac param

   jms double        " Call subroutine
   " Result is in AC

   dac result        " Store result
   hlt

" Subroutine: double the parameter
double: 0            " Return address
   lac param         " Load parameter
   tad param         " Add it again (doubles it)
   jmp double i      " Return with result in AC

param: 0
result: 0
d5: 5</code></pre>
<p><strong>Example 2: Subroutine with multiple calls</strong></p>
<pre class="assembly"><code>start:
   lac a
   dac param
   jms square        " square(a)
   dac result1

   lac b
   dac param
   jms square        " square(b)
   dac result2

   lac c
   dac param
   jms square        " square(c)
   dac result3

   hlt

" Subroutine: square a number (using repeated addition)
square: 0
   lac param         " Load n
   dac count         " Use as counter
   cla               " result = 0
   dac result

   lac count         " Check for negative
   sma
   jmp sq_loop       " Positive, continue

   dzm result        " Negative not supported, return 0
   jmp square i

sq_loop:
   lac result
   tad param         " Add param to result
   dac result

   isz count         " Done?
   lac count
   sza
   jmp sq_loop

   lac result        " Load result into AC
   jmp square i      " Return

param: 0
count: 0
result: 0
result1: 0
result2: 0
result3: 0
a: 5
b: 7
c: 10</code></pre>
<p><strong>Example 3: Recursive subroutine (advanced)</strong></p>
<p>Recursion requires a stack to save return addresses:</p>
<pre class="assembly"><code>" Factorial (simplified, no stack for clarity)
" factorial(n) = n * factorial(n-1), base case: factorial(0) = 1

start:
   lac d5            " Calculate factorial(5)
   dac n
   jms factorial
   dac result        " Result in AC
   hlt

factorial: 0
   lac n             " Load n
   sza               " If n = 0
   jmp fact_recurse

   " Base case: return 1
   lac d1
   jmp factorial i

fact_recurse:
   " Recursive case: n * factorial(n-1)
   " (This is simplified; real recursion needs stack)
   lac n
   tad dm1           " n - 1
   dac n             " Update n (WRONG for real recursion!)

   jms factorial     " factorial(n-1)

   " Multiply result by n
   " (Multiplication code omitted for brevity)

   jmp factorial i

n: 0
result: 0
d1: 1
d5: 5
dm1: -1</code></pre>
<p><strong>Note:</strong> Real recursion requires saving return
addresses and local variables on a stack. Unix doesn‚Äôt use much
recursion due to memory constraints.</p>
<hr/>
<h2 data-number="3.6" id="data-structures"><span class="header-section-number">3.6</span> 5. Data Structures</h2>
<p>Assembly language has no built-in data types. Everything is an 18-bit
word. You create structure through convention and careful
programming.</p>
<h3 data-number="3.6.1" id="constants"><span class="header-section-number">3.6.1</span> Constants</h3>
<p>Define constants with simple labels:</p>
<pre class="assembly"><code>" Decimal constants (common values)
d0: 0
d1: 1
d2: 2
d8: 8
d10: 10
d64: 64

" Octal constants (bit patterns)
o7: 07               " Octal 7 = binary 111
o177: 0177           " ASCII mask (7 bits)
o777: 0777           " 9-bit mask

" Negative constants
dm1: -1              " 777777 octal
dm2: -2              " 777776 octal</code></pre>
<p><strong>Why not use literals?</strong></p>
<p>The PDP-7 has no immediate addressing mode. You can‚Äôt write:</p>
<pre class="assembly"><code>   lac 42            " ERROR: This loads from address 42!</code></pre>
<p>You must load from memory:</p>
<pre class="assembly"><code>   lac d42           " Correct: loads value 42 from location d42
d42: 42</code></pre>
<h3 data-number="3.6.2" id="single-word-variables"><span class="header-section-number">3.6.2</span> Single-Word Variables</h3>
<p>Reserve storage with labels:</p>
<pre class="assembly"><code>" Uninitialized variables
count: 0
sum: 0
result: 0

" Initialized variables
total: 100
limit: 1000
flag: -1

" Character variables
char: 0              " Will hold a 9-bit character
newline: 012         " Line feed character (octal 12 = decimal 10)</code></pre>
<h3 data-number="3.6.3" id="arrays-sequential-storage"><span class="header-section-number">3.6.3</span> Arrays (Sequential
Storage)</h3>
<p>Arrays are consecutive memory locations:</p>
<pre class="assembly"><code>" Method 1: Explicit initialization
scores: 95; 87; 92; 78; 88

" Method 2: Reserve uninitialized space
buffer: .=.+64       " Reserve 64 words (all zero)

" Method 3: Mixed
data: 1; 2; 3; 4     " First 4 elements initialized
      .=.+96         " Next 96 elements reserved</code></pre>
<p><strong>The <code>.=.+n</code> directive:</strong></p>
<p><code>.</code> is the location counter (current assembly address).
<code>.=.+n</code> means ‚Äúincrement location counter by n‚Äù, effectively
reserving n words.</p>
<p><strong>Accessing arrays:</strong></p>
<pre class="assembly"><code>" Method 1: Direct indexing (inefficient)
   lac array         " array[0]
   lac array+1       " array[1]
   lac array+2       " array[2]

" Method 2: Computed address (complex)
   law array         " Base address
   tad index         " Add index
   dac temp
   lac temp i        " Load element

" Method 3: Auto-increment (efficient!)
   law array-1
   dac 8
   lac 8 i           " array[0], pointer advances
   lac 8 i           " array[1], pointer advances
   lac 8 i           " array[2], pointer advances</code></pre>
<p><strong>Multi-dimensional arrays:</strong></p>
<pre class="assembly"><code>" 2D array: 10 rows √ó 5 columns = 50 elements
" Stored row-major: [0][0], [0][1], ..., [0][4], [1][0], ...

matrix: .=.+50       " 10√ó5 = 50 words

" Access matrix[row][col]
" Address = base + (row √ó 5) + col

" Example: Access matrix[3][2]
   lac d3            " row = 3
   tad d3            " √ó2
   tad d3            " √ó3
   tad d3            " √ó4
   tad d3            " √ó5 (row √ó columns)
   tad d2            " + col (2)
   tad matrix_addr   " + base address
   dac temp
   lac temp i        " Load matrix[3][2]

matrix_addr: matrix
d2: 2
d3: 3
temp: 0</code></pre>
<h3 data-number="3.6.4" id="structures-grouped-data"><span class="header-section-number">3.6.4</span> Structures (Grouped
Data)</h3>
<p>Group related data:</p>
<pre class="assembly"><code>" Structure: File descriptor
" Fields: fd.fileno, fd.mode, fd.position

file1:
   fd1.fileno: 3     " File number
   fd1.mode: 1       " Mode (0=read, 1=write)
   fd1.position: 0   " Current position

file2:
   fd2.fileno: 5
   fd2.mode: 0
   fd2.position: 1024

" Access structure fields
   lac fd1.fileno    " Load file number
   lac fd1.mode      " Load mode</code></pre>
<p><strong>Structure arrays:</strong></p>
<pre class="assembly"><code>" Array of file descriptors (3 words each)
" 10 files √ó 3 words = 30 words

files: .=.+30        " Reserve space

" Access file[i].field
" Address = files + (i √ó 3) + field_offset

" Field offsets
.fileno = 0
.mode = 1
.position = 2

" Access file[3].position
   lac d3            " File index
   tad d3            " √ó2
   tad d3            " √ó3 (i √ó structure_size)
   tad .position     " + field offset (2)
   law files         " + base
   tad temp          " ...
   " (Complex addressing needed)</code></pre>
<p><strong>Better: Define structure template</strong></p>
<pre class="assembly"><code>" Template for file descriptor structure
.define filestruct
   filestruct.fileno: 0
   filestruct.mode: 0
   filestruct.position: 0
.enddef

" Create instances
file1:
   0; 0; 0           " Fields initialized to 0

file2:
   3; 1; 0           " fileno=3, mode=1, position=0

" Access with offsets
   law file1         " Load structure address
   tad d1            " + offset for 'mode' field
   dac temp
   lac temp i        " Load mode field</code></pre>
<h3 data-number="3.6.5" id="character-strings-packed"><span class="header-section-number">3.6.5</span> Character Strings
(Packed)</h3>
<p>The PDP-7 packs 2 characters per word (each character is 9 bits):</p>
<pre><code>Word structure (18 bits):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Char1  ‚îÇ  Char2  ‚îÇ
‚îÇ (bits   ‚îÇ (bits   ‚îÇ
‚îÇ 17-9)   ‚îÇ  8-0)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
<p><strong>Defining strings:</strong></p>
<pre class="assembly"><code>" String "HELLO" (5 chars = 3 words)
" Pairs: 'H''E', 'L''L', 'O''\0'

msg: 0510; 0514; 0517; 00   " 'HE', 'LL', 'O\0'

" Or use assembler syntax (if supported)
msg: "Hello\0"     " Assembler packs automatically</code></pre>
<p><strong>Character encoding (9-bit ASCII):</strong></p>
<pre><code>Character   Octal   Binary (9-bit)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
'A'         0101    001 000 001
'H'         0510    101 001 000
'E'         0505    101 000 101
'L'         0514    101 001 100
'O'         0517    101 001 111
' '         040     000 100 000
'\n'        012     000 001 010
'\0'        000     000 000 000</code></pre>
<p><strong>Extracting characters:</strong></p>
<pre class="assembly"><code>" Extract left character (bits 17-9)
   lac word          " Load packed word
   lrss 9            " Logical right shift 9 bits
   and o777          " Mask to 9 bits (optional)

" Extract right character (bits 8-0)
   lac word          " Load packed word
   and o777          " Mask to lower 9 bits

o777: 0777           " 9-bit mask
word: 0510           " 'HE'</code></pre>
<p><strong>String processing example:</strong></p>
<pre class="assembly"><code>" Count characters in null-terminated string

   law string-1      " Setup pointer
   dac 8

   cla               " count = 0
   dac count

loop:
   lac 8 i           " Get next word (2 chars)
   dac word          " Save it

   " Check left character
   lrss 9            " Get high char
   and o777          " Mask
   sza               " If zero, done
   jmp count_left

   " Left char is null, done
   jmp done

count_left:
   lac count         " count++
   tad d1
   dac count

   " Check right character
   lac word          " Reload word
   and o777          " Get low char
   sza               " If zero, done
   jmp count_right

   " Right char is null, done
   jmp done

count_right:
   lac count         " count++
   tad d1
   dac count

   jmp loop          " Next word

done:
   hlt               " Result in count

string: 0510; 0514; 0517; 0  " "HELLO" (5 chars)
count: 0
word: 0
o777: 0777
d1: 1</code></pre>
<h3 data-number="3.6.6" id="linked-lists-advanced"><span class="header-section-number">3.6.6</span> Linked Lists (Advanced)</h3>
<p>While uncommon due to memory constraints, linked lists are
possible:</p>
<pre class="assembly"><code>" Node structure:
" .data (1 word)
" .next (1 word - pointer to next node)

" List: 10 ‚Üí 20 ‚Üí 30 ‚Üí NULL

node1:
   10                " data
   node2             " next pointer

node2:
   20                " data
   node3             " next pointer

node3:
   30                " data
   0                 " next = NULL

" Traverse list
   law node1         " Start at head
   dac ptr

traverse:
   lac ptr           " Load current pointer
   sza               " If NULL, done
   jmp process_node

   hlt               " Done

process_node:
   dac temp          " Save pointer
   lac temp i        " Load data field
   " ... process data ...

   " Advance to next node
   lac temp          " Reload pointer
   tad d1            " + 1 (offset to next field)
   dac temp
   lac temp i        " Load next pointer
   dac ptr           " Update ptr

   jmp traverse      " Continue

ptr: 0
temp: 0
d1: 1</code></pre>
<hr/>
<h2 data-number="3.7" id="advanced-techniques"><span class="header-section-number">3.7</span> 6. Advanced Techniques</h2>
<p>Now that you understand the basics, let‚Äôs explore sophisticated
programming techniques used in Unix.</p>
<h3 data-number="3.7.1" id="multi-precision-arithmetic"><span class="header-section-number">3.7.1</span> Multi-Precision
Arithmetic</h3>
<p>The PDP-7‚Äôs 18-bit words are sometimes insufficient. Unix uses
<strong>double-precision (36-bit)</strong> arithmetic for file sizes and
time values.</p>
<p><strong>36-bit number representation:</strong></p>
<pre><code>High word (18 bits)    Low word (18 bits)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Bits 35-18      ‚îÇ  Bits 17-0       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Example: 1000000 (decimal)
High: 000003    (3 √ó 2^18 = 786432)
Low:  0105100   (35136)
Total: 786432 + 35136 = 821568... wait, that's wrong!

Correct calculation:
1000000 decimal = 03641100 octal = 0364 1100 (36 bits)
Split: High = 000003 (upper 18 bits), Low = 0641100 (lower 18 bits)</code></pre>
<p><strong>36-bit addition:</strong></p>
<pre class="assembly"><code>" Add two 36-bit numbers: (high1,low1) + (high2,low2)

   " Add low words first
   lac low1          " Load low word of first number
   tad low2          " Add low word of second number
                     " Link receives carry out
   dac result_low    " Store low word of result

   " Add high words with carry
   lac high1         " Load high word of first number
   tad high2         " Add high word of second number
                     " Link from previous add is carry in!
   dac result_high   " Store high word of result

" Example: 100000 + 50000 = 150000
" 100000 octal = 000000 + 0303240 (high=0, low=0303240)
" 50000 octal  = 000000 + 0141510 (high=0, low=0141510)

high1: 0
low1: 0303240
high2: 0
low2: 0141510
result_high: 0       " Will be 0
result_low: 0        " Will be 0444750 (150000 octal)</code></pre>
<p><strong>Why the Link carries:</strong></p>
<pre><code>Step 1: Add low words
   low1 = 0303240
   low2 = 0141510
   sum  = 0444750 (no carry, Link = 0)

Step 2: Add high words
   high1 = 0
   high2 = 0
   Link  = 0 (carry from previous)
   sum   = 0 + 0 + 0 = 0</code></pre>
<p><strong>Example with carry:</strong></p>
<pre class="assembly"><code>" 500000 + 500000 = 1000000
" 500000 octal = 001 + 0731100
" (High = 1, Low = 0731100 ‚Äî wait, that's wrong too!)

" Let me recalculate:
" 500000 decimal = 0x7A120 hex = 1750440 octal
" High 18 bits: 001
" Low 18 bits:  0731100... no, still wrong.

" The issue is I'm confusing decimal and octal. Let me be clear:

" 500000 DECIMAL = 1750440 OCTAL
" Split into 18-bit words:
" 001 750440 (too long!)
" Actually: 1750440 octal = 18 bits? No, that's 19+ bits.

" Ah! 500000 decimal doesn't fit in 18 bits.
" Max 18-bit value = 2^18 - 1 = 262143 decimal

" Better example: Add 200000 + 150000 (decimal)

" First convert to octal:
" 200000 dec = 605620 octal (18-bit, fits)
" 150000 dec = 444750 octal (18-bit, fits)
" Sum = 350000 dec = 1252370 octal (19-bit, needs 2 words!)

" 1252370 octal in 36-bit:
" High: 000001 (bit 18)
" Low:  0252370 (bits 17-0)

   lac low1          " 0605620
   tad low2          " + 0444750 = 1252370
                     " Result: 0252370, Carry: Link = 1
   dac result_low    " 0252370

   lac high1         " 0
   tad high2         " + 0 = 0
                     " + Link (1) = 1
   dac result_high   " 1

low1: 0605620        " 200000 decimal
low2: 0444750        " 150000 decimal
high1: 0
high2: 0
result_high: 0       " Result: 1 (high word)
result_low: 0        " Result: 0252370 (low word)
                     " Together: 1,252370 octal = 350000 decimal</code></pre>
<p><strong>36-bit comparison:</strong></p>
<pre class="assembly"><code>" Compare (high1,low1) with (high2,low2)
" Return: AC &lt; 0 if less, 0 if equal, &gt; 0 if greater

   " Compare high words first
   lac high1
   tad neg_high2     " high1 - high2
   sza               " If not equal, done
   jmp done          " AC contains result

   " High words equal, compare low words
   lac low1
   tad neg_low2      " low1 - low2

done:
   " AC contains comparison result
   dac result

high1: 1
low1: 0100000
high2: 0
low2: 0777777
neg_high2: -0        " (Precomputed -high2)
neg_low2: -0777777   " (Precomputed -low2)
result: 0</code></pre>
<h3 data-number="3.7.2" id="multiplication-by-shifting"><span class="header-section-number">3.7.2</span> Multiplication by
Shifting</h3>
<p>The PDP-7 has multiply/divide instructions, but shifting is often
more efficient for powers of 2:</p>
<p><strong>Multiply by 2 (shift left 1):</strong></p>
<pre class="assembly"><code>   lac value         " Load value
   cll               " Clear Link
   als 1             " Arithmetic Left Shift 1 bit
   dac result        " Result = value √ó 2

value: 100           " Decimal 64
result: 0            " Will be 200 (decimal 128)</code></pre>
<p><strong>Multiply by 8 (shift left 3):</strong></p>
<pre class="assembly"><code>   lac value         " Load value
   cll               " Clear Link
   als 3             " Shift left 3 bits
   dac result        " Result = value √ó 8

value: 10            " Decimal 8
result: 0            " Will be 100 (decimal 64)</code></pre>
<p><strong>Divide by 2 (shift right 1):</strong></p>
<pre class="assembly"><code>   lac value         " Load value
   cll               " Clear Link
   lrs 1             " Logical Right Shift 1 bit
   dac result        " Result = value √∑ 2

value: 100           " Decimal 64
result: 0            " Will be 40 (decimal 32)</code></pre>
<p><strong>Why shifting is faster:</strong></p>
<pre class="assembly"><code>" Multiply by 8 using addition (slow)
   lac value
   tad value         " √ó2
   tad value         " √ó3
   tad value         " √ó4
   tad value         " √ó5
   tad value         " √ó6
   tad value         " √ó7
   tad value         " √ó8
   " 8 instructions!

" Multiply by 8 using shift (fast)
   lac value
   cll
   als 3             " √ó8
   " 3 instructions!</code></pre>
<h3 data-number="3.7.3" id="bit-manipulation"><span class="header-section-number">3.7.3</span> Bit Manipulation</h3>
<p><strong>Set specific bits:</strong></p>
<pre class="assembly"><code>" Set bit 5 in flags
   lac flags
   or bit5           " OR to set bit
   dac flags

flags: 0
bit5: 040            " Octal 40 = binary 000000000000100000 (bit 5)</code></pre>
<p><strong>Clear specific bits:</strong></p>
<pre class="assembly"><code>" Clear bit 5 in flags
   lac flags
   and not_bit5      " AND to clear bit
   dac flags

flags: 077
not_bit5: 777737     " All bits except bit 5 (complement of 040)</code></pre>
<p><strong>Toggle specific bits:</strong></p>
<pre class="assembly"><code>" Toggle bit 5 in flags
   lac flags
   xor bit5          " XOR to toggle
   dac flags

flags: 040
bit5: 040            " Result: flags becomes 0 (toggle off)</code></pre>
<p><strong>Test specific bit:</strong></p>
<pre class="assembly"><code>" Test if bit 5 is set
   lac flags
   and bit5          " Mask to bit 5
   sza               " Skip if zero (bit not set)
   jmp bit_set       " Bit is set

bit_clear:
   " Bit 5 is clear
   jmp continue

bit_set:
   " Bit 5 is set

continue:
   " ...

flags: 077
bit5: 040</code></pre>
<p><strong>Extract bit field:</strong></p>
<pre class="assembly"><code>" Extract bits 9-6 from value (4-bit field)

   lac value         " Load value
   lrss 6            " Shift right 6 bits
   and o17           " Mask to 4 bits (binary 1111)
   dac field         " Result is bits 9-6

value: 07654         " Binary: 111 110 101 100
                     " Bits 9-6: 1010 = octal 12
field: 0             " Will be 012

o17: 017             " Mask: 000000000000001111</code></pre>
<p><strong>Pack bit fields:</strong></p>
<pre class="assembly"><code>" Pack two 8-bit values into one word

   lac value1        " Load first value (8 bits)
   cll
   als 8             " Shift left 8 bits
   or value2         " OR with second value
   dac packed        " Result: value1 in bits 15-8, value2 in bits 7-0

value1: 0123         " 8-bit value (bits 7-0)
value2: 0456         " 8-bit value (bits 7-0)
packed: 0            " Will be 0123456 (concatenated)</code></pre>
<h3 data-number="3.7.4" id="rotate-operations"><span class="header-section-number">3.7.4</span> Rotate Operations</h3>
<p><strong>RAL/RAR (Rotate AC Left/Right):</strong></p>
<pre class="assembly"><code>" Rotate AC left (19-bit rotate: Link + AC)
   lac value         " Load 000123
   cll               " Link = 0
   ral               " Rotate left
                     " Before: Link=0, AC=000123 (binary: 0 001010011)
                     " After:  Link=0, AC=000246 (binary: 0 010100110)

" Rotate AC right
   lac value         " Load 000246
   cll               " Link = 0
   rar               " Rotate right
                     " Result: Link=0, AC=000123

value: 000123</code></pre>
<p><strong>RCL/RCR (Rotate Combined Left/Right):</strong></p>
<pre class="assembly"><code>" Rotate 19 bits (Link + AC) left
   lac value         " Load value
   stl               " Set Link to 1
   rcl               " Rotate combined left
                     " Rotates all 19 bits (Link + 18-bit AC)

" Rotate 19 bits right
   lac value
   cll               " Clear Link
   rcr               " Rotate combined right</code></pre>
<p><strong>Practical use: Test high bit</strong></p>
<pre class="assembly"><code>" Test if bit 17 (sign bit) is set

   lac value         " Load value
   ral               " Rotate left (bit 17 ‚Üí Link)
   snl               " Skip if Link Not set
   jmp positive      " Bit 17 was 0 (positive)

negative:
   " Bit 17 was 1 (negative)
   jmp continue

positive:
   " Bit 17 was 0 (positive)

continue:
   " ...

value: 777777        " Negative (-1)</code></pre>
<h3 data-number="3.7.5" id="optimized-character-handling"><span class="header-section-number">3.7.5</span> Optimized Character
Handling</h3>
<p><strong>Extract character from packed word:</strong></p>
<p>From Unix source code (cat.s pattern):</p>
<pre class="assembly"><code>" Extract one character from packed word
" Two 9-bit chars per word: [char0][char1]
" ipt points to word, ipt bit 0 selects which char

   lac ipt           " Load pointer (includes char index in bit 0)
   ral               " Rotate left: bit 0 ‚Üí Link
   lac ipt i         " Load word from buffer
   szl               " Skip if Link = 0 (even char, left char)
   lrss 9            " Odd char: shift right 9 bits
   and o177          " Mask to 7-bit ASCII
   dac char          " Store character

   " Advance pointer to next character
   lac ipt
   tad half          " Add 0.5 (in fixed point: 0400000)
   dac ipt           " Next char (toggles bit 0, carries to bit 1)

ipt: buffer          " Pointer to packed buffer
char: 0
o177: 0177           " 7-bit ASCII mask
half: 0400000        " Half-word increment
buffer: 0</code></pre>
<p>This elegant code uses bit 0 of the pointer to track odd/even
characters!</p>
<h3 data-number="3.7.6" id="loop-unrolling-for-performance"><span class="header-section-number">3.7.6</span> Loop Unrolling for
Performance</h3>
<p><strong>Standard loop (5 iterations):</strong></p>
<pre class="assembly"><code>   -5
   dac count
loop:
   " ... body (assume 10 instructions) ...
   isz count         " 1 instruction
   jmp loop          " 1 instruction
   " Total: 5 √ó (10 + 2) = 60 instructions executed</code></pre>
<p><strong>Unrolled loop (no loop overhead):</strong></p>
<pre class="assembly"><code>   " ... body (10 instructions) ...
   " ... body (10 instructions) ...
   " ... body (10 instructions) ...
   " ... body (10 instructions) ...
   " ... body (10 instructions) ...
   " Total: 5 √ó 10 = 50 instructions executed
   " Savings: 10 instructions (16% faster!)</code></pre>
<p>Unrolling trades code size for speed‚Äîworthwhile for tight inner
loops.</p>
<hr/>
<h2 data-number="3.8" id="the-unix-assembler"><span class="header-section-number">3.8</span> 7. The Unix Assembler</h2>
<p>The assembler (<code>as.s</code>) is a remarkably compact two-pass
assembler that assembles itself‚Äîa bootstrap marvel.</p>
<h3 data-number="3.8.1" id="two-pass-assembly-process"><span class="header-section-number">3.8.1</span> Two-Pass Assembly
Process</h3>
<p><strong>Pass 1: Build Symbol Table</strong></p>
<ol type="1">
<li><strong>Read source file</strong> line by line</li>
<li><strong>Track location counter</strong> (current assembly
address)</li>
<li><strong>Record labels</strong> and their addresses in symbol
table</li>
<li><strong>Handle directives</strong> (<code>.=</code>,
<code>.=.+n</code>)</li>
<li><strong>Don‚Äôt generate code</strong> yet (just scan)</li>
</ol>
<p><strong>Pass 2: Generate Code</strong></p>
<ol type="1">
<li><strong>Re-read source file</strong> from beginning</li>
<li><strong>Look up symbols</strong> in symbol table (built in Pass
1)</li>
<li><strong>Evaluate expressions</strong> (e.g.,
<code>array+10</code>)</li>
<li><strong>Generate machine code</strong> with resolved addresses</li>
<li><strong>Write output</strong> to object file</li>
</ol>
<p><strong>Why two passes?</strong></p>
<p>Forward references require two passes:</p>
<pre class="assembly"><code>   jmp forward       " Pass 1: Don't know address of 'forward' yet
                     " Pass 2: Look up 'forward' in symbol table

   " ... more code ...

forward:             " Pass 1: Record this address in symbol table
   lac value</code></pre>
<h3 data-number="3.8.2" id="symbol-table"><span class="header-section-number">3.8.2</span> Symbol Table</h3>
<p>The symbol table maps names to addresses:</p>
<pre><code>Symbol Table (after Pass 1):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Symbol     ‚îÇ Address ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  start      ‚îÇ  0000   ‚îÇ
‚îÇ  loop       ‚îÇ  0012   ‚îÇ
‚îÇ  count      ‚îÇ  0034   ‚îÇ
‚îÇ  value      ‚îÇ  0035   ‚îÇ
‚îÇ  d1         ‚îÇ  0036   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
<p><strong>Symbol types:</strong></p>
<ul>
<li><strong>Labels</strong> - Code locations (e.g.,
<code>loop:</code>)</li>
<li><strong>Variables</strong> - Data locations (e.g.,
<code>count: 0</code>)</li>
<li><strong>Constants</strong> - Defined values (e.g.,
<code>maxsize = 100</code>)</li>
<li><strong>Global symbols</strong> - Exported to linker</li>
<li><strong>Local symbols</strong> - Numeric labels (1:, 2:, etc.)</li>
</ul>
<h3 data-number="3.8.3" id="forward-and-backward-references"><span class="header-section-number">3.8.3</span> Forward and Backward
References</h3>
<p><strong>Backward reference</strong> (already defined):</p>
<pre class="assembly"><code>loop:                " Defined here (address known)
   lac count
   isz count
   jmp loop          " Backward ref: address already in symbol table</code></pre>
<p><strong>Forward reference</strong> (not yet defined):</p>
<pre class="assembly"><code>   jmp done          " Forward ref: address unknown in Pass 1
                     " Pass 2: look up 'done' in symbol table

   " ... code ...

done:                " Defined here
   hlt</code></pre>
<p><strong>Local labels</strong> (numeric):</p>
<pre class="assembly"><code>   jmp 1f            " Forward ref to label '1'
1:
   lac value
   jmp 2f            " Forward ref to label '2'

1:                   " Reused label '1' (local scope)
   dac result
   jmp 1b            " Backward ref to previous '1'

2:
   hlt</code></pre>
<ul>
<li><code>1f</code> = forward reference to next label
<code>1:</code></li>
<li><code>1b</code> = backward reference to previous label
<code>1:</code></li>
</ul>
<p>This allows reusing simple numeric labels without conflict.</p>
<h3 data-number="3.8.4" id="expression-evaluation"><span class="header-section-number">3.8.4</span> Expression Evaluation</h3>
<p>The assembler can evaluate arithmetic expressions:</p>
<pre class="assembly"><code>" Simple arithmetic
   lac array+5       " Address of array plus 5
   lac buffer+64     " 64 words beyond buffer
   law value-1       " One before value

" Constants
size = 100           " Define constant
   lac size          " Use constant (assembler substitutes 100)

" Complex expressions
   lac array+(size*2)    " array + (size √ó 2)
   law buffer+(size-1)   " buffer + (size - 1)</code></pre>
<p><strong>Expression operators:</strong></p>
<ul>
<li><code>+</code> - Addition</li>
<li><code>-</code> - Subtraction</li>
<li><code>*</code> - Multiplication</li>
<li><code>/</code> - Division</li>
<li><code>&amp;</code> - Bitwise AND</li>
<li><code>|</code> - Bitwise OR (some assemblers)</li>
</ul>
<p><strong>Evaluation rules:</strong></p>
<ul>
<li>Constants and symbols are operands</li>
<li>Standard operator precedence (* / before + -)</li>
<li>Parentheses for grouping</li>
<li>All arithmetic is 18-bit</li>
</ul>
<h3 data-number="3.8.5" id="assembler-directives-1"><span class="header-section-number">3.8.5</span> Assembler Directives</h3>
<p><strong>Location counter assignment:</strong></p>
<pre class="assembly"><code>   .=1000            " Set location counter to 1000 (octal)
                     " Next instruction assembles at 1000

   .=.+10            " Advance location counter by 10
                     " Reserve 10 words</code></pre>
<p><strong>Constant definition:</strong></p>
<pre class="assembly"><code>size = 100           " Define size as 100
mask = 0177          " Define mask as octal 177</code></pre>
<p><strong>String and data:</strong></p>
<pre class="assembly"><code>msg: "Hello\0"       " String (packed, 2 chars/word)
data: 1; 2; 3; 4     " Array of values
buffer: .=.+64       " Reserve 64 words (uninitialized)</code></pre>
<h3 data-number="3.8.6" id="code-from-as.s"><span class="header-section-number">3.8.6</span> Code from as.s</h3>
<p>The assembler‚Äôs core loop (simplified):</p>
<pre class="assembly"><code>" Pass 1: Build symbol table
pass1:
   " Read line from source
   jms getline

   " Check for label (ends with ':')
   jms checklabel
   sza
   jms addlabel      " Add to symbol table with current location

   " Process instruction/directive
   jms parseline     " Parse mnemonic and operands

   " Update location counter
   lac location
   tad d1            " location++
   dac location

   " Check for end of file
   lac eof_flag
   sza
   jms pass1         " Continue Pass 1

   " Start Pass 2
   jms pass2</code></pre>
<p><strong>Symbol table lookup:</strong></p>
<pre class="assembly"><code>" lookup: Find symbol in table
" Input: symbol name in AC
" Output: AC = address (or -1 if not found)

lookup: 0
   dac symbol_name   " Save symbol

   law symtab-1      " Point to symbol table
   dac 8

   lac symtab_count  " Number of entries
   dac count

lkloop:
   lac 8 i           " Get next symbol entry
   sad symbol_name   " Compare to search name
   jmp found         " Match!

   lac 8 i           " Skip address field
   isz count         " Continue?
   jmp lkloop

   " Not found
   lac dm1           " Return -1
   jmp lookup i

found:
   lac 8 i           " Load address
   jmp lookup i      " Return

symbol_name: 0
symtab: .=.+1000     " Symbol table (500 entries max)
symtab_count: 0
count: 0
dm1: -1</code></pre>
<h3 data-number="3.8.7" id="macro-expansion-sys"><span class="header-section-number">3.8.7</span> Macro Expansion (sys)</h3>
<p>The <code>sys</code> pseudo-op generates system call sequences:</p>
<pre class="assembly"><code>" Source code:
sys read; 3; buffer; 64

" Expands to:
   jms 020           " System call trap
   4                 " Read syscall number
   3                 " File descriptor
   buffer            " Buffer address
   64                " Count</code></pre>
<p>The assembler recognizes <code>sys</code> and expands it during
assembly.</p>
<h3 data-number="3.8.8" id="linking-multiple-files"><span class="header-section-number">3.8.8</span> Linking Multiple Files</h3>
<p>The assembler can combine multiple source files:</p>
<div class="sourceCode" id="cb276"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb276-1"><a aria-hidden="true" href="#cb276-1" tabindex="-1"></a><span class="fu">as</span> file1.s file2.s file3.s</span></code></pre></div>
<p><strong>File1.s:</strong></p>
<pre class="assembly"><code>   jms subr          " Call subroutine in file2
   hlt

.globl subr          " Declare external symbol</code></pre>
<p><strong>File2.s:</strong></p>
<pre class="assembly"><code>subr:                " Define subroutine
   lac value
   jmp subr i

.globl subr          " Export symbol</code></pre>
<p>The assembler resolves cross-file references during linking.</p>
<hr/>
<h2 data-number="3.9" id="calling-conventions"><span class="header-section-number">3.9</span> 8. Calling Conventions</h2>
<p>For code to interoperate, programs must follow conventions for
subroutine calls.</p>
<h3 data-number="3.9.1" id="parameter-passing-1"><span class="header-section-number">3.9.1</span> Parameter Passing</h3>
<p><strong>Method 1: Global variables (simplest)</strong></p>
<pre class="assembly"><code>" Caller
   lac arg1_val      " Set up arguments
   dac param1
   lac arg2_val
   dac param2

   jms multiply      " Call function

   lac result        " Get result
   dac answer

" Callee
multiply: 0
   lac param1
   " ... multiply param1 * param2 ...
   dac result
   jmp multiply i

param1: 0
param2: 0
result: 0</code></pre>
<p><strong>Method 2: Inline arguments (more flexible)</strong></p>
<pre class="assembly"><code>" Caller
   jms multiply
   arg1_val          " Arguments follow call
   arg2_val
   " Execution resumes here with result in AC

" Callee
multiply: 0
   lac multiply i    " Load return address
   dac ret_addr      " Save it

   lac ret_addr i    " Load first argument
   isz ret_addr      " Advance return address
   dac param1

   lac ret_addr i    " Load second argument
   isz ret_addr      " Advance return address
   dac param2

   " ... compute result in AC ...

   lac ret_addr      " Load return address
   jmp multiply i    " Return (indirect through multiply)

ret_addr: 0
param1: 0
param2: 0</code></pre>
<p><strong>Method 3: AC and MQ registers</strong></p>
<pre class="assembly"><code>" Caller
   lac arg1          " First argument in AC
   lmq               " Second argument in MQ (or save AC, load arg2)
   jms function
   " Result in AC

" Callee
function: 0
   dac param1        " Save AC (arg1)
   lacq              " Load MQ
   dac param2        " Save MQ (arg2)

   " ... compute ...
   " Put result in AC

   jmp function i

param1: 0
param2: 0</code></pre>
<h3 data-number="3.9.2" id="return-values-1"><span class="header-section-number">3.9.2</span> Return Values</h3>
<p><strong>Return value in AC:</strong></p>
<pre class="assembly"><code>" Function
square: 0
   lac param
   " ... square the value ...
   " Leave result in AC
   jmp square i      " Return with result in AC

" Caller
   jms square
   dac result        " Save return value from AC</code></pre>
<p><strong>Return value in memory:</strong></p>
<pre class="assembly"><code>" Function
process: 0
   " ... computation ...
   dac result        " Store result
   jmp process i

" Caller
   jms process
   lac result        " Load result from memory</code></pre>
<p><strong>Multiple return values (AC + MQ):</strong></p>
<pre class="assembly"><code>" Function returns quotient in AC, remainder in MQ
divide: 0
   lac dividend
   " ... division algorithm ...
   " Quotient in AC
   " Remainder in MQ
   lmq               " Store remainder in MQ
   jmp divide i

" Caller
   jms divide
   dac quotient      " Save AC (quotient)
   lacq              " Load MQ
   dac remainder     " Save MQ (remainder)</code></pre>
<h3 data-number="3.9.3" id="register-usage-conventions"><span class="header-section-number">3.9.3</span> Register Usage
Conventions</h3>
<p>Unix code follows these conventions:</p>
<p><strong>Caller-saved registers:</strong> - <strong>AC</strong> -
Accumulator (caller must save if needed after call) -
<strong>MQ</strong> - Multiplier-Quotient (caller must save) -
<strong>Link</strong> - Carry/borrow bit (caller must save)</p>
<p><strong>Callee-saved registers:</strong> - <strong>Auto-increment
registers (8-15)</strong> - Callee should preserve if used</p>
<p><strong>Example: Saving registers</strong></p>
<pre class="assembly"><code>" Caller saves AC
   lac important     " Value we need after call
   dac saved_ac      " Save it

   jms function      " Call may destroy AC

   lac saved_ac      " Restore AC
   dac result        " Use saved value

saved_ac: 0</code></pre>
<p><strong>Callee saves registers:</strong></p>
<pre class="assembly"><code>function: 0
   " Save registers we'll use
   lac 8             " Save R8
   dac saved_r8
   lac 9             " Save R9
   dac saved_r9

   " ... use R8 and R9 ...

   " Restore registers
   lac saved_r8
   dac 8
   lac saved_r9
   dac 9

   jmp function i

saved_r8: 0
saved_r9: 0</code></pre>
<h3 data-number="3.9.4" id="library-function-example"><span class="header-section-number">3.9.4</span> Library Function Example</h3>
<p>From Unix: <code>betwen</code> (check if value is between bounds)</p>
<pre class="assembly"><code>" betwen: Check if value is in range [low, high]
" Call: jms betwen; value; low; high
" Return: AC = 0 if in range, -1 if out of range

betwen: 0
   lac betwen i      " Load return address
   dac ret
   isz ret           " Skip to first arg

   lac ret i         " Load value
   isz ret
   dac value

   lac ret i         " Load low
   isz ret
   dac low

   lac ret i         " Load high
   isz ret
   dac high_val

   " Check if value &lt; low
   lac value
   tad neg_low       " value - low
   sma               " Skip if negative
   jmp check_high

   " value &lt; low, out of range
   lac dm1
   jmp betwen_ret

check_high:
   " Check if value &gt; high
   lac value
   tad neg_high      " value - high
   spa               " Skip if positive or zero
   jmp in_range

   " value &gt; high, out of range
   lac dm1
   jmp betwen_ret

in_range:
   " In range
   cla

betwen_ret:
   lac ret
   dac betwen        " Update return address
   jmp betwen i      " Return

ret: 0
value: 0
low: 0
high_val: 0
neg_low: 0           " Precomputed -low
neg_high: 0          " Precomputed -high
dm1: -1</code></pre>
<hr/>
<h2 data-number="3.10" id="system-call-interface"><span class="header-section-number">3.10</span> 9. System Call Interface</h2>
<p>User programs interact with the kernel through system calls.</p>
<h3 data-number="3.10.1" id="the-sys-pseudo-operation"><span class="header-section-number">3.10.1</span> The sys
Pseudo-Operation</h3>
<p>The <code>sys</code> macro generates a system call:</p>
<pre class="assembly"><code>sys read; fd; buffer; count</code></pre>
<p><strong>Expands to:</strong></p>
<pre class="assembly"><code>   jms 020           " Jump to system call trap (location 020)
   4                 " System call number (4 = read)
   fd                " Argument 1
   buffer            " Argument 2
   count             " Argument 3</code></pre>
<p><strong>Location 020</strong> is the system call trap vector. All
system calls enter the kernel here.</p>
<h3 data-number="3.10.2" id="system-call-conventions"><span class="header-section-number">3.10.2</span> System Call Conventions</h3>
<p><strong>Entry:</strong> 1. User executes <code>jms 020</code> 2.
Return address (next instruction) stored at location 020 3. PC jumps to
021 (kernel entry point) 4. Kernel saves user state 5. Kernel reads
syscall number from return address 6. Kernel dispatches to appropriate
handler</p>
<p><strong>Exit:</strong> 1. Kernel restores user state 2. Kernel
advances return address past arguments 3. Kernel returns to user code 4.
AC contains return value</p>
<p><strong>Return values:</strong> - <strong>Positive</strong> - Success
(e.g., byte count, file descriptor) - <strong>Zero</strong> - Success
(for operations with no data) - <strong>Negative</strong> - Error
(usually -1)</p>
<h3 data-number="3.10.3" id="common-system-calls"><span class="header-section-number">3.10.3</span> Common System Calls</h3>
<p><strong>File operations:</strong></p>
<pre class="assembly"><code>" open: Open file
" Call: sys open; filename; mode
" Return: AC = file descriptor (or -1 on error)

   sys open; filename; 0     " 0 = read mode
   sma                       " Skip if negative (error)
   jmp error
   dac fd                    " Save file descriptor

" read: Read from file
" Call: sys read; fd; buffer; count
" Return: AC = bytes read (or -1 on error)

   sys read; fd; buffer; 64
   sma
   jmp error
   dac bytes_read

" write: Write to file
" Call: sys write; fd; buffer; count
" Return: AC = bytes written

   sys write; fd; buffer; 64
   dac bytes_written

" close: Close file
" Call: sys close; fd
" Return: AC = 0 on success, -1 on error

   sys close; fd</code></pre>
<p><strong>Process operations:</strong></p>
<pre class="assembly"><code>" fork: Create child process
" Call: sys fork
" Return: AC = 0 in child, child PID in parent

   sys fork
   sza                       " Skip if zero (child)
   jmp parent                " Non-zero: parent process

child:
   " This is the child process
   " AC = 0
   jmp continue

parent:
   " This is the parent process
   " AC = child PID
   dac child_pid

continue:
   " ...

" exit: Terminate process
" Call: sys exit
" Return: Never returns

   sys exit                  " Process terminates

" getuid: Get user ID
" Call: sys getuid
" Return: AC = user ID (negative if superuser)

   sys getuid
   dac uid</code></pre>
<h3 data-number="3.10.4" id="error-handling"><span class="header-section-number">3.10.4</span> Error Handling</h3>
<p>Check for errors after every system call:</p>
<pre class="assembly"><code>" Pattern 1: Check for negative (error)
   sys open; filename; 0
   sma                       " Skip if minus (error)
   jmp error_handler         " Handle error
   dac fd                    " Success, save fd

" Pattern 2: Check for specific error
   sys read; fd; buffer; 100
   tad dm1                   " Add -1
   sza                       " If AC was -1, now 0
   jmp success

error:
   " Handle error (read returned -1)
   jmp continue

success:
   " Process data

continue:
   " ...</code></pre>
<p><strong>Common error patterns:</strong></p>
<pre class="assembly"><code>" open failed: file not found
   sys open; filename; 0
   sma
   jmp file_not_found

" read failed: I/O error or EOF
   sys read; fd; buffer; count
   sma
   jmp read_error

" write failed: disk full or permission denied
   sys write; fd; buffer; count
   sad count                 " Check if bytes_written = count
   skp
   jmp incomplete_write      " Didn't write all bytes</code></pre>
<h3 data-number="3.10.5" id="complete-system-call-example"><span class="header-section-number">3.10.5</span> Complete System Call
Example</h3>
<pre class="assembly"><code>" Program: Copy file to output
" Usage: Reads from file descriptor 3, writes to fd 1 (stdout)

start:
   " Open input file
   sys open; infile; 0       " Mode 0 = read
   sma                       " Error?
   jmp open_error
   dac in_fd                 " Save file descriptor

read_loop:
   " Read block
   sys read; in_fd; buffer; 64
   sma                       " Error?
   jmp read_error
   sza                       " EOF (0 bytes)?
   jmp got_data
   jmp done                  " EOF, exit

got_data:
   dac byte_count            " Save count

   " Write block
   sys write; d1; buffer; byte_count
   sma                       " Error?
   jmp write_error

   jmp read_loop             " Continue

done:
   sys close; in_fd
   sys exit                  " Terminate

open_error:
   " Handle open error
   sys exit

read_error:
   " Handle read error
   sys exit

write_error:
   " Handle write error
   sys exit

" Data
infile: "input\0"
buffer: .=.+64               " 64-word buffer
in_fd: 0
byte_count: 0
d1: 1                        " stdout file descriptor</code></pre>
<hr/>
<h2 data-number="3.11" id="complete-programs"><span class="header-section-number">3.11</span> 10. Complete Programs</h2>
<p>Let‚Äôs build complete, working programs that demonstrate everything
you‚Äôve learned.</p>
<h3 data-number="3.11.1" id="program-1-character-counter"><span class="header-section-number">3.11.1</span> Program 1: Character
Counter</h3>
<p>Count characters in a file:</p>
<pre class="assembly"><code>" charcount: Count characters read from stdin
" Usage: charcount &lt; file

start:
   " Initialize counter
   cla
   dac count
   dac count_high            " 36-bit counter

read_loop:
   " Read one block
   sys read; 0; buffer; 64
   sma                       " Error?
   jmp error
   sza                       " EOF?
   jmp got_data
   jmp done                  " EOF, print result

got_data:
   " AC contains byte count for this block
   dac nread

   " Add to total count (36-bit addition)
   lac count                 " Low word
   tad nread
   dac count

   lac count_high            " High word (with carry)
   tad d0                    " Add 0 + carry from Link
   dac count_high

   jmp read_loop             " Continue reading

done:
   " Print result (simplified: just halt with count in memory)
   " Real version would convert to decimal and print
   hlt

error:
   sys exit

" Data
buffer: .=.+64
count: 0                     " Character count (low word)
count_high: 0                " Character count (high word)
nread: 0
d0: 0</code></pre>
<h3 data-number="3.11.2" id="program-2-file-copier-cp"><span class="header-section-number">3.11.2</span> Program 2: File Copier
(cp)</h3>
<p>Copy input file to output file:</p>
<pre class="assembly"><code>" cp: Copy standard input to standard output
" Usage: cp &lt; input &gt; output

start:
loop:
   " Read from stdin (fd 0)
   sys read; 0; buffer; 64
   sma                       " Error?
   jmp error
   sza                       " EOF?
   jmp got_data

   " EOF reached, exit
   sys exit

got_data:
   " AC = number of bytes read
   dac nread

   " Write to stdout (fd 1)
   sys write; 1; buffer; nread
   sma                       " Error?
   jmp error

   jmp loop                  " Continue

error:
   " Error occurred, exit
   sys exit

" Data
buffer: .=.+64               " I/O buffer (64 words)
nread: 0                     " Bytes read

" File descriptors (constants)
stdin = 0
stdout = 1</code></pre>
<p><strong>Annotated version with comments:</strong></p>
<pre class="assembly"><code>" ========================================
" cp: Copy standard input to standard output
" ========================================
"
" This program reads data from file descriptor 0 (standard input)
" and writes it to file descriptor 1 (standard output).
" It continues until EOF is reached on input.
"
" Memory usage: ~70 words
" ========================================

start:
loop:
   " ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   " Read up to 64 words from stdin
   " ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   sys read; 0; buffer; 64
                        " System call #4: read
                        " Arg1: fd = 0 (stdin)
                        " Arg2: buffer address
                        " Arg3: count = 64 words
                        " Returns: AC = bytes read (or -1)

   sma                  " Skip if Minus (AC &lt; 0)
                        " If AC &gt;= 0, fall through
                        " If AC &lt; 0, error occurred
   jmp error            " Handle read error

   sza                  " Skip if Zero (AC == 0)
                        " If AC != 0, fall through (data read)
                        " If AC == 0, EOF reached
   jmp got_data         " Process data

   " ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   " EOF: No more data, exit cleanly
   " ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   sys exit             " System call #14: exit
                        " Process terminates (no return)

got_data:
   " ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   " We read some data (AC = byte count)
   " Save count and write to stdout
   " ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   dac nread            " Store byte count for write

   sys write; 1; buffer; nread
                        " System call #5: write
                        " Arg1: fd = 1 (stdout)
                        " Arg2: buffer address
                        " Arg3: nread (count from read)
                        " Returns: AC = bytes written

   sma                  " Check for write error
   jmp error            " Handle write error

   jmp loop             " Continue reading/writing

error:
   " ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   " I/O error: exit immediately
   " ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   sys exit             " Terminate with error

" ========================================
" Data Area
" ========================================

buffer: .=.+64          " I/O buffer
                        " Reserve 64 words (128 bytes)
                        " Shared for both read and write

nread: 0                " Number of bytes read
                        " Saved from read syscall
                        " Used as count for write

" ========================================
" Constants (could be defined but not needed here
" since we use literal fd numbers 0 and 1)
" ========================================</code></pre>
<h3 data-number="3.11.3" id="program-3-line-counter-wc--l"><span class="header-section-number">3.11.3</span> Program 3: Line Counter (wc
-l)</h3>
<p>Count lines in input:</p>
<pre class="assembly"><code>" linecount: Count newline characters in input
" Usage: linecount &lt; file

start:
   " Initialize line counter
   cla
   dac line_count

read_loop:
   " Read block
   sys read; 0; buffer; 64
   sma
   jmp error
   sza
   jmp got_data
   jmp done              " EOF

got_data:
   dac nread             " Save byte count

   " Setup pointer to scan buffer
   law buffer-1
   dac 8

   lac nread             " Loop count = nread
   dac temp
   cla
   tad temp              " Negate for countdown
   dac count

scan_loop:
   " Get next word (2 chars)
   lac 8 i               " Auto-increment pointer
   dac word              " Save word

   " Check left character (bits 17-9)
   lrss 9                " Shift right 9 bits
   and o777              " Mask to 9 bits
   sad newline           " Is it newline?
   jmp found_nl_left

   " Check right character (bits 8-0)
   lac word
   and o777              " Mask to 9 bits
   sad newline           " Is it newline?
   jmp found_nl_right

   jmp next_word

found_nl_left:
   lac line_count
   tad d1
   dac line_count
   jmp check_right       " Still need to check right char

found_nl_right:
   lac line_count
   tad d1
   dac line_count

check_right:
   " Check if we need to check right char
   " (Only if we didn't already via found_nl_left)

next_word:
   isz count             " More words?
   jmp scan_loop

   jmp read_loop         " Read next block

done:
   " Print line count (simplified: just halt)
   " Real implementation would convert to decimal and print
   hlt

error:
   sys exit

" Data
buffer: .=.+64
line_count: 0
nread: 0
word: 0
count: 0
temp: 0
newline: 012             " Newline character (octal 12 = decimal 10)
o777: 0777               " 9-bit mask
d1: 1</code></pre>
<h3 data-number="3.11.4" id="program-4-simple-grep-search"><span class="header-section-number">3.11.4</span> Program 4: Simple grep
(Search)</h3>
<p>Find lines containing a pattern:</p>
<pre class="assembly"><code>" search: Find lines containing "error"
" Usage: search &lt; file

start:
   " Initialize
   cla
   dac match_count

read_loop:
   " Read line
   jms readline          " Read one line into line_buf
   sma                   " Error or EOF?
   jmp check_line
   jmp done              " EOF or error

check_line:
   " Search for "error" in line
   jms search_pattern
   sza                   " Found?
   jmp found_match

   jmp read_loop         " No match, continue

found_match:
   " Write matching line
   sys write; 1; line_buf; line_len

   " Increment match count
   lac match_count
   tad d1
   dac match_count

   jmp read_loop

done:
   " Print count and exit
   hlt

" ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
" readline: Read one line into line_buf
" Return: AC = line length (or -1 on EOF/error)
" ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
readline: 0
   cla
   dac line_len
   law line_buf-1
   dac 9

rl_loop:
   " Read one character
   sys read; 0; char_buf; 1
   sma
   jmp rl_error
   sza
   jmp rl_got_char
   jmp rl_eof

rl_got_char:
   lac char_buf
   dac 9 i               " Store in line buffer

   " Check for newline
   and o777              " Mask to character
   sad newline
   jmp rl_done           " End of line

   " Continue
   lac line_len
   tad d1
   dac line_len

   " Check buffer full
   lac line_len
   sad d100              " Max line length
   skp
   jmp rl_loop

   " Buffer full
   jmp rl_done

rl_done:
   lac line_len          " Return length
   jmp readline i

rl_eof:
   lac dm1               " Return -1
   jmp readline i

rl_error:
   lac dm1               " Return -1
   jmp readline i

" ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
" search_pattern: Search for "error" in line_buf
" Return: AC = 0 if not found, 1 if found
" ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
search_pattern: 0
   " Simplified: just check if 'e' is in line
   " Real implementation would do substring match

   law line_buf-1
   dac 8

   lac line_len
   dac count

sp_loop:
   lac 8 i
   and o777              " Mask to character
   sad char_e            " Is it 'e'?
   jmp sp_found

   isz count
   jmp sp_loop

   " Not found
   cla
   jmp search_pattern i

sp_found:
   lac d1                " Return 1
   jmp search_pattern i

" Data
line_buf: .=.+100        " Line buffer (max 100 chars)
char_buf: 0              " Single char buffer
line_len: 0
match_count: 0
count: 0
newline: 012
o777: 0777
char_e: 0145             " Character 'e' (octal 145)
d1: 1
d100: 100
dm1: -1</code></pre>
<hr/>
<h2 data-number="3.12" id="debugging-assembly-code"><span class="header-section-number">3.12</span> 11. Debugging Assembly
Code</h2>
<p>Debugging assembly is challenging but systematic. Unix provides the
<code>db.s</code> debugger.</p>
<h3 data-number="3.12.1" id="using-db.s-the-debugger"><span class="header-section-number">3.12.1</span> Using db.s (The
Debugger)</h3>
<p>The PDP-7 Unix debugger allows you to:</p>
<ul>
<li><strong>Examine memory</strong> - Display contents of memory
locations</li>
<li><strong>Set breakpoints</strong> - Stop execution at specific
addresses</li>
<li><strong>Single-step</strong> - Execute one instruction at a
time</li>
<li><strong>Modify memory</strong> - Change values while debugging</li>
<li><strong>Display registers</strong> - Show AC, MQ, Link, PC</li>
</ul>
<p><strong>Basic db commands:</strong></p>
<pre><code>100/          " Display location 100 (octal)
100:value     " Set location 100 to value
AC/           " Display AC
PC/           " Display PC
100;          " Set breakpoint at 100
proceed       " Continue execution
step          " Execute one instruction</code></pre>
<h3 data-number="3.12.2" id="reading-core-dumps"><span class="header-section-number">3.12.2</span> Reading Core Dumps</h3>
<p>When a program crashes, Unix can dump memory to a file:</p>
<pre><code>Core dump structure:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ User data    ‚îÇ  Process state (AC, MQ, etc.)
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Program      ‚îÇ  Code memory
‚îÇ memory       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Data area    ‚îÇ  Variables and buffers
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
<p><strong>Analyzing a crash:</strong></p>
<ol type="1">
<li><strong>Find PC value</strong> - Where did it crash?</li>
<li><strong>Examine instruction</strong> - What was executing?</li>
<li><strong>Check AC, MQ</strong> - What values were involved?</li>
<li><strong>Trace backwards</strong> - What led to this state?</li>
</ol>
<h3 data-number="3.12.3" id="common-assembly-errors"><span class="header-section-number">3.12.3</span> Common Assembly Errors</h3>
<p><strong>1. Uninitialized pointers:</strong></p>
<pre class="assembly"><code>" BUG: pointer not initialized
   lac 8 i           " R8 contains garbage!
                     " Accesses random memory
                     " CRASH or wrong data

" FIX: Initialize pointer
   law array-1
   dac 8             " Now R8 points to array
   lac 8 i           " Correct</code></pre>
<p><strong>2. Infinite loops:</strong></p>
<pre class="assembly"><code>" BUG: Counter never reaches zero
   lac d10           " WRONG: Positive counter
   dac count

loop:
   " ... body ...
   isz count         " Increments: 10 ‚Üí 11 ‚Üí 12 ‚Üí ...
                     " Never reaches 0!
   jmp loop          " INFINITE LOOP

" FIX: Use negative counter
   -10               " Correct: Negative counter
   dac count

loop:
   " ... body ...
   isz count         " -10 ‚Üí -9 ‚Üí ... ‚Üí -1 ‚Üí 0
   jmp loop          " Exits when count = 0</code></pre>
<p><strong>3. Incorrect addressing mode:</strong></p>
<pre class="assembly"><code>" BUG: Forgot indirect
   law array
   dac ptr
   lac ptr           " WRONG: Loads address, not data

" FIX: Use indirect
   lac ptr i         " Correct: Loads data from address in ptr</code></pre>
<p><strong>4. Register clobbering:</strong></p>
<pre class="assembly"><code>" BUG: Subroutine destroys R8
   law array-1
   dac 8             " Setup R8

   jms subr          " Call subroutine
                     " Subroutine uses R8 internally!

   lac 8 i           " WRONG: R8 was changed!

" FIX: Save and restore
subr: 0
   lac 8             " Save R8
   dac saved_r8

   " ... use R8 ...

   lac saved_r8      " Restore R8
   dac 8
   jmp subr i

saved_r8: 0</code></pre>
<p><strong>5. Off-by-one errors:</strong></p>
<pre class="assembly"><code>" BUG: Loop executes wrong number of times
   -10
   dac count

loop:
   " ... body ...

   lac count
   tad d1            " WRONG: Manual increment
   dac count
   sza
   jmp loop          " Executes 11 times! (0-10)

" FIX: Use ISZ correctly
   -10
   dac count

loop:
   " ... body ...

   isz count         " Correct: Executes 10 times
   jmp loop</code></pre>
<p><strong>6. Sign extension issues:</strong></p>
<pre class="assembly"><code>" BUG: Treating negative as positive
   lac value         " value = 777777 (-1)
   tad d1            " Add 1
                     " Result: 0 (correct)

   " But if you compare unsigned:
   lac value         " -1 (appears as 262143 unsigned!)
   sad d100          " Compare to 100
   " Incorrect comparison!

" FIX: Be aware of signed vs unsigned</code></pre>
<h3 data-number="3.12.4" id="debugging-strategies"><span class="header-section-number">3.12.4</span> Debugging Strategies</h3>
<p><strong>1. Add trace points:</strong></p>
<pre class="assembly"><code>" Insert at key points to trace execution

   lac checkpoint1
   tad d1
   dac checkpoint1   " Increment checkpoint counter

" Check checkpoint values in debugger</code></pre>
<p><strong>2. Simplify:</strong></p>
<pre class="assembly"><code>" Instead of complex expression:
   lac array+(index*5)+offset

" Break into steps:
   lac index
   tad index         " √ó2
   tad index         " √ó3
   tad index         " √ó4
   tad index         " √ó5
   dac temp          " Save index√ó5

   law array
   tad temp
   tad offset
   " Now easier to debug step-by-step</code></pre>
<p><strong>3. Instrument code:</strong></p>
<pre class="assembly"><code>" Save intermediate values for inspection

   lac result1
   dac debug1        " Save for debugging

   tad result2
   dac debug2        " Save intermediate sum

   tad result3
   dac final         " Final result

" Examine debug1, debug2 in debugger</code></pre>
<p><strong>4. Test incrementally:</strong></p>
<pre class="assembly"><code>" Test each subroutine separately

start:
   " Test subr1
   jms test_subr1
   hlt

   " Test subr2
   jms test_subr2
   hlt

" Don't test everything at once!</code></pre>
<hr/>
<h2 data-number="3.13" id="practical-tips-and-best-practices"><span class="header-section-number">3.13</span> 12. Practical Tips and Best
Practices</h2>
<h3 data-number="3.13.1" id="code-organization"><span class="header-section-number">3.13.1</span> Code Organization</h3>
<p><strong>Group related code:</strong></p>
<pre class="assembly"><code>" ========================================
" String Utilities
" ========================================

strlen: 0
   " ... implementation ...

strcpy: 0
   " ... implementation ...

strcmp: 0
   " ... implementation ...

" ========================================
" Math Functions
" ========================================

multiply: 0
   " ... implementation ...

divide: 0
   " ... implementation ...</code></pre>
<p><strong>Consistent naming:</strong></p>
<pre class="assembly"><code>" Constants: descriptive names
buffer_size = 64
max_files = 10

" Variables: brief but clear
file_count: 0
current_pos: 0

" Labels: verb or action
process_data:
check_error:
init_table:</code></pre>
<h3 data-number="3.13.2" id="performance-optimization"><span class="header-section-number">3.13.2</span> Performance
Optimization</h3>
<p><strong>Use auto-increment:</strong></p>
<pre class="assembly"><code>" Slow (7 instructions per iteration):
loop:
   lac ptr
   dac temp
   lac temp i
   " ... process ...
   lac ptr
   tad d1
   dac ptr

" Fast (2 instructions per iteration):
loop:
   lac 8 i
   " ... process ...</code></pre>
<p><strong>Minimize memory accesses:</strong></p>
<pre class="assembly"><code>" Slow (loads from memory each time):
loop:
   lac count
   tad d1
   dac count
   lac count
   tad d1
   dac count

" Fast (keep in AC when possible):
loop:
   lac count
   tad d1            " count + 1
   tad d1            " count + 2
   dac count</code></pre>
<p><strong>Use DZM instead of CLA + DAC:</strong></p>
<pre class="assembly"><code>" Slower:
   cla
   dac value

" Faster:
   dzm value</code></pre>
<h3 data-number="3.13.3" id="memory-conservation"><span class="header-section-number">3.13.3</span> Memory Conservation</h3>
<p><strong>Reuse buffers:</strong></p>
<pre class="assembly"><code>" Instead of multiple buffers:
buffer1: .=.+64
buffer2: .=.+64
buffer3: .=.+64      " 192 words!

" Reuse single buffer:
buffer: .=.+64       " 64 words
" Use for different purposes at different times</code></pre>
<p><strong>Pack data:</strong></p>
<pre class="assembly"><code>" Instead of separate flags:
flag1: 0
flag2: 0
flag3: 0
flag4: 0             " 4 words

" Use bit flags:
flags: 0             " 1 word, 18 bits available!
                     " Bit 0 = flag1
                     " Bit 1 = flag2
                     " etc.</code></pre>
<h3 data-number="3.13.4" id="documentation"><span class="header-section-number">3.13.4</span> Documentation</h3>
<p><strong>Comment thoroughly:</strong></p>
<pre class="assembly"><code>" ========================================
" Function: find_max
" Purpose: Find maximum value in array
" Input: Array address in R8, count in 'count'
" Output: Maximum value in AC
" Modifies: AC, R8, temp
" ========================================
find_max: 0
   " Initialize max to first element
   lac 8 i           " Get first element
   dac max           " Save as max so far

   " Loop through remaining elements
   -count
   dac loop_count

fm_loop:
   lac 8 i           " Get next element
   dac current       " Save it

   " Compare with current max
   lac max
   tad neg_current   " max - current
   spa               " Skip if positive or zero (max &gt;= current)
   jmp fm_update     " Current &gt; max, update

   jmp fm_continue   " max &gt;= current, continue

fm_update:
   lac current       " Update max
   dac max

fm_continue:
   isz loop_count    " More elements?
   jmp fm_loop

   lac max           " Return max in AC
   jmp find_max i

max: 0
current: 0
neg_current: 0
loop_count: 0</code></pre>
<hr/>
<h2 data-number="3.14" id="summary"><span class="header-section-number">3.14</span> Summary</h2>
<p>You‚Äôve now learned PDP-7 assembly language from the ground up:</p>
<p><strong>Fundamentals:</strong> - Octal number system and why it‚Äôs
natural for 18-bit words - Basic instructions (LAC, DAC, TAD, CLA) -
Addressing modes (direct, indirect, auto-increment)</p>
<p><strong>Control Flow:</strong> - Conditional execution with skip
instructions - Loops using ISZ and negative counters - Subroutines with
JMS</p>
<p><strong>Data Structures:</strong> - Variables, arrays, structures -
Character strings (packed 2 per word) - Multi-precision arithmetic</p>
<p><strong>Advanced Techniques:</strong> - Bit manipulation and shifting
- Multiplication and division optimizations - Performance tuning</p>
<p><strong>System Integration:</strong> - System calls via
<code>sys</code> pseudo-op - Calling conventions - Error handling</p>
<p><strong>Complete Programs:</strong> - Character counter - File copier
- Line counter - Pattern searcher</p>
<p><strong>Debugging:</strong> - Using <code>db.s</code> debugger -
Common errors and fixes - Debugging strategies</p>
<p>You‚Äôre now ready to read and understand the PDP-7 Unix source code.
The techniques you‚Äôve learned here appear throughout the system‚Äîfrom the
kernel to user utilities.</p>
<p>In the next chapter (Chapter 4), we‚Äôll explore the overall system
architecture, showing how these assembly language programs combine to
create a complete operating system.</p>
<p><strong>Practice exercises:</strong></p>
<ol type="1">
<li>Write a program to reverse an array in place</li>
<li>Implement a substring search function</li>
<li>Create a decimal-to-octal conversion utility</li>
<li>Write a simple calculator (add, subtract, multiply, divide)</li>
<li>Implement a bubble sort algorithm</li>
</ol>
<p>The best way to learn assembly is to write code. Study the Unix
sources, experiment with your own programs, and gradually build your
understanding of this elegant, minimalist system.</p>
<hr/>
<p><em>‚ÄúThe PDP-7 was not a very powerful machine, but it was big enough
to build Unix.‚Äù</em> ‚Äî Ken Thompson</p>
<h1 data-number="4" id="chapter-4---system-architecture-overview"><span class="header-section-number">4</span> Chapter 4 - System Architecture
Overview</h1>
<p>This chapter provides a comprehensive architectural overview of PDP-7
Unix, giving you a mental model of the entire system before diving into
detailed implementation in later chapters. Think of this as a map that
shows how all the pieces fit together‚Äîthe relationships between kernel
modules, the flow of data through the system, and the fundamental data
structures that make it all work.</p>
<h2 data-number="4.1" id="the-big-picture"><span class="header-section-number">4.1</span> 1. The Big Picture</h2>
<p>PDP-7 Unix is remarkably simple compared to modern operating systems,
yet it implements every essential feature: processes, files, devices,
and memory management. The entire kernel consists of approximately 2,500
lines of assembly code organized into nine files.</p>
<h3 data-number="4.1.1" id="system-components-diagram"><span class="header-section-number">4.1.1</span> System Components
Diagram</h3>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         USER SPACE                              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
‚îÇ  ‚îÇ   init   ‚îÇ  ‚îÇ    sh    ‚îÇ  ‚îÇ    ed    ‚îÇ  ‚îÇ   ...    ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ (pid=1)  ‚îÇ  ‚îÇ  (shell) ‚îÇ  ‚îÇ (editor) ‚îÇ  ‚îÇ (other)  ‚îÇ       ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
‚îÇ       ‚îÇ             ‚îÇ             ‚îÇ             ‚îÇ              ‚îÇ
‚îÇ       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îÇ
‚îÇ                          ‚îÇ                                      ‚îÇ
‚îÇ                  System Call Interface                          ‚îÇ
‚îÇ                     (26 calls)                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      KERNEL SPACE                               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚îÇ  System Call Dispatcher (s1.s)                              ‚îÇ
‚îÇ  ‚îÇ  - Entry/exit handling                                      ‚îÇ
‚îÇ  ‚îÇ  - Process context switching                                ‚îÇ
‚îÇ  ‚îÇ  - Swapping control                                         ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ       ‚îÇ                       ‚îÇ                  ‚îÇ             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ File System ‚îÇ   ‚îÇ    Process Mgmt   ‚îÇ   ‚îÇ   Device I/O  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   (s2,s6)   ‚îÇ   ‚îÇ      (s3)         ‚îÇ   ‚îÇ   (s3,s7)     ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ       ‚îÇ                       ‚îÇ                  ‚îÇ             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ           Low-Level Services (s4,s5)                      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  - Memory allocation (alloc/free)                         ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  - Disk I/O (dskrd/dskwr)                                 ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  - Block buffering                                        ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  - Utility functions (copy/betwen)                        ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ       ‚îÇ                                                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ         Data Structures &amp; Constants (s8.s)                ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  - Process table (ulist)                                  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  - System data (sysdata)                                  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  - Manifest constants                                     ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ         Interrupt Handler (s7.s)                          ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  - Clock ticks, keyboard, display, disk, paper tape       ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ         Boot Loader (s9.s)                                ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  - System initialization from cold boot                   ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                       HARDWARE                                  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
‚îÇ  ‚îÇ   CPU    ‚îÇ  ‚îÇ  Memory  ‚îÇ  ‚îÇ   Disk   ‚îÇ  ‚îÇ Devices  ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ  (18bit) ‚îÇ  ‚îÇ  (8K)    ‚îÇ  ‚îÇ(DECtape) ‚îÇ  ‚îÇ (TTY,etc)‚îÇ       ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
<h3 data-number="4.1.2" id="data-flow-example-reading-a-file"><span class="header-section-number">4.1.2</span> Data Flow Example: Reading a
File</h3>
<p>Here‚Äôs how data flows through the system when a user program reads
from a file:</p>
<pre><code>1. User calls:  sys read; fd; buffer; count

2. Hardware trap ‚Üí s1.s entry point (location 020)
   - Save user context (AC, MQ, registers)
   - Set .insys flag
   - Check if system call number is valid

3. Dispatch to .read (s2.s)
   - Validate buffer address and count
   - Call finac to get file descriptor
   - Call fget to retrieve file structure

4. File system layer (s6.s)
   - Call iget to load inode from disk
   - Determine which disk blocks contain data
   - Call pget to get physical block number
   - Call dskrd to read block into buffer

5. Disk I/O layer (s4.s)
   - Check disk buffer cache
   - If not cached, perform physical disk read
   - Call dskio to convert block number to track/sector
   - Call dsktrans to execute disk transfer

6. Copy data to user space
   - Transfer from dskbuf to user buffer
   - Update file position pointer
   - Update file structure

7. Return to user (s1.s: sysexit)
   - Write sysdata back to disk if needed
   - Restore user context
   - Clear .insys flag
   - Return to user space with byte count in AC</code></pre>
<h2 data-number="4.2" id="kernel-organization"><span class="header-section-number">4.2</span> 2. Kernel Organization</h2>
<p>The kernel is organized into nine source files, each with a specific
responsibility. This modular organization made development manageable
even in 1969.</p>
<h3 data-number="4.2.1" id="module-responsibilities"><span class="header-section-number">4.2.1</span> Module Responsibilities</h3>
<table>
<colgroup>
<col style="width: 14%"/>
<col style="width: 12%"/>
<col style="width: 44%"/>
<col style="width: 27%"/>
</colgroup>
<thead>
<tr>
<th>File</th>
<th>Lines</th>
<th>Primary Responsibility</th>
<th>Key Functions</th>
</tr>
</thead>
<tbody>
<tr>
<td>s1.s</td>
<td>193</td>
<td>System call dispatcher</td>
<td>Entry/exit, swap control, dispatch table</td>
</tr>
<tr>
<td>s2.s</td>
<td>328</td>
<td>File operations</td>
<td>open, close, read, write, link, unlink, chmod, chown</td>
</tr>
<tr>
<td>s3.s</td>
<td>347</td>
<td>Process &amp; device I/O</td>
<td>fork, exit, smes/rmes, device handlers (TTY, display)</td>
</tr>
<tr>
<td>s4.s</td>
<td>334</td>
<td>Low-level utilities</td>
<td>alloc, free, copy, betwen, disk I/O, queues</td>
</tr>
<tr>
<td>s5.s</td>
<td>273</td>
<td>Support functions</td>
<td>dskswap, access, fassign, sleep, icreat, display</td>
</tr>
<tr>
<td>s6.s</td>
<td>344</td>
<td>File system core</td>
<td>iget, iput, namei, iread, iwrite, dget, dput</td>
</tr>
<tr>
<td>s7.s</td>
<td>350</td>
<td>Interrupt handler</td>
<td>pibreak, device interrupts, wakeup</td>
</tr>
<tr>
<td>s8.s</td>
<td>208</td>
<td>Data structures</td>
<td>Constants, process table, inode, directory</td>
</tr>
<tr>
<td>s9.s</td>
<td>112</td>
<td>Boot loader</td>
<td>Cold boot, disk initialization, tape loading</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td><strong>2,489</strong></td>
<td><strong>Complete kernel</strong></td>
<td><strong>~200 functions</strong></td>
</tr>
</tbody>
</table>
<h3 data-number="4.2.2" id="detailed-module-descriptions"><span class="header-section-number">4.2.2</span> Detailed Module
Descriptions</h3>
<h4 data-number="4.2.2.1" id="s1.s---system-call-dispatcher-and-kernel-entryexit"><span class="header-section-number">4.2.2.1</span> s1.s - System Call
Dispatcher and Kernel Entry/Exit</h4>
<p>The heart of the kernel. Every system call enters through location
<code>020</code> (octal), which is the system call trap vector. This
file handles:</p>
<ul>
<li><strong>Entry sequence</strong>: Save all user registers to
<code>userdata</code> structure</li>
<li><strong>Validation</strong>: Check system call number is in valid
range (0-26)</li>
<li><strong>Dispatch</strong>: Jump to appropriate handler via
<code>swp</code> table</li>
<li><strong>Swapping</strong>: Decide when to swap processes in/out of
memory</li>
<li><strong>Exit sequence</strong>: Restore user registers and return to
user space</li>
</ul>
<p>Key data structures:</p>
<pre class="assembly"><code>swp:        " System call jump table
   .save; .getuid; .open; .read; .write; .creat; .seek; .tell
   .close; .link; .unlink; .setuid; .rename; .exit; .time; .intrp
   .chdir; .chmod; .chown; badcal; .sysloc; badcal; .capt; .rele
   .status; badcal; .smes; .rmes; .fork</code></pre>
<p>The swap algorithm checks <code>uquant</code> (time quantum) and
calls <code>swap</code> when a process has used its allocation.</p>
<h4 data-number="4.2.2.2" id="s2.s---file-system-system-calls"><span class="header-section-number">4.2.2.2</span> s2.s - File System System
Calls</h4>
<p>Implements the user-facing file system operations. These functions
validate arguments, perform permission checks, and coordinate with s6.s
for actual file system manipulation.</p>
<p>System calls implemented: - <code>.open</code> - Open existing file
for reading/writing - <code>.creat</code> - Create new file -
<code>.close</code> - Close file descriptor - <code>.read</code> - Read
bytes from file - <code>.write</code> - Write bytes to file -
<code>.seek</code> - Position file pointer - <code>.tell</code> - Get
current file position - <code>.link</code> - Create directory link to
file - <code>.unlink</code> - Remove directory entry -
<code>.rename</code> - Change file name - <code>.chmod</code> - Change
file permissions - <code>.chown</code> - Change file owner -
<code>.chdir</code> - Change current directory - <code>.status</code> -
Get file status (proto-stat) - <code>.capt</code> - Capture display
buffer - <code>.rele</code> - Release display buffer</p>
<h4 data-number="4.2.2.3" id="s3.s---process-management-and-device-io"><span class="header-section-number">4.2.2.3</span> s3.s - Process Management
and Device I/O</h4>
<p>Handles process lifecycle and character device I/O:</p>
<p><strong>Process operations:</strong> - <code>.fork</code> - Create
child process (copy-on-write via disk) - <code>.exit</code> - Terminate
process - <code>.smes</code> - Send message to another process -
<code>.rmes</code> - Receive message (blocking)</p>
<p><strong>Device handlers:</strong> -
<code>rttyi</code>/<code>wttyo</code> - Read/write teletype (console) -
<code>rkbdi</code>/<code>wdspo</code> - Read keyboard/write display
(Type 340) - <code>rppti</code>/<code>wppto</code> - Read/write paper
tape punch</p>
<p>The <code>searchu</code> function iterates over the process
table‚Äîused extensively for finding processes by state.</p>
<h4 data-number="4.2.2.4" id="s4.s---low-level-services"><span class="header-section-number">4.2.2.4</span> s4.s - Low-Level
Services</h4>
<p>The utility belt of the kernel. These functions are called by higher
layers:</p>
<p><strong>Memory management:</strong> - <code>alloc</code> - Allocate
disk block from free list - <code>free</code> - Return disk block to
free list</p>
<p><strong>Disk I/O:</strong> - <code>dskrd</code> - Read disk block
into <code>dskbuf</code> - <code>dskwr</code> - Write
<code>dskbuf</code> to disk block - <code>dskio</code> - Convert block
number to track/sector, perform I/O - <code>dsktrans</code> - Low-level
disk transfer (retry on error)</p>
<p><strong>Utilities:</strong> - <code>copy</code> - Copy words from
source to destination - <code>copyz</code> - Zero-fill memory region -
<code>betwen</code> - Check if value is between two bounds -
<code>laci</code> - Load AC indirect (access arrays)</p>
<p><strong>Character queues:</strong> - <code>putchar</code> - Add
character to device queue - <code>getchar</code> - Remove character from
device queue - <code>takeq</code>/<code>putq</code> - Queue
primitives</p>
<p>The disk buffer cache (<code>dskbs</code>, 4 buffers of 64 words
each) reduces redundant disk reads.</p>
<h4 data-number="4.2.2.5" id="s5.s---support-functions"><span class="header-section-number">4.2.2.5</span> s5.s - Support
Functions</h4>
<p>Helper functions that don‚Äôt fit neatly into other categories:</p>
<ul>
<li><code>dskswap</code> - Swap process memory to/from disk</li>
<li><code>access</code> - Check file permissions</li>
<li><code>fassign</code> - Allocate file descriptor</li>
<li><code>fget</code>/<code>fput</code> - Get/put file descriptor
structure</li>
<li><code>forall</code> - Iterate over user buffer (for read/write)</li>
<li><code>sleep</code> - Block process on event</li>
<li><code>dslot</code> - Find empty directory slot</li>
<li><code>icreat</code> - Create new inode</li>
<li><code>dspput</code> - Put character to display</li>
<li><code>dspinit</code> - Initialize display</li>
<li><code>movdsp</code> - Move display buffer</li>
<li><code>arg</code> - Fetch system call argument</li>
<li><code>argname</code> - Fetch filename argument</li>
<li><code>seektell</code> - Common code for seek/tell</li>
<li><code>isown</code> - Check if user owns file</li>
</ul>
<h4 data-number="4.2.2.6" id="s6.s---file-system-implementation"><span class="header-section-number">4.2.2.6</span> s6.s - File System
Implementation</h4>
<p>The core file system logic. These functions manipulate inodes,
directories, and data blocks:</p>
<p><strong>Inode operations:</strong> - <code>iget</code> - Read inode
from disk into memory - <code>iput</code> - Write inode back to disk -
<code>itrunc</code> - Truncate file (free all blocks) -
<code>iread</code> - Read data from inode - <code>iwrite</code> - Write
data to inode</p>
<p><strong>Directory operations:</strong> - <code>namei</code> -
Name-to-inode lookup (like modern <code>namei</code>) -
<code>dget</code> - Read directory entry - <code>dput</code> - Write
directory entry</p>
<p><strong>Block mapping:</strong> - <code>pget</code> - Get physical
block number for logical block - Handles direct blocks (0-6) - Handles
single-indirect blocks (block 0 points to indirect block)</p>
<p>The file system uses a simple but effective structure: - Small files
(‚â§7 blocks): Direct block pointers - Large files (&gt;7 blocks): First
pointer becomes indirect block</p>
<h4 data-number="4.2.2.7" id="s7.s---interrupt-handler"><span class="header-section-number">4.2.2.7</span> s7.s - Interrupt
Handler</h4>
<p>All hardware interrupts vector to <code>pibreak</code> (program
interrupt break). This massive interrupt handler checks every
device:</p>
<p><strong>Devices handled:</strong> - <strong>Disk</strong> (dssf) -
Disk operation complete - <strong>Display</strong> (clsf) - Display
interrupt - <strong>Clock</strong> (lpb) - Line printer buffer (used as
clock) - <strong>Teletype</strong> (ksf/tsf) - Keyboard/printer flags -
<strong>Paper tape</strong> (rsf/psf) - Reader/punch flags -
<strong>Card reader</strong> (crsf) - Card reader flag -
<strong>Dectape</strong> (dpcf) - Tape control</p>
<p>For each interrupt, the handler: 1. Checks device status flag 2.
Reads/writes data if ready 3. Calls <code>wakeup</code> to unblock
waiting processes 4. Updates system time (<code>s.tim</code>) 5.
Increments time quantum (<code>uquant</code>)</p>
<p>The <code>wakeup</code> function scans the process table and marks
processes as ready if they‚Äôre waiting on the specified event.</p>
<h4 data-number="4.2.2.8" id="s8.s---data-structures-and-constants"><span class="header-section-number">4.2.2.8</span> s8.s - Data Structures and
Constants</h4>
<p>The ‚Äúheader file‚Äù of PDP-7 Unix. Contains no executable code, only
declarations:</p>
<p><strong>Manifest constants:</strong></p>
<pre class="assembly"><code>mnproc = 10        " Maximum processes
dspbsz = 270       " Display buffer size
ndskbs = 4         " Number of disk buffers</code></pre>
<p><strong>Constants:</strong> - Decimal: <code>d0</code> through
<code>d10</code>, <code>d33</code>, <code>d65</code>, etc. - Octal:
<code>o7</code>, <code>o12</code>, <code>o17</code>, <code>o20</code>,
etc. - Negative: <code>dm1</code> (-1), <code>dm3</code> (-3)</p>
<p><strong>Data structures:</strong> - <code>userdata</code> -
Per-process user structure (64 words) - <code>ulist</code> - Process
table (10 entries, 4 words each) - <code>inode</code> - In-core inode
(12 words) - <code>dnode</code> - Directory entry (8 words) -
<code>fnode</code> - File descriptor (3 words) - <code>sysdata</code> -
System-wide data (free blocks, time)</p>
<p><strong>Buffers:</strong> - <code>dskbuf</code> - Disk I/O buffer (64
words at location 07700) - <code>dskbs</code> - Disk buffer cache (4√ó65
words) - <code>dspbuf</code> - Display buffer (270 words)</p>
<h4 data-number="4.2.2.9" id="s9.s---boot-loader"><span class="header-section-number">4.2.2.9</span> s9.s - Boot Loader</h4>
<p>Executed only during cold boot. This code:</p>
<ol type="1">
<li><strong>Zeros the inode list</strong> (blocks 2-710)</li>
<li><strong>Builds free block list</strong> (blocks 711-6399)</li>
<li><strong>Reads installation tape</strong>, creating:
<ul>
<li>Inode 1: Root directory</li>
<li>Inode 2: /init program</li>
<li>Inode 3+: System files</li>
</ul></li>
</ol>
<p>The tape format is:</p>
<pre><code>[count] [flags] [nlinks] [word1] [word2] ... [checksum]</code></pre>
<p>After loading all files, it jumps to block 4096 (the /init program),
starting the system.</p>
<h3 data-number="4.2.3" id="why-s1-through-s9"><span class="header-section-number">4.2.3</span> Why s1 through s9?</h3>
<p>The numbering reflects the development order and logical
layering:</p>
<ul>
<li><strong>s1</strong>: First thing written‚Äîmust enter/exit the
kernel</li>
<li><strong>s2-s3</strong>: System calls that users need</li>
<li><strong>s4</strong>: Low-level utilities needed by s2-s3</li>
<li><strong>s5</strong>: Additional support needed</li>
<li><strong>s6</strong>: Complex file system logic</li>
<li><strong>s7</strong>: Interrupt handling (added after basic
functionality worked)</li>
<li><strong>s8</strong>: Data declarations (extracted for clarity)</li>
<li><strong>s9</strong>: Boot loader (written last, runs first)</li>
</ul>
<h2 data-number="4.3" id="system-calls-overview"><span class="header-section-number">4.3</span> 3. System Calls Overview</h2>
<p>PDP-7 Unix implements 26 system calls, organized into three
categories:</p>
<h3 data-number="4.3.1" id="complete-system-call-reference"><span class="header-section-number">4.3.1</span> Complete System Call
Reference</h3>
<h4 data-number="4.3.1.1" id="file-system-calls-15"><span class="header-section-number">4.3.1.1</span> File System Calls (15)</h4>
<table>
<colgroup>
<col style="width: 17%"/>
<col style="width: 12%"/>
<col style="width: 23%"/>
<col style="width: 19%"/>
<col style="width: 27%"/>
</colgroup>
<thead>
<tr>
<th>Number</th>
<th>Name</th>
<th>Arguments</th>
<th>Returns</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>open</td>
<td>filename, mode</td>
<td>fd</td>
<td>Open file for reading (mode=0) or writing (mode=1)</td>
</tr>
<tr>
<td>4</td>
<td>read</td>
<td>fd, buffer, count</td>
<td>nread</td>
<td>Read bytes from file into buffer</td>
</tr>
<tr>
<td>5</td>
<td>write</td>
<td>fd, buffer, count</td>
<td>nwritten</td>
<td>Write bytes from buffer to file</td>
</tr>
<tr>
<td>6</td>
<td>creat</td>
<td>filename, mode</td>
<td>fd</td>
<td>Create new file with permissions</td>
</tr>
<tr>
<td>7</td>
<td>seek</td>
<td>fd, offset, whence</td>
<td>position</td>
<td>Position file pointer</td>
</tr>
<tr>
<td>8</td>
<td>tell</td>
<td>fd, whence</td>
<td>position</td>
<td>Get file position</td>
</tr>
<tr>
<td>9</td>
<td>close</td>
<td>fd</td>
<td>0/-1</td>
<td>Close file descriptor</td>
</tr>
<tr>
<td>10</td>
<td>link</td>
<td>file1, file2, name</td>
<td>0/-1</td>
<td>Create directory link</td>
</tr>
<tr>
<td>11</td>
<td>unlink</td>
<td>filename</td>
<td>0/-1</td>
<td>Remove directory entry</td>
</tr>
<tr>
<td>13</td>
<td>rename</td>
<td>oldname, newname</td>
<td>0/-1</td>
<td>Rename file</td>
</tr>
<tr>
<td>16</td>
<td>chdir</td>
<td>dirname</td>
<td>0/-1</td>
<td>Change current directory</td>
</tr>
<tr>
<td>17</td>
<td>chmod</td>
<td>filename, mode</td>
<td>0/-1</td>
<td>Change file permissions</td>
</tr>
<tr>
<td>18</td>
<td>chown</td>
<td>filename, uid</td>
<td>0/-1</td>
<td>Change file owner</td>
</tr>
<tr>
<td>24</td>
<td>status</td>
<td>filename1, filename2, buffer</td>
<td>0/-1</td>
<td>Get file status into buffer</td>
</tr>
<tr>
<td>27</td>
<td>rmes</td>
<td>-</td>
<td>message</td>
<td>Receive inter-process message (blocking)</td>
</tr>
</tbody>
</table>
<h4 data-number="4.3.1.2" id="process-calls-6"><span class="header-section-number">4.3.1.2</span> Process Calls (6)</h4>
<table>
<thead>
<tr>
<th>Number</th>
<th>Name</th>
<th>Arguments</th>
<th>Returns</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>save</td>
<td>-</td>
<td>-</td>
<td>Save process state to inode 1</td>
</tr>
<tr>
<td>1</td>
<td>getuid</td>
<td>-</td>
<td>uid</td>
<td>Get user ID (negative = superuser)</td>
</tr>
<tr>
<td>12</td>
<td>setuid</td>
<td>uid</td>
<td>0/-1</td>
<td>Set user ID (superuser only)</td>
</tr>
<tr>
<td>14</td>
<td>exit</td>
<td>-</td>
<td>-</td>
<td>Terminate process (never returns)</td>
</tr>
<tr>
<td>26</td>
<td>smes</td>
<td>pid, msg</td>
<td>0/-1</td>
<td>Send message to process</td>
</tr>
<tr>
<td>28</td>
<td>fork</td>
<td>-</td>
<td>pid</td>
<td>Create child process</td>
</tr>
</tbody>
</table>
<h4 data-number="4.3.1.3" id="system-calls-5"><span class="header-section-number">4.3.1.3</span> System Calls (5)</h4>
<table>
<colgroup>
<col style="width: 17%"/>
<col style="width: 12%"/>
<col style="width: 23%"/>
<col style="width: 19%"/>
<col style="width: 27%"/>
</colgroup>
<thead>
<tr>
<th>Number</th>
<th>Name</th>
<th>Arguments</th>
<th>Returns</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
<td>time</td>
<td>-</td>
<td>time (AC+MQ)</td>
<td>Get system time (36-bit value)</td>
</tr>
<tr>
<td>20</td>
<td>sysloc</td>
<td>symbol</td>
<td>address</td>
<td>Get kernel symbol address (for debugging)</td>
</tr>
<tr>
<td>22</td>
<td>capt</td>
<td>buffer</td>
<td>0/-1</td>
<td>Capture display output to buffer</td>
</tr>
<tr>
<td>23</td>
<td>rele</td>
<td>-</td>
<td>0/-1</td>
<td>Release display buffer</td>
</tr>
<tr>
<td>21</td>
<td>intrp</td>
<td>flag</td>
<td>0/-1</td>
<td>Set interrupt flag</td>
</tr>
</tbody>
</table>
<h3 data-number="4.3.2" id="system-call-categories"><span class="header-section-number">4.3.2</span> System Call Categories</h3>
<p><strong>File-oriented calls:</strong> - Basic I/O: <code>open</code>,
<code>read</code>, <code>write</code>, <code>close</code>,
<code>creat</code> - File positioning: <code>seek</code>,
<code>tell</code> - Directory operations: <code>link</code>,
<code>unlink</code>, <code>rename</code>, <code>chdir</code> - Metadata:
<code>chmod</code>, <code>chown</code>, <code>status</code></p>
<p><strong>Process-oriented calls:</strong> - Lifecycle:
<code>fork</code>, <code>exit</code>, <code>save</code> - Identity:
<code>getuid</code>, <code>setuid</code> - IPC: <code>smes</code>,
<code>rmes</code> (message passing)</p>
<p><strong>System-oriented calls:</strong> - Time: <code>time</code> -
Display: <code>capt</code>, <code>rele</code> - Debugging:
<code>sysloc</code>, <code>intrp</code></p>
<h3 data-number="4.3.3" id="calling-convention"><span class="header-section-number">4.3.3</span> Calling Convention</h3>
<p>All system calls use the same interface:</p>
<pre class="assembly"><code>" Pattern:
sys &lt;number&gt;
arg1
arg2
...

" Example: Read from file descriptor 3
sys read; 3; buffer; count</code></pre>
<p>The <code>sys</code> macro generates:</p>
<pre class="assembly"><code>jms 020         " Jump to system call entry point
&lt;number&gt;        " System call number</code></pre>
<p>Arguments immediately follow the system call number. The kernel‚Äôs
<code>arg</code> function fetches them:</p>
<pre class="assembly"><code>arg: 0
   lac u.rq+8 i     " Load argument
   isz u.rq+8       " Increment return address
   jmp arg i</code></pre>
<h2 data-number="4.4" id="file-system-architecture"><span class="header-section-number">4.4</span> 4. File System
Architecture</h2>
<p>The PDP-7 Unix file system is the conceptual ancestor of all Unix
file systems. It introduced the inode concept and hierarchical
directories.</p>
<h3 data-number="4.4.1" id="high-level-design"><span class="header-section-number">4.4.1</span> High-Level Design</h3>
<p><strong>Three-level structure:</strong></p>
<ol type="1">
<li><strong>Superblock</strong> (block 1) - System-wide information</li>
<li><strong>Inode list</strong> (blocks 2-710) - File metadata</li>
<li><strong>Data blocks</strong> (blocks 711-6399) - File contents and
directories</li>
</ol>
<p><strong>Key innovations:</strong> - Inodes separate from directories
- Directory entries are just (name, inode number) pairs - Small files
use direct pointers, large files use indirect blocks - Free block list
managed in-memory with overflow to disk</p>
<h3 data-number="4.4.2" id="disk-layout"><span class="header-section-number">4.4.2</span> Disk Layout</h3>
<pre><code>Block Range  | Usage              | Description
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
0-1          | Boot &amp; System      | Block 0: unused
             |                    | Block 1: superblock (sysdata)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2-710        | Inode List         | 709 blocks √ó 5 inodes/block = 3,545 inodes
             | (709 blocks)       | Each inode is 12 words
             |                    | Inode 0: unused
             |                    | Inode 1: root directory "/"
             |                    | Inode 2: /init
             |                    | Inode 3+: other files
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
711-6399     | Data Blocks        | 5,689 blocks for file data and directories
             | (5,689 blocks)     | Each block is 64 words (128 bytes)
             |                    |
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Total: 6,400 blocks √ó 64 words √ó 2 bytes = 819,200 bytes ‚âà 800 KB</code></pre>
<h3 data-number="4.4.3" id="inode-structure"><span class="header-section-number">4.4.3</span> Inode Structure</h3>
<p>The inode (index node) stores all file metadata:</p>
<pre class="assembly"><code>" inode structure (12 words)
inode:
   i.flags:  .=.+1    " File type and permissions
   i.dskps:  .=.+7    " Disk block pointers (7 blocks)
   i.uid:    .=.+1    " Owner user ID
   i.nlks:   .=.+1    " Number of directory links
   i.size:   .=.+1    " File size in words
   i.uniq:   .=.+1    " Unique ID (for cache coherency)</code></pre>
<p><strong>i.flags format (18 bits):</strong></p>
<pre><code>Bit 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
    ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ Permissions (15 bits)
    ‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Reserved
    ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Directory (1=dir, 0=file)
    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Character device
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Large file (indirect)

Permissions:
  Bits 0-2:   Owner permissions (read=4, write=2, execute=1)
  Bits 3-5:   Group permissions (same)
  Bits 6-8:   Other permissions (same)
  Bits 9-14:  Reserved for future use</code></pre>
<p><strong>i.dskps block pointers:</strong> - <strong>Small
files</strong> (‚â§7 blocks): Each word is a direct block number -
<strong>Large files</strong> (&gt;7 blocks): - i.dskps[0] points to
indirect block - Indirect block contains up to 64 data block pointers -
Maximum file size: 64 blocks √ó 64 words = 4,096 words</p>
<h3 data-number="4.4.4" id="directory-structure"><span class="header-section-number">4.4.4</span> Directory Structure</h3>
<p>Directories are special files (i.flags bit 4 set) containing
directory entries:</p>
<pre class="assembly"><code>" Directory entry structure (8 words)
dnode:
   d.i:     .=.+1    " Inode number
   d.name:  .=.+4    " Filename (4 words = 6 chars max)
   d.uniq:  .=.+1    " Unique ID (must match inode)
   .=.+2             " Padding to 8 words</code></pre>
<p><strong>Filename encoding:</strong> - PDP-7 stores 2 characters per
word (9 bits each) - 4 words = 8 characters, but only 6 used (2 words
for padding) - Characters are 9-bit ASCII (not 7-bit)</p>
<p><strong>Example directory:</strong></p>
<pre><code>Inode  Name         Uniq
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ
  1    "."          0001   " Current directory (root)
  1    ".."         0001   " Parent directory (also root)
  2    "init"       0002   " /init program
  3    "sh"         0003   " Shell
  4    "ed"         0004   " Editor
  0    (free slot)  0000   " Deleted entry</code></pre>
<p>The <code>namei</code> (name-to-inode) function walks directories: 1.
Start with current directory inode 2. Read directory data blocks 3.
Compare each d.name with target name 4. If match found, return d.i
(inode number) 5. Verify d.uniq matches i.uniq (prevents stale
references)</p>
<h3 data-number="4.4.5" id="free-block-management"><span class="header-section-number">4.4.5</span> Free Block Management</h3>
<p>The free list is managed with a clever two-level structure:</p>
<p><strong>In-memory portion (sysdata):</strong></p>
<pre class="assembly"><code>sysdata:
   s.nxfblk: .=.+1   " Next free block overflow list
   s.nfblks: .=.+1   " Number of free blocks in memory
   s.fblks:  .=.+10  " Free block numbers (up to 10)
   s.uniq:   .=.+1   " Unique ID counter
   s.tim:    .=.+2   " System time (36 bits)</code></pre>
<p><strong>Free block algorithm:</strong></p>
<p>When allocating a block (<code>alloc</code>):</p>
<pre><code>1. If s.nfblks &gt; 0:
   - Decrement s.nfblks
   - Return s.fblks[s.nfblks]
2. Else if s.nxfblk ‚â† 0:
   - Read s.nxfblk block into dskbuf
   - Copy 10 block numbers to s.fblks
   - Set s.nxfblk = dskbuf[0]
   - Set s.nfblks = 10
   - Go to step 1
3. Else:
   - Halt: "OUT OF DISK"</code></pre>
<p>When freeing a block (<code>free</code>):</p>
<pre><code>1. If s.nfblks &lt; 10:
   - s.fblks[s.nfblks] = block
   - Increment s.nfblks
2. Else:
   - dskbuf[0] = s.nxfblk
   - Copy s.fblks[1..10] to dskbuf[1..10]
   - Write dskbuf to block
   - Set s.nxfblk = block
   - Set s.nfblks = 1</code></pre>
<p>This design: - Keeps common case (allocate/free) fast (no disk I/O) -
Handles overflow elegantly (linked list on disk) - Requires only 14
words of memory for free list</p>
<h3 data-number="4.4.6" id="example-storing-a-200-word-file"><span class="header-section-number">4.4.6</span> Example: Storing a 200-Word
File</h3>
<p>Let‚Äôs trace how a 200-word file ‚Äúhello.txt‚Äù is stored:</p>
<p><strong>Step 1: Create file</strong></p>
<pre class="assembly"><code>sys creat; filename; 0010   " Create with rw------- permissions</code></pre>
<p><strong>Step 2: Find empty inode</strong> - <code>icreat</code> scans
inodes starting at 20 (octal) - Finds empty inode (i.flags &lt; 0), say
inode 42</p>
<p><strong>Step 3: Initialize inode 42</strong></p>
<pre><code>i.flags:  040010     " Regular file, rw-------
i.dskps:  0 0 0 0 0 0 0   " No blocks allocated yet
i.uid:    1          " Owner UID
i.nlks:   -1         " One link (stored as -1)
i.size:   0          " Empty file
i.uniq:   137        " Unique ID from s.uniq</code></pre>
<p><strong>Step 4: Add directory entry</strong> - Find empty slot in
current directory - Create entry: (42, ‚Äúhello.txt‚Äù, 137)</p>
<p><strong>Step 5: Write 200 words</strong></p>
<pre class="assembly"><code>sys write; fd; buffer; 200   " fd was returned by creat</code></pre>
<ul>
<li>200 words requires 4 blocks (64+64+64+8)</li>
<li><code>alloc</code> called 4 times, returns blocks: 5123, 5124, 5125,
5126</li>
</ul>
<p><strong>Step 6: Update inode 42</strong></p>
<pre><code>i.flags:  040010
i.dskps:  5123 5124 5125 5126 0 0 0
i.uid:    1
i.nlks:   -1
i.size:   200        " Updated
i.uniq:   137</code></pre>
<p><strong>Disk usage:</strong> - Inode: 12 words in inode list - Data:
4 blocks √ó 64 words = 256 words (56 unused) - Directory entry: 8 words
in parent directory - Total overhead: 20 words + 56 unused = 76 words
(38% overhead for small files)</p>
<h2 data-number="4.5" id="process-model"><span class="header-section-number">4.5</span> 5. Process Model</h2>
<p>The process model is extremely simple: no virtual memory, no
copy-on-write in memory. Processes are swapped between memory and
disk.</p>
<h3 data-number="4.5.1" id="process-table-structure"><span class="header-section-number">4.5.1</span> Process Table Structure</h3>
<p>The process table (<code>ulist</code>) holds 10 process slots:</p>
<pre class="assembly"><code>" ulist - 10 processes √ó 4 words each = 40 words
ulist:
   0131000;1;0;0      " Process 0 (init)
   0031040;0;0;0      " Process 1 (free)
   0031100;0;0;0      " Process 2 (free)
   ...
   0031440;0;0;0      " Process 9 (free)</code></pre>
<p><strong>Each 4-word entry format:</strong></p>
<pre><code>Word 0: Process state and pointer
  Bits 17-15: State
    000 = Free (not used)
    001 = In memory, ready to run
    010 = Out of memory (swapped), not ready
    011 = Out of memory (swapped), ready
    100 = In memory, not ready (sleeping)
  Bits 14-0: Pointer to userdata structure

Word 1: Process ID (PID)

Word 2: Parent PID (or message source PID for rmes)

Word 3: Message data (for smes/rmes IPC)</code></pre>
<h3 data-number="4.5.2" id="user-data-structure"><span class="header-section-number">4.5.2</span> User Data Structure</h3>
<p>Each process has a 64-word <code>userdata</code> structure that holds
its complete state:</p>
<pre class="assembly"><code>userdata:
   u.ac:      0              " Saved accumulator
   u.mq:      0              " Saved MQ register
   u.rq:      .=.+9          " Saved registers 8,9,10-15
   u.uid:     -1             " User ID (-1 = superuser)
   u.pid:     1              " Process ID
   u.cdir:    3              " Current directory inode
   u.ulistp:  ulist          " Pointer to ulist entry
   u.swapret: 0              " Return address after swap
   u.base:    0              " System call work area
   u.count:   0              " System call work area
   u.limit:   0              " System call work area
   u.ofiles:  .=.+30         " Open file table (10 files √ó 3 words)
   u.dspbuf:  0              " Display buffer pointer
   u.intflg:  1              " Interrupt flag
   .=userdata+64</code></pre>
<p><strong>u.ofiles file descriptor table:</strong> - 10 file
descriptors maximum per process - Each descriptor is 3 words:
<code>f.flags: Access mode (0=read, 1=write) and valid bit   f.badd:  Current position in file   f.i:     Inode number</code></p>
<h3 data-number="4.5.3" id="process-states"><span class="header-section-number">4.5.3</span> Process States</h3>
<p>The state machine is simple but effective:</p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                                                             ‚îÇ
‚îÇ   START (fork)                                              ‚îÇ
‚îÇ      ‚îÇ                                                      ‚îÇ
‚îÇ      ‚ñº                                                      ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  quantum expired    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ   ‚îÇ  In Memory   ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ&gt; ‚îÇ Out, Ready   ‚îÇ    ‚îÇ
‚îÇ   ‚îÇ    Ready     ‚îÇ                     ‚îÇ  (swapped)   ‚îÇ    ‚îÇ
‚îÇ   ‚îÇ   (state 1)  ‚îÇ &lt;‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚îÇ  (state 3)   ‚îÇ    ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  swap in            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ          ‚îÇ                                                  ‚îÇ
‚îÇ          ‚îÇ sleep()                                          ‚îÇ
‚îÇ          ‚ñº                                                  ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  quantum expired    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ   ‚îÇ  In Memory   ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ&gt; ‚îÇOut, Not Ready‚îÇ    ‚îÇ
‚îÇ   ‚îÇ  Not Ready   ‚îÇ                     ‚îÇ  (swapped)   ‚îÇ    ‚îÇ
‚îÇ   ‚îÇ  (state 4)   ‚îÇ &lt;‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚îÇ  (state 2)   ‚îÇ    ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  swap in            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ          ‚îÇ             ‚ñ≤                       ‚îÇ            ‚îÇ
‚îÇ          ‚îÇ wakeup()    ‚îÇ sleep()               ‚îÇ            ‚îÇ
‚îÇ          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                       ‚îÇ            ‚îÇ
‚îÇ                                                ‚îÇ            ‚îÇ
‚îÇ                                     wakeup()   ‚îÇ            ‚îÇ
‚îÇ                                      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ
‚îÇ                                      ‚îÇ                      ‚îÇ
‚îÇ                                      ‚ñº                      ‚îÇ
‚îÇ                               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê             ‚îÇ
‚îÇ                               ‚îÇOut, Ready    ‚îÇ             ‚îÇ
‚îÇ                               ‚îÇ(swapped)     ‚îÇ             ‚îÇ
‚îÇ                               ‚îÇ(state 3)     ‚îÇ             ‚îÇ
‚îÇ                               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ                                 exit()                      ‚îÇ
‚îÇ                                   ‚îÇ                         ‚îÇ
‚îÇ                                   ‚ñº                         ‚îÇ
‚îÇ                                 FREE                        ‚îÇ
‚îÇ                              (state 0)                      ‚îÇ
‚îÇ                                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
<h3 data-number="4.5.4" id="swapping-mechanism"><span class="header-section-number">4.5.4</span> Swapping Mechanism</h3>
<p>PDP-7 Unix uses <strong>swapping</strong> (not paging) because: -
Limited memory (8K words) - Only one process runs at a time - No memory
protection hardware</p>
<p><strong>Swap algorithm:</strong></p>
<ol type="1">
<li><p><strong>When to swap:</strong> Determined by <code>swap</code>
routine called from system call entry</p>
<ul>
<li>Check if a process is ‚Äúout, ready‚Äù (state 3) ‚Üí swap it in</li>
<li>Current process exhausted quantum ‚Üí swap it out</li>
</ul></li>
<li><p><strong>Swap out:</strong></p>
<pre class="assembly"><code>- Set process state to "out, not ready" (state 2) or "out, ready" (state 3)
- Call dskswap with mode 07000 (write)
- Write userdata (64 words) to disk
- Write user memory (4096 words) to disk
- Total: 4160 words swapped out</code></pre></li>
<li><p><strong>Swap in:</strong></p>
<pre class="assembly"><code>- Call dskswap with mode 06000 (read)
- Read userdata (64 words) from disk
- Read user memory (4096 words) from disk
- Set process state to "in, ready" (state 1)
- Jump to u.swapret (resume execution)</code></pre></li>
</ol>
<p><strong>Swap location on disk:</strong> Each process has a dedicated
swap area:</p>
<pre><code>Process 0: blocks 0√ó020 = 0      (userdata) + 0√ó020+020 = 020   (memory)
Process 1: blocks 1√ó020 = 020    (userdata) + 1√ó020+020 = 0140  (memory)
Process 2: blocks 2√ó020 = 0140   (userdata) + 2√ó020+020 = 0260  (memory)
...
Process 9: blocks 9√ó020 = 01120  (userdata) + 9√ó020+020 = 01340 (memory)</code></pre>
<p>Each process reserves 020 (octal) = 16 blocks = 1024 words: - 64
words for userdata - 4096 words for user memory - Total: 4160 words
(requires 65 blocks, but allocated 64‚Äîbug or compression?)</p>
<h3 data-number="4.5.5" id="process-lifecycle"><span class="header-section-number">4.5.5</span> Process Lifecycle</h3>
<p><strong>1. fork() - Process Creation</strong></p>
<pre class="assembly"><code>.fork:
   jms lookfor; 0          " Find free process slot
      skp
      jms error
   dac 9f+t                " Save slot pointer
   isz uniqpid             " Generate unique PID
   lac uniqpid
   dac u.ac                " Child gets new PID in AC

   " Mark current process as "out, ready"
   lac o200000
   tad u.ulistp i
   dac u.ulistp i

   " Swap current process to disk
   jms dskswap; 07000      " Write to disk

   " Initialize child process entry
   lac 9f+t
   dac u.ulistp            " Point to child slot
   lac o100000
   xor u.ulistp i
   dac u.ulistp i          " Set child state to "in, not ready"

   " Set up child's PID and return value
   lac u.pid
   dac u.ac                " Parent returns child's PID
   lac uniqpid
   dac u.pid               " Child's PID

   " Child returns here after swap
   dzm u.intflg
   jmp sysexit</code></pre>
<p><strong>Key insight:</strong> fork() in PDP-7 Unix: - Parent: Returns
child PID, swapped out to disk - Child: Returns parent PID (in u.ac),
immediately swapped out - No memory copying in RAM‚Äîdisk is the
‚Äúcopy‚Äù</p>
<p><strong>2. exit() - Process Termination</strong></p>
<pre class="assembly"><code>.exit:
   lac u.dspbuf
   sna
   jmp .+3
   law dspbuf
   jms movdsp              " Release display if captured

   jms awake               " Wake parent (for wait())

   lac u.ulistp i
   and o77777              " Clear state bits
   dac u.ulistp i          " Mark as free (state 0)

   isz u.ulistp
   dzm u.ulistp i          " Clear PID

   jms swap                " Swap to another process (never returns)</code></pre>
<p>Process termination: - Releases resources (display buffer) - Marks
slot as free - Never returns (swaps to another process)</p>
<p><strong>3. sleep() and wakeup() - Process
Synchronization</strong></p>
<pre class="assembly"><code>sleep: 0
   " Mark current process as waiting on event
   lac o200000             " "out" bit
   lmq

   " Find self in ulist
   law ulist-1
   dac 8
1: lac u.ulistp i
   sad 8 i
   jmp 1f
   " Next entry...
   jmp 1b

1: tad o100000            " "not ready" bit
   dac u.ulistp i         " Mark as "in, not ready"

   lac sleep i            " Get event address
   dac 9f+t
   lac 9f+t i             " OR in wait bit
   omq
   dac 9f+t i

   isz sleep
   jmp sleep i</code></pre>
<pre class="assembly"><code>wakeup: 0
   dac 9f+t               " Event address

   " Scan all processes
   -mnproc
   dac 9f+t+1

1: lac 9f+t
   ral                    " Rotate wait bits
   dac 9f+t
   sma                    " Check if waiting
   jmp 2f+2               " Not waiting, skip

   lac o700000            " Clear wait bits
2: tad ..                 " Modify ulist entry
   dac ..

   " Next process...
   isz 9f+t+1
   jmp 1b

   cla
   jmp wakeup i</code></pre>
<p>The wait/wakeup mechanism: - Each event has an address (like
<code>sfiles+1</code> for TTY output) - <code>sleep</code> sets a bit in
that address corresponding to process number - <code>wakeup</code>
clears that bit and marks process ready - Interrupt handler calls
<code>wakeup</code> when devices become ready</p>
<h2 data-number="4.6" id="memory-map-1"><span class="header-section-number">4.6</span> 6. Memory Map</h2>
<p>The PDP-7 has only 8K words (16 KB) of memory. Every word counts.</p>
<h3 data-number="4.6.1" id="complete-memory-layout"><span class="header-section-number">4.6.1</span> Complete Memory Layout</h3>
<pre><code>Address   | Region            | Size    | Description
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
00000     | Reserved          | 1 word  | Location 0: used by halt
00001-017 | Reserved          | 15 words| Unused
00020     | Syscall trap      | 1 word  | System call entry point
00021-077 | Reserved          | 47 words| Trap vectors
00100     | Kernel code start | ~2500   | s1.s through s9.s
          |                   | words   | All kernel code
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
~03000    | Kernel data       | ~500    | Process table, system data
          |                   | words   | buffers, variables
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
04000     | User memory start | 4096    | User program code and data
          | (decimal 2048)    | words   | (Swapped in/out by kernel)
          |                   |         |
          |                   |         | User programs run here
          |                   |         |
07677     | User memory end   |         |
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
07700     | dskbuf            | 64 words| Disk I/O buffer
07764     | dskbs[]           | 260 wds | Disk buffer cache (4√ó65)
10244     | Kernel stack      | varies  | Grows downward
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
17777     | End of memory     | (8K)    | Last address
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</code></pre>
<h3 data-number="4.6.2" id="kernel-memory-organization"><span class="header-section-number">4.6.2</span> Kernel Memory
Organization</h3>
<p><strong>Low memory (00000-00077):</strong> - Hardware-defined trap
vectors - Location 020: System call entry (modified by kernel)</p>
<p><strong>Kernel code (00100-~03000):</strong></p>
<pre><code>00100: coldentry           " Cold boot entry (s9.s)
00102: jms halt            " Halt on error
...
       s1.s code           " System dispatcher
       s2.s code           " File system calls
       s3.s code           " Process/device code
       s4.s code           " Utilities
       s5.s code           " Support functions
       s6.s code           " File system core
       s7.s code           " Interrupt handler</code></pre>
<p><strong>Kernel data (~03000-03777):</strong></p>
<pre><code>sysdata:                   " System-wide data (14 words)
   s.nxfblk, s.nfblks, s.fblks[10], s.uniq, s.tim[2]

ulist:                     " Process table (40 words)
   10 entries √ó 4 words

userdata:                  " Current process state (64 words)
   u.ac, u.mq, u.rq[9], u.uid, u.pid, u.cdir, ...
   u.ofiles[30]           " 10 file descriptors √ó 3 words

inode:                     " In-core inode (12 words)
dnode:                     " Directory entry buffer (8 words)
fnode:                     " File descriptor buffer (3 words)

sfiles[10]:                " Device wait queues
dspbuf[270]:               " Display buffer
q2[50√ó2]:                  " Character queues (50 entries)</code></pre>
<h3 data-number="4.6.3" id="user-memory-layout"><span class="header-section-number">4.6.3</span> User Memory Layout</h3>
<p>User programs have exactly 4096 words (04000-07677):</p>
<pre><code>04000    Start of user program
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ  Program code (.text)           ‚îÇ
         ‚îÇ  - Loaded from inode            ‚îÇ
         ‚îÇ  - Executable instructions      ‚îÇ
         ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
         ‚îÇ  Initialized data (.data)       ‚îÇ
         ‚îÇ  - Global variables             ‚îÇ
         ‚îÇ  - String constants             ‚îÇ
         ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
         ‚îÇ  Uninitialized data (.bss)      ‚îÇ
         ‚îÇ  - Zeroed by loader             ‚îÇ
         ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
         ‚îÇ  Heap (grows upward)            ‚îÇ
         ‚îÇ  ‚Üì                              ‚îÇ
         ‚îÇ  ...                            ‚îÇ
         ‚îÇ  ‚Üë                              ‚îÇ
         ‚îÇ  Stack (grows downward)         ‚îÇ
         ‚îÇ  - Return addresses             ‚îÇ
         ‚îÇ  - Local variables              ‚îÇ
         ‚îÇ  - Function arguments           ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
07677    End of user memory</code></pre>
<p><strong>No memory protection!</strong> - User programs can access
kernel memory - Crashes affect entire system - Trust-based security
model</p>
<h3 data-number="4.6.4" id="special-memory-locations-1"><span class="header-section-number">4.6.4</span> Special Memory Locations</h3>
<p>Certain memory locations have special meaning:</p>
<pre class="assembly"><code>Location  | Symbol    | Purpose
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
0         | (none)    | Used by halt: stores LAW instruction
1-7       | (various) | Temporary storage, scratch registers
8-9       | -         | Index registers (loop counters, pointers)
10-15     | -         | User registers (saved in u.rq)
020       | -         | System call trap vector (kernel modifies)
021       | -         | Return address from trap</code></pre>
<p><strong>Register conventions:</strong> - <strong>AC</strong>:
Accumulator (main working register) - <strong>MQ</strong>:
Multiplier-quotient (second working register) - <strong>8-9</strong>:
Kernel index registers (for loops, array access) -
<strong>10-15</strong>: User program registers (preserved across
syscalls)</p>
<h3 data-number="4.6.5" id="memory-usage-analysis"><span class="header-section-number">4.6.5</span> Memory Usage Analysis</h3>
<p>For a typical running system:</p>
<pre><code>Component              | Words  | Percentage
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Kernel code            | ~2,500 | 31%
Kernel data            | ~1,000 | 12%
User program (in core) |  4,096 | 50%
Disk buffers           |    324 | 4%
Kernel stack           |    ~80 | 1%
Unused/fragmented      |   ~200 | 2%
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Total                  |  8,192 | 100%</code></pre>
<p><strong>Memory pressure:</strong> - Only ONE user process can be in
memory at a time - Swapping is mandatory for multitasking - Disk
bandwidth is the limiting factor - Typical swap time: ~500ms (depends on
disk position)</p>
<h2 data-number="4.7" id="device-io-architecture"><span class="header-section-number">4.7</span> 7. Device I/O Architecture</h2>
<p>PDP-7 Unix manages seven device types through a unified
character-oriented interface.</p>
<h3 data-number="4.7.1" id="device-list"><span class="header-section-number">4.7.1</span> Device List</h3>
<table>
<thead>
<tr>
<th>Device</th>
<th>Input</th>
<th>Output</th>
<th>Buffer</th>
<th>Type</th>
<th>Speed</th>
</tr>
</thead>
<tbody>
<tr>
<td>TTY</td>
<td>KSF/KRB</td>
<td>TSF/TLS</td>
<td>Queue</td>
<td>Character</td>
<td>10 chars/sec</td>
</tr>
<tr>
<td>Keyboard</td>
<td>(KBD)</td>
<td>-</td>
<td>Queue</td>
<td>Character</td>
<td>Typed input</td>
</tr>
<tr>
<td>Display</td>
<td>-</td>
<td>CDF/BEG</td>
<td>Direct</td>
<td>Block</td>
<td>60 Hz refresh</td>
</tr>
<tr>
<td>Paper tape</td>
<td>RSF/RRB</td>
<td>PSF/PSA</td>
<td>Queue</td>
<td>Character</td>
<td>300 chars/sec</td>
</tr>
<tr>
<td>Disk</td>
<td>DSSF</td>
<td>DSSF</td>
<td>Buffer</td>
<td>Block</td>
<td>~40 KB/sec</td>
</tr>
<tr>
<td>Line clock</td>
<td>LPB</td>
<td>-</td>
<td>None</td>
<td>Special</td>
<td>60 Hz</td>
</tr>
<tr>
<td>Card reader</td>
<td>CRSF</td>
<td>-</td>
<td>Queue</td>
<td>Character</td>
<td>Rare</td>
</tr>
</tbody>
</table>
<h3 data-number="4.7.2" id="character-vs.-block-devices"><span class="header-section-number">4.7.2</span> Character vs.¬†Block
Devices</h3>
<p><strong>Character devices</strong> (TTY, keyboard, paper tape): - One
character at a time - Managed by character queues (q2 structure) -
Interrupt-driven - Buffering in kernel space</p>
<p><strong>Block devices</strong> (disk, display): - Fixed-size blocks
(64 words for disk) - DMA (Direct Memory Access) transfers - Buffering
with cache (disk) or direct (display)</p>
<h3 data-number="4.7.3" id="character-queue-implementation"><span class="header-section-number">4.7.3</span> Character Queue
Implementation</h3>
<p>The <code>q2</code> structure implements circular linked lists for
character buffering:</p>
<pre class="assembly"><code>" Queue structure (50 entries)
q2:
   .+2;0;.+2;0;.+2;0; ...    " Linked list nodes

" Each queue entry:
"   word 0: pointer to next entry (or 0 for end)
"   word 1: character data

" Queue header (in device sfiles entry):
"   q1: pointer to first entry (head)
"   q1+1: pointer to last entry (tail)</code></pre>
<p><strong>Queue operations:</strong></p>
<p><code>putq</code>: Add character to queue tail</p>
<pre class="assembly"><code>putq: 0
   " Allocate free queue entry
   " Link to tail (or make new head)
   " Store character
   jmp putq i</code></pre>
<p><code>takeq</code>: Remove character from queue head</p>
<pre class="assembly"><code>takeq: 0
   " Check if queue empty
   " Remove head entry
   " Update head pointer
   " Return character
   jmp takeq i</code></pre>
<p><code>putchar</code>: High-level put (allocates from free pool)
<code>getchar</code>: High-level get (returns to free pool)</p>
<h3 data-number="4.7.4" id="buffering-strategy"><span class="header-section-number">4.7.4</span> Buffering Strategy</h3>
<p><strong>Why buffering matters:</strong> - Devices operate at
different speeds - CPU is much faster than I/O - Buffering allows
asynchronous operation</p>
<p><strong>Disk buffer cache (dskbs):</strong></p>
<pre class="assembly"><code>" Four 64-word buffers
dskbs: .=.+65+65+65+65     " 260 words total</code></pre>
<p>Each buffer tracks: - Block number (in first word) - 64 words of
data</p>
<p><strong>Cache algorithm (in dskrd):</strong></p>
<pre class="assembly"><code>dskrd: 0
   " Check if block already in cache
   jms srcdbs               " Search disk buffers
      jmp 1f                " Not found
   " Found - copy from cache
   jms copy; buffer; dskbuf; 64
   jmp 2f

1: " Not found - read from disk
   jms dskio; 06000         " Physical disk read

2: " Update cache (collapse oldest)
   jms collapse
   jmp dskrd i</code></pre>
<p>The <code>collapse</code> routine implements a simple LRU-like
policy: - Recent reads stay in cache - Oldest buffer is overwritten</p>
<p><strong>Display buffering:</strong> - Direct buffer at
<code>dspbuf</code> (270 words) - Written directly to display hardware -
Process can ‚Äúcapture‚Äù display with <code>capt</code> syscall - Released
with <code>rele</code> syscall</p>
<h3 data-number="4.7.5" id="interrupt-handling-overview"><span class="header-section-number">4.7.5</span> Interrupt Handling
Overview</h3>
<p>All interrupts vector to <code>pibreak</code> (s7.s), which polls
every device:</p>
<pre class="assembly"><code>pibreak:
   " Disk interrupt
   dpsf              " Disk status flag
   jmp 1f
   " ... handle disk ...

1: clsf              " Clock flag
   jmp 1f
   " ... handle clock ...

1: dssf              " Dectape flag
   jmp 1f
   " ... handle tape ...

   " ... (check all devices) ...

piret:
   lac 0
   ral
   lac .ac
   ion
   jmp 0 i           " Return from interrupt</code></pre>
<p><strong>Interrupt flow:</strong> 1. Hardware asserts interrupt signal
2. PC saved, jump to pibreak 3. Poll each device status flag 4. If
device ready, transfer data 5. Call <code>wakeup</code> to unblock
waiting process 6. Restore registers, return from interrupt</p>
<p>The polling approach is inefficient but simple. With only 7 devices
and slow interrupt rates, it works fine.</p>
<h3 data-number="4.7.6" id="device-specific-handlers"><span class="header-section-number">4.7.6</span> Device-Specific Handlers</h3>
<p><strong>TTY (Teletype) - rttyi/wttyo</strong></p>
<p>Input (rttyi):</p>
<pre class="assembly"><code>rttyi:
   jms chkint1               " Check for interrupts
   lac d1                    " Device 1
   jms getchar               " Get from queue
      jmp 1f                 " Queue empty
   and o177                  " Mask to 7 bits
   jms betwen; o101; o132    " Check if uppercase
      skp
   tad o40                   " Convert to lowercase
   alss 9                    " Shift to high half
   jmp passone               " Return to user

1: jms sleep; sfiles+0       " Sleep on TTY input
   jms swap                  " Swap to other process
   jmp rttyi                 " Try again when woken</code></pre>
<p>Output (wttyo):</p>
<pre class="assembly"><code>wttyo:
   jms chkint1               " Check interrupts
   jms forall                " Get character from user
   sna                       " End of buffer?
   jmp fallr                 " Yes, return
   lmq                       " Save character
   lac sfiles+1              " Check output ready flag
   spa                       " Ready?
   jmp 1f                    " No, wait
   xor o400000               " Clear ready flag
   dac sfiles+1
   lacq                      " Get character
   tls                       " Output to TTY
   sad o12                   " Newline?
   jms putcr                 " Add carriage return
   jmp fallr                 " Return

1: lacq
   dac char
   jms putchar               " Queue character
      skp
   jmp fallr
   jms sleep; sfiles+1       " Sleep on output ready
   jms swap
   jmp wttyo                 " Try again</code></pre>
<p><strong>Display (Type 340) - wdspo</strong></p>
<pre class="assembly"><code>wdspo:
   jms chkint1               " Check interrupts
   jms forall                " Get character from user
   jms dspput                " Put to display buffer
      jmp fallr              " Buffer full, return
   jms sleep; sfiles+6       " Sleep on display ready
   jms swap
   jmp wdspo                 " Try again</code></pre>
<p>The display uses a special hardware feature (BEG - begin display)
that triggers DMA transfer of the entire display buffer.</p>
<p><strong>Disk - handled via s4.s functions</strong></p>
<p>Disk I/O is block-oriented, not character-oriented: -
<code>dskrd</code>/<code>dskwr</code> are called from file system -
Interrupt handler just sets <code>.dskb</code> flag - No process
sleeping on disk (synchronous I/O)</p>
<h2 data-number="4.8" id="boot-and-initialization"><span class="header-section-number">4.8</span> 8. Boot and Initialization</h2>
<p>The boot process is crucial to understanding how Unix comes alive
from a cold start.</p>
<h3 data-number="4.8.1" id="cold-boot-sequence"><span class="header-section-number">4.8.1</span> Cold Boot Sequence</h3>
<p><strong>Step 1: Hardware Bootstrap</strong></p>
<pre><code>1. Power on PDP-7
2. Operator loads boot program from paper tape
3. Boot program reads block 0 from disk
4. Jump to location 00100 (coldentry in s9.s)</code></pre>
<p><strong>Step 2: Kernel Initialization (s9.s)</strong></p>
<pre class="assembly"><code>coldentry:
   dzm 0100              " Mark not re-entrant
   caf                   " Clear all flags
   ion                   " Enable interrupts
   clon                  " Clear console (start fresh)
   law 3072              " Load display address
   wcga                  " Write CGA (graphics address)
   jms dspinit           " Initialize display buffer
   law dspbuf
   jms movdsp            " Move display buffer to hardware</code></pre>
<p><strong>Step 3: Load System Data</strong></p>
<pre class="assembly"><code>   cla
   jms dskio; 06000      " Read block 1 (superblock)
   jms copy; dskbuf; sysdata; ulist-sysdata</code></pre>
<p>This reads the superblock containing: - Free block list (s.fblks) -
Unique ID counter (s.uniq) - System time (s.tim) - Process table state
(ulist)</p>
<p><strong>Step 4: Load /init Program</strong></p>
<pre class="assembly"><code>   lac d3                " Inode 3 = /init
   jms namei; initf      " Resolve "init" filename
      jms halt           " Panic if not found
   jms iget              " Load inode into memory
   cla
   jms iread; 4096; 4096 " Read init program into user memory
   jmp 4096              " Jump to user memory, start init</code></pre>
<p><strong>Init filename:</strong></p>
<pre class="assembly"><code>initf:
   &lt;i&gt;n;&lt;i&gt;t;&lt; &gt; ;&lt; &gt;   " "init" in 4-word format</code></pre>
<p><strong>Step 5: /init Program Runs</strong></p>
<p>The /init program (written in assembler or B language):</p>
<pre><code>1. Initialize terminal
2. Print login prompt
3. Read username
4. Fork and exec shell for user
5. Repeat</code></pre>
<h3 data-number="4.8.2" id="full-boot-flowchart"><span class="header-section-number">4.8.2</span> Full Boot Flowchart</h3>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  POWER ON                                                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Operator loads boot tape                                   ‚îÇ
‚îÇ  - Paper tape reader                                        ‚îÇ
‚îÇ  - ~50 words of bootstrap code                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Bootstrap reads disk block 0                               ‚îÇ
‚îÇ  - Contains secondary boot loader                           ‚îÇ
‚îÇ  - Loads kernel into memory                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Jump to coldentry (00100)                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Hardware initialization (s9.s)                             ‚îÇ
‚îÇ  - Clear flags and console                                  ‚îÇ
‚îÇ  - Initialize display                                       ‚îÇ
‚îÇ  - Enable interrupts                                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Load system data (sysdata, ulist)                          ‚îÇ
‚îÇ  - Read block 1 (superblock)                                ‚îÇ
‚îÇ  - Initialize free block list                               ‚îÇ
‚îÇ  - Restore process table                                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Locate /init program                                       ‚îÇ
‚îÇ  - Look up inode 3                                          ‚îÇ
‚îÇ  - Load into user memory (4096-7677)                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Jump to user memory (4096)                                 ‚îÇ
‚îÇ  - /init program starts                                     ‚îÇ
‚îÇ  - PID = 1, UID = -1 (superuser)                            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  /init runs                                                 ‚îÇ
‚îÇ  - Display login prompt                                     ‚îÇ
‚îÇ  - Read username                                            ‚îÇ
‚îÇ  - Fork shell process                                       ‚îÇ
‚îÇ  - Wait for shell to exit                                   ‚îÇ
‚îÇ  - Repeat                                                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
             ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Shell executes user commands                               ‚îÇ
‚îÇ  - Fork/exec for each command                               ‚îÇ
‚îÇ  - Normal Unix operation                                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
<h3 data-number="4.8.3" id="installation-boot-s9.s-alternate-path"><span class="header-section-number">4.8.3</span> Installation Boot (s9.s
alternate path)</h3>
<p>During initial installation, s9.s has additional code to read system
files from paper tape:</p>
<pre class="assembly"><code>" After zeroing i-list and freeing blocks...
dzm ii                    " Start with inode 0
1:
   dzm sum                " Checksum accumulator
   jms getw               " Read word from tape
   sza                    " Zero means pause
   jmp .+3
   hlt                    " Halt for operator
   jmp 1b                 " Continue

   dac xx                 " Save word count
   isz ii                 " Next inode
   lac ii
   jms iget               " Get inode
   jms copyz; inode; 12   " Clear inode

   jms getw               " Read flags
   dac i.flags
   -1
   dac i.uid              " Superuser owns all files
   jms getw               " Read link count
   dac i.nlks

   " Read file contents from tape...
   " Write to disk using iwrite

   jmp 1b                 " Next file</code></pre>
<p><strong>Tape format:</strong></p>
<pre><code>[word_count] [flags] [nlinks] [data...] [checksum]
[word_count] [flags] [nlinks] [data...] [checksum]
...
[0] (end marker)</code></pre>
<p>This creates the initial file system with: - Inode 1: Root directory
‚Äú/‚Äù - Inode 2: /init - Inode 3+: System utilities (sh, ed, as, etc.)</p>
<h3 data-number="4.8.4" id="shutdown-and-restart"><span class="header-section-number">4.8.4</span> Shutdown and Restart</h3>
<p>There is no formal ‚Äúshutdown‚Äù procedure. To stop the system: 1. Kill
all user processes 2. <code>sys save</code> to write system state to
inode 1 3. Halt the machine (power off)</p>
<p>To restart: 1. Power on 2. Boot from tape (reads inode 1) 3. System
state restored 4. Processes resume (primitive hibernation)</p>
<h2 data-number="4.9" id="data-structures-1"><span class="header-section-number">4.9</span> 9. Data Structures</h2>
<p>Understanding the data structures is key to reading the source code.
Here are the actual definitions from s8.s.</p>
<h3 data-number="4.9.1" id="process-table-ulist"><span class="header-section-number">4.9.1</span> Process Table (ulist)</h3>
<pre class="assembly"><code>" ulist - 10 process slots, 4 words each
ulist:
   0131000;1;0;0      " Process 0: state=1 (in, ready), ptr=031000, pid=1
   0031040;0;0;0      " Process 1: state=0 (free), ptr=031040
   0031100;0;0;0      " Process 2: state=0 (free), ptr=031100
   0031140;0;0;0      " Process 3: state=0 (free), ptr=031140
   0031200;0;0;0      " Process 4: state=0 (free), ptr=031200
   0031240;0;0;0      " Process 5: state=0 (free), ptr=031240
   0031300;0;0;0      " Process 6: state=0 (free), ptr=031300
   0031340;0;0;0      " Process 7: state=0 (free), ptr=031340
   0031400;0;0;0      " Process 8: state=0 (free), ptr=031400
   0031440;0;0;0      " Process 9: state=0 (free), ptr=031440</code></pre>
<p><strong>Word 0 breakdown (octal 0131000):</strong></p>
<pre><code>0 1 3 1 0 0 0
‚îÇ ‚îî‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ Pointer: 031000 (points to userdata)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  State: 001 (in memory, ready)</code></pre>
<h3 data-number="4.9.2" id="user-data-structure-userdata"><span class="header-section-number">4.9.2</span> User Data Structure
(userdata)</h3>
<pre class="assembly"><code>userdata:
   u.ac: 0                 " Saved accumulator
   u.mq: 0                 " Saved MQ register
   u.rq: .=.+9             " Saved registers 8,9,10-15
   u.uid: -1               " User ID (-1 = superuser, ‚â•0 = normal user)
   u.pid: 1                " Process ID
   u.cdir: 3               " Current directory inode (3 = root)
   u.ulistp: ulist         " Pointer to this process's ulist entry
   u.swapret: 0            " Return address after swap
   u.base: 0               " Syscall work: base address
   u.count: 0              " Syscall work: count
   u.limit: 0              " Syscall work: limit
   u.ofiles: .=.+30        " Open file table (10 files √ó 3 words each)
   u.dspbuf: 0             " Display buffer pointer (0 = not captured)
   u.intflg: 1             " Interrupt enable flag
   .=userdata+64           " Total: 64 words</code></pre>
<p><strong>u.ofiles layout:</strong></p>
<pre><code>u.ofiles+0:  f.flags, f.badd, f.i     " File descriptor 0
u.ofiles+3:  f.flags, f.badd, f.i     " File descriptor 1
u.ofiles+6:  f.flags, f.badd, f.i     " File descriptor 2
...
u.ofiles+27: f.flags, f.badd, f.i     " File descriptor 9</code></pre>
<h3 data-number="4.9.3" id="inode-structure-1"><span class="header-section-number">4.9.3</span> Inode Structure</h3>
<pre class="assembly"><code>ii: .=.+1              " Current inode number
inode:
   i.flags: .=.+1      " File type and permissions (18 bits)
   i.dskps: .=.+7      " Disk block pointers (7 words)
   i.uid: .=.+1        " Owner user ID
   i.nlks: .=.+1       " Number of links (stored as -n for n links)
   i.size: .=.+1       " File size in words
   i.uniq: .=.+1       " Unique ID (for cache coherency)
   .= inode+12         " Total: 12 words</code></pre>
<p><strong>i.flags format:</strong></p>
<pre><code>Bit:  17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
      ‚îÇ  ‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ Permissions (15 bits)
      ‚îÇ  ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Reserved
      ‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Directory flag (020)
      ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Character device (040)
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Large file/indirect (0200000)</code></pre>
<p><strong>Example inode for a readable/writable file owned by user
1:</strong></p>
<pre><code>ii:       42            " Inode number 42
i.flags:  040010        " Regular file, rw-------
i.dskps:  5123 5124 5125 0 0 0 0
i.uid:    1             " Owner UID
i.nlks:   -1            " One link
i.size:   150           " 150 words
i.uniq:   137           " Unique ID 137</code></pre>
<h3 data-number="4.9.4" id="directory-entry-structure"><span class="header-section-number">4.9.4</span> Directory Entry
Structure</h3>
<pre class="assembly"><code>di: .=.+1              " Current directory slot number
dnode:
   d.i: .=.+1          " Inode number
   d.name: .=.+4       " Filename (4 words = 6 chars)
   d.uniq: .=.+1       " Unique ID (must match inode's i.uniq)
   .= dnode+8          " Total: 8 words (2 words padding)</code></pre>
<p><strong>Filename encoding:</strong></p>
<pre><code>Word 0: [char1][char2]   " 9 bits each
Word 1: [char3][char4]
Word 2: [char5][char6]
Word 3: [padding]</code></pre>
<p><strong>Example directory entry for ‚Äúhello.txt‚Äù:</strong></p>
<pre><code>d.i:     42                " Points to inode 42
d.name:  &lt;h&gt;e;&lt;l&gt;l;&lt;o&gt;.; 0 " "hello." (truncated to 6 chars)
d.uniq:  137               " Must match inode 42's i.uniq</code></pre>
<h3 data-number="4.9.5" id="file-descriptor-structure"><span class="header-section-number">4.9.5</span> File Descriptor
Structure</h3>
<pre class="assembly"><code>fnode:
   f.flags: .=.+1      " Access mode and valid bit
   f.badd: .=.+1       " Current byte address in file
   f.i: 0              " Inode number</code></pre>
<p><strong>f.flags format:</strong></p>
<pre><code>Bit 17: Valid (1=in use, 0=free)
Bit 16: Write mode (1=write, 0=read)
Bits 0-15: Reserved</code></pre>
<p><strong>Example open file (fd 3, writing, position 100):</strong></p>
<pre><code>u.ofiles+9:               " Offset for fd 3
   f.flags:  0600000      " Valid + write mode
   f.badd:   100          " Current position
   f.i:      42           " Inode 42</code></pre>
<h3 data-number="4.9.6" id="system-data-sysdata"><span class="header-section-number">4.9.6</span> System Data (sysdata)</h3>
<pre class="assembly"><code>sysdata:
   s.nxfblk: .=.+1     " Next free block overflow list
   s.nfblks: .=.+1     " Number of free blocks in s.fblks
   s.fblks: .=.+10     " Free block numbers (cache of 10)
   s.uniq: .=.+1       " Unique ID counter (increments on file create)
   s.tim: .=.+2        " System time (36-bit, AC+MQ)</code></pre>
<p><strong>Example sysdata at boot:</strong></p>
<pre><code>s.nxfblk: 0            " No overflow yet
s.nfblks: 10           " 10 blocks in cache
s.fblks:  6399 6398 6397 6396 6395 6394 6393 6392 6391 6390
s.uniq:   142          " Next file will get uniq=143
s.tim:    01234567 023456  " Time since boot (arbitrary units)</code></pre>
<p>The system writes <code>sysdata</code> to disk block 1 on every
system call exit (if <code>.savblk</code> not set). This ensures
consistency even if power fails.</p>
<h3 data-number="4.9.7" id="constants-and-manifests"><span class="header-section-number">4.9.7</span> Constants and Manifests</h3>
<pre class="assembly"><code>" Manifest constants
mnproc = 10            " Maximum number of processes
dspbsz = 270           " Display buffer size in words
ndskbs = 4             " Number of disk buffers

" Decimal constants
d0: 0
d1: 1
d2: 2
...
d10: 10

" Octal constants
o7: 07
o12: 012  (newline)
o15: 015  (carriage return)
o17: 017
o20: 020  (directory flag)
...
o200000: 0200000  (process "out" flag)

" Negative constants
dm1: -1
dm3: -3</code></pre>
<h3 data-number="4.9.8" id="memory-allocation-pattern"><span class="header-section-number">4.9.8</span> Memory Allocation
Pattern</h3>
<p>The kernel data structures are allocated sequentially in memory:</p>
<pre><code>Address   Structure            Size
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
~03000    sysdata              14 words
~03016    ulist                40 words
~03060    userdata             64 words
~03144    inode                12 words
~03160    dnode                8 words
~03170    fnode                3 words
~03173    (work variables)     ~50 words
~03250    sfiles (wait queues) 10 words
~03262    dspbuf               270 words
~03556    q2 (char queues)     100 words
~03660    dskbs (disk cache)   260 words
~04150    (end of kernel data)</code></pre>
<p>Total kernel memory: ~4,000 words (code + data) Remaining for user:
~4,096 words</p>
<h2 data-number="4.10" id="naming-conventions"><span class="header-section-number">4.10</span> 10. Naming Conventions</h2>
<p>The PDP-7 Unix source code follows specific naming conventions that
reflect both the hardware constraints and Ken Thompson‚Äôs terse
style.</p>
<h3 data-number="4.10.1" id="why-s1-through-s9-1"><span class="header-section-number">4.10.1</span> Why s1 through s9?</h3>
<p><strong>Historical reasons:</strong> 1. <strong>Assembly required
short filenames</strong> - Early assemblers had filename length limits
2. <strong>Sequential development</strong> - Files numbered in rough
order of creation 3. <strong>Logical grouping</strong> - Related
functionality stayed together 4. <strong>Load order</strong> - Assembler
concatenated files in order (s1, s2, ‚Ä¶, s9)</p>
<p><strong>Modern equivalent:</strong></p>
<div class="sourceCode" id="cb392"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb392-1"><a aria-hidden="true" href="#cb392-1" tabindex="-1"></a><span class="co">// If PDP-7 Unix were written in C today:</span></span>
<span id="cb392-2"><a aria-hidden="true" href="#cb392-2" tabindex="-1"></a>kern<span class="op">/</span>entry<span class="op">.</span>c      <span class="co">// s1.s - entry/exit</span></span>
<span id="cb392-3"><a aria-hidden="true" href="#cb392-3" tabindex="-1"></a>kern<span class="op">/</span>file<span class="op">.</span>c       <span class="co">// s2.s - file operations</span></span>
<span id="cb392-4"><a aria-hidden="true" href="#cb392-4" tabindex="-1"></a>kern<span class="op">/</span>proc<span class="op">.</span>c       <span class="co">// s3.s - process management</span></span>
<span id="cb392-5"><a aria-hidden="true" href="#cb392-5" tabindex="-1"></a>kern<span class="op">/</span>util<span class="op">.</span>c       <span class="co">// s4.s - utilities</span></span>
<span id="cb392-6"><a aria-hidden="true" href="#cb392-6" tabindex="-1"></a>kern<span class="op">/</span>support<span class="op">.</span>c    <span class="co">// s5.s - support functions</span></span>
<span id="cb392-7"><a aria-hidden="true" href="#cb392-7" tabindex="-1"></a>fs<span class="op">/</span>inode<span class="op">.</span>c        <span class="co">// s6.s - file system core</span></span>
<span id="cb392-8"><a aria-hidden="true" href="#cb392-8" tabindex="-1"></a>kern<span class="op">/</span>trap<span class="op">.</span>c       <span class="co">// s7.s - interrupt handler</span></span>
<span id="cb392-9"><a aria-hidden="true" href="#cb392-9" tabindex="-1"></a>kern<span class="op">/</span>data<span class="op">.</span>c       <span class="co">// s8.s - data structures</span></span>
<span id="cb392-10"><a aria-hidden="true" href="#cb392-10" tabindex="-1"></a>kern<span class="op">/</span>boot<span class="op">.</span>c       <span class="co">// s9.s - boot loader</span></span></code></pre></div>
<h3 data-number="4.10.2" id="symbol-naming-patterns"><span class="header-section-number">4.10.2</span> Symbol Naming Patterns</h3>
<p><strong>System calls:</strong> Prefixed with dot (<code>.</code>)</p>
<pre class="assembly"><code>.open, .read, .write, .fork, .exit</code></pre>
<p><strong>Internal functions:</strong> No prefix</p>
<pre class="assembly"><code>alloc, free, copy, betwen, iget, iput, namei</code></pre>
<p><strong>Data structures:</strong> First letter indicates type</p>
<pre class="assembly"><code>i.flags   " inode field
d.name    " directory field
f.badd    " file descriptor field
u.pid     " user data field
s.tim     " system data field</code></pre>
<p><strong>Constants:</strong></p>
<pre class="assembly"><code>d0, d1, d2     " Decimal constants
o7, o12, o20   " Octal constants
dm1, dm3       " Decimal minus (negative)</code></pre>
<p><strong>Temporary variables:</strong> <code>9f+t</code> pattern</p>
<pre class="assembly"><code>t = 0          " At start of file
...
9f+t           " Refers to temp slot in array '9'
t = t+1        " Increment for next function</code></pre>
<p>This creates function-local temporaries in the <code>9</code> array
(defined in s8.s):</p>
<pre class="assembly"><code>9: .=.+t       " Allocate t words</code></pre>
<h3 data-number="4.10.3" id="label-naming"><span class="header-section-number">4.10.3</span> Label Naming</h3>
<p><strong>Local labels:</strong> Digits (1, 2, 1f, 1b)</p>
<pre class="assembly"><code>1:             " Label '1'
   ...
   jmp 1b      " Jump backward to '1'
   ...
   jmp 1f      " Jump forward to '1'
1:             " Reuse of label '1'</code></pre>
<p><strong>Global labels:</strong> Descriptive names</p>
<pre class="assembly"><code>coldentry:     " Cold boot entry point
pibreak:       " Program interrupt break
swap:          " Process swapper</code></pre>
<p><strong>Special labels:</strong></p>
<pre class="assembly"><code>0f, 1f, 2f     " Forward reference to argument
..             " Special: self-reference (modified at runtime)</code></pre>
<h3 data-number="4.10.4" id="octal-address-conventions"><span class="header-section-number">4.10.4</span> Octal Address
Conventions</h3>
<p><strong>Why octal?</strong> 18-bit words divide evenly into 6 octal
digits:</p>
<pre><code>Binary:  000 000 000 000 000 000   (18 bits)
Octal:    0   0   0   0   0   0    (6 digits)
Decimal: 0-262,143                 (awkward)</code></pre>
<p><strong>Common addresses:</strong></p>
<pre class="assembly"><code>00000   " Memory start
00020   " System call trap vector
00100   " Kernel code start
04000   " User memory start (decimal 2048)
07700   " Disk buffer (dskbuf)
07777   " Near end of memory
17777   " Last address (8K - 1)</code></pre>
<p><strong>Octal bit masks:</strong></p>
<pre class="assembly"><code>o17777  " Low 13 bits (8K address space)
o77777  " Low 15 bits
o177    " Low 7 bits (ASCII)
o777    " Low 9 bits (9-bit character)</code></pre>
<h3 data-number="4.10.5" id="function-call-conventions"><span class="header-section-number">4.10.5</span> Function Call
Conventions</h3>
<p><strong>JMS (Jump to Subroutine):</strong></p>
<pre class="assembly"><code>" Caller:
   jms function
   " Return address stored in function[0]

" Callee:
function: 0
   ...
   jmp function i    " Return via stored address</code></pre>
<p><strong>Return values:</strong> - Single value: Return in AC - Two
values: AC + MQ - Multiple values: Store in caller-provided
addresses</p>
<p><strong>Skip returns:</strong> Indicate success/failure</p>
<pre class="assembly"><code>" Function that can fail:
function: 0
   ...
   isz function      " Skip return on success
   jmp function i    " Normal return (failure)

" Caller:
   jms function
      jmp error      " Taken if no skip
   " Success path</code></pre>
<h3 data-number="4.10.6" id="naming-evolution"><span class="header-section-number">4.10.6</span> Naming Evolution</h3>
<p><strong>Early names (terse):</strong></p>
<pre class="assembly"><code>i, ii, di         " Inode, inode number, directory index
8, 9              " Index registers
t                 " Temporary counter</code></pre>
<p><strong>Later names (more descriptive):</strong></p>
<pre class="assembly"><code>searchu, lookfor  " Process table search
argname, seektell " Higher-level operations</code></pre>
<p><strong>The tradeoff:</strong> - Short names: Faster to type, fit in
limited symbol table - Long names: Easier to understand,
self-documenting</p>
<p>Thompson favored extreme brevity. Modern standards prefer
clarity.</p>
<h2 data-number="4.11" id="size-and-complexity-analysis"><span class="header-section-number">4.11</span> 11. Size and Complexity
Analysis</h2>
<p>Let‚Äôs analyze the remarkable efficiency of PDP-7 Unix.</p>
<h3 data-number="4.11.1" id="line-counts-by-module"><span class="header-section-number">4.11.1</span> Line Counts by Module</h3>
<pre><code>File  | Lines | Code | Comments | Blank | Code/Total
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
s1.s  |  193  | 150  |   30     |  13   | 78%
s2.s  |  328  | 280  |   35     |  13   | 85%
s3.s  |  347  | 295  |   40     |  12   | 85%
s4.s  |  334  | 285  |   35     |  14   | 85%
s5.s  |  273  | 230  |   30     |  13   | 84%
s6.s  |  344  | 295  |   35     |  14   | 86%
s7.s  |  350  | 310  |   30     |  10   | 89%
s8.s  |  208  | 195  |   10     |   3   | 94%
s9.s  |  112  |  95  |   12     |   5   | 85%
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Total | 2,489 | 2,135|  257     |  97   | 86%</code></pre>
<p><strong>Observations:</strong> - Very high code density (86%
executable code) - Minimal comments (10% of lines) - Few blank lines
(4%) - s8.s is nearly all code (data declarations)</p>
<h3 data-number="4.11.2" id="functionality-density"><span class="header-section-number">4.11.2</span> Functionality Density</h3>
<pre><code>Category              | Functions | Lines | Lines/Function
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
System calls          |    26     |  600  |    23
File system core      |    15     |  700  |    47
Process management    |     8     |  400  |    50
Device I/O            |    12     |  350  |    29
Utilities             |    20     |  300  |    15
Interrupt handling    |     1     |  350  |   350
Boot/initialization   |     5     |  200  |    40
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Total                 |   ~87     | 2,900 |    33</code></pre>
<p>Average function size: <strong>33 lines</strong></p>
<p>For comparison: - Modern Linux kernel: ~100-200 lines per function
average - PDP-7 Unix: 33 lines per function - Difference: 3-6x more
compact</p>
<h3 data-number="4.11.3" id="functionality-per-line-metrics"><span class="header-section-number">4.11.3</span> Functionality per Line
Metrics</h3>
<p>Let‚Äôs measure what each line of code achieves:</p>
<p><strong>System call implementation:</strong></p>
<pre><code>26 system calls / 2,489 total lines = 96 lines per system call

But several system calls are trivial (getuid: 3 lines)
Complex system calls (fork, read, write): 50-100 lines each</code></pre>
<p><strong>File system operations:</strong></p>
<pre><code>Operations supported:
  - Inode read/write
  - Directory lookup
  - Block allocation/free
  - Large file support (indirect blocks)
  - Permission checking
  - Link/unlink

Lines of code: ~900 (s2.s + s6.s)</code></pre>
<p><strong>Process management:</strong></p>
<pre><code>Operations:
  - fork (create process)
  - exit (terminate)
  - swap (process switching)
  - sleep/wakeup (synchronization)
  - smes/rmes (IPC)

Lines of code: ~400 (s3.s, parts of s1.s)</code></pre>
<p><strong>Device drivers:</strong></p>
<pre><code>Devices supported: 7 (TTY, keyboard, display, tape, disk, clock, card reader)
Lines per driver: ~50
Total driver code: ~350 lines

Compare to Linux:
  - Single device driver: Often 1,000-10,000 lines
  - PDP-7 Unix: All drivers fit in 350 lines</code></pre>
<h3 data-number="4.11.4" id="comparison-with-modern-systems"><span class="header-section-number">4.11.4</span> Comparison with Modern
Systems</h3>
<table>
<thead>
<tr>
<th>Metric</th>
<th>PDP-7 Unix (1969)</th>
<th>Linux 6.x (2024)</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>Total kernel lines</td>
<td>2,489</td>
<td>~30,000,000</td>
<td>12,000√ó</td>
</tr>
<tr>
<td>System calls</td>
<td>26</td>
<td>~450</td>
<td>17√ó</td>
</tr>
<tr>
<td>Loadable modules</td>
<td>0</td>
<td>~6,000</td>
<td>‚àû</td>
</tr>
<tr>
<td>Supported CPUs</td>
<td>1 (PDP-7)</td>
<td>~30 architectures</td>
<td>30√ó</td>
</tr>
<tr>
<td>File systems</td>
<td>1 (Unix FS)</td>
<td>~70</td>
<td>70√ó</td>
</tr>
<tr>
<td>Device drivers</td>
<td>7</td>
<td>~4,000</td>
<td>570√ó</td>
</tr>
<tr>
<td>Developers</td>
<td>2 (Thompson, Ritchie)</td>
<td>~20,000</td>
<td>10,000√ó</td>
</tr>
<tr>
<td>Development time</td>
<td>~4 weeks</td>
<td>30+ years</td>
<td>‚àû</td>
</tr>
<tr>
<td>Binary size</td>
<td>~8 KB</td>
<td>~10 MB</td>
<td>1,250√ó</td>
</tr>
</tbody>
</table>
<p><strong>Why the difference?</strong></p>
<p>PDP-7 Unix could be small because: 1. <strong>One CPU
architecture</strong> - No portability abstractions 2. <strong>No
backward compatibility</strong> - No legacy code 3. <strong>Minimal
hardware</strong> - Only 7 devices to support 4. <strong>Simple
features</strong> - No networking, no graphics, no security 5.
<strong>Expert programmers</strong> - Thompson and Ritchie were masters
6. <strong>Assembly language</strong> - Direct hardware access, no
overhead</p>
<p>Modern Linux must handle: 1. <strong>30+ CPU architectures</strong> -
x86, ARM, RISC-V, etc. 2. <strong>40+ years of compatibility</strong> -
Support ancient software 3. <strong>Thousands of devices</strong> - USB,
PCI, network cards, GPUs 4. <strong>Complex features</strong> -
Networking, security, virtualization 5. <strong>Many
contributors</strong> - Code from thousands of developers 6.
<strong>Portability</strong> - Written in C, works on many platforms</p>
<h3 data-number="4.11.5" id="code-reuse-analysis"><span class="header-section-number">4.11.5</span> Code Reuse Analysis</h3>
<p>How much code is shared vs.¬†specialized?</p>
<pre><code>Shared utilities (s4.s, s5.s):      ~600 lines (24%)
  - Used by all other modules
  - High reuse factor (called from 50+ places)

File system code (s2.s, s6.s):      ~900 lines (36%)
  - Called by file-related syscalls
  - Moderate reuse (10-20 call sites per function)

Process code (s1.s, s3.s):          ~540 lines (22%)
  - Called by process syscalls and scheduler
  - Moderate reuse

Device drivers (s3.s, s7.s):        ~400 lines (16%)
  - Device-specific, low reuse
  - Each driver used by 1-2 system calls

Data structures (s8.s):             ~200 lines (8%)
  - Included by all modules
  - Maximum reuse

Boot code (s9.s):                   ~112 lines (4%)
  - Run once, never reused
  - Minimum reuse</code></pre>
<p><strong>Reuse efficiency:</strong> - 60% of code is highly reused
(utilities, data structures) - 40% is specialized (drivers, boot,
specific syscalls)</p>
<p>Compare to modern systems: - Modern OS: ~70-80% specialized, 20-30%
shared - PDP-7 Unix achieved higher reuse through simplicity</p>
<h3 data-number="4.11.6" id="complexity-metrics"><span class="header-section-number">4.11.6</span> Complexity Metrics</h3>
<p><strong>Cyclomatic complexity</strong> (branches per function):</p>
<pre><code>Function Type       | Avg Branches | Complexity
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Utilities           |      2-3     | Simple
System calls        |      4-6     | Moderate
File system ops     |      8-12    | Complex
Interrupt handler   |     20+      | Very complex</code></pre>
<p><strong>Deepest call chains:</strong></p>
<pre><code>User program
  ‚Üí sys call (s1.s)
    ‚Üí .read (s2.s)
      ‚Üí finac (s6.s)
        ‚Üí fget (s5.s)
      ‚Üí iread (s6.s)
        ‚Üí pget (s6.s)
          ‚Üí alloc (s4.s)
        ‚Üí dskrd (s4.s)
          ‚Üí dskio (s4.s)
            ‚Üí dsktrans (s4.s)

Depth: 9 levels</code></pre>
<p>Modern kernels often reach 15-20 levels deep.</p>
<p><strong>Coupling analysis:</strong></p>
<pre><code>Module    | Calls To  | Called By | Coupling Score
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
s1.s      | s2,s3,s4  |  (entry)  | Medium
s2.s      | s4,s5,s6  |   s1      | High
s3.s      | s4,s5,s7  |   s1      | High
s4.s      | (hardware)|  ALL      | High (utility)
s5.s      | s4,s6     | s2,s3,s6  | Medium
s6.s      | s4,s5     | s2,s5     | Medium
s7.s      | s4,s5     |(hardware) | Low (isolated)
s8.s      | -         |  ALL      | High (data)
s9.s      | s4,s6,s8  | (boot)    | Low (runs once)</code></pre>
<p>Most modules are moderately coupled. s4.s (utilities) and s8.s (data)
are highly coupled by design.</p>
<h2 data-number="4.12" id="reading-map"><span class="header-section-number">4.12</span> 12. Reading Map</h2>
<p>A guide to navigating the source code effectively.</p>
<h3 data-number="4.12.1" id="what-to-read-first"><span class="header-section-number">4.12.1</span> What to Read First</h3>
<p><strong>For understanding the big picture:</strong> 1.
<strong>s8.s</strong> - Data structures (30 minutes) - See all the key
structures - Understand memory layout - Learn naming conventions</p>
<ol start="2" type="1">
<li><strong>s1.s</strong> - System call dispatcher (1 hour)
<ul>
<li>Entry/exit flow</li>
<li>System call table</li>
<li>Swapping logic</li>
</ul></li>
<li><strong>This chapter</strong> - Architecture overview (2 hours)
<ul>
<li>Mental model of entire system</li>
</ul></li>
</ol>
<p><strong>For file system understanding:</strong> 1.
<strong>s6.s</strong> - File system core (3 hours) - Start with
<code>iget</code>, <code>iput</code> (simple) - Then <code>namei</code>
(directory lookup) - Then <code>iread</code>, <code>iwrite</code>
(complex) - Finally <code>pget</code> (block mapping)</p>
<ol start="2" type="1">
<li><strong>s2.s</strong> - File operations (2 hours)
<ul>
<li>See how syscalls use s6.s functions</li>
<li>Understand permission checking</li>
<li>Learn file descriptor management</li>
</ul></li>
</ol>
<p><strong>For process understanding:</strong> 1. <strong>s3.s</strong>
- Process management (2 hours) - Start with <code>.fork</code> (process
creation) - Then <code>.exit</code> (termination) - Then
<code>sleep</code>/<code>wakeup</code> (synchronization)</p>
<ol start="2" type="1">
<li><strong>s1.s</strong> - Process switching (1 hour)
<ul>
<li><code>swap</code> routine</li>
<li>Context save/restore</li>
</ul></li>
</ol>
<p><strong>For device I/O understanding:</strong> 1.
<strong>s7.s</strong> - Interrupt handler (3 hours) - Start with
<code>pibreak</code> structure - Trace one device (e.g., TTY) -
Understand <code>wakeup</code> mechanism</p>
<ol start="2" type="1">
<li><strong>s3.s</strong> - Device syscalls (1 hour)
<ul>
<li><code>rttyi</code>, <code>wttyo</code> (TTY)</li>
<li>See how they use character queues</li>
</ul></li>
<li><strong>s4.s</strong> - Character queues (1 hour)
<ul>
<li><code>putchar</code>, <code>getchar</code></li>
<li><code>putq</code>, <code>takeq</code></li>
</ul></li>
</ol>
<h3 data-number="4.12.2" id="dependencies-between-modules"><span class="header-section-number">4.12.2</span> Dependencies Between
Modules</h3>
<p><strong>Dependency graph:</strong></p>
<pre><code>        s8.s (data)
          ‚Üë
          ‚îÇ (used by all)
          ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ                               ‚îÇ
   s4.s (utilities)                s1.s (entry)
    ‚Üë                               ‚Üë
    ‚îÇ                               ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
    ‚îÇ       ‚îÇ       ‚îÇ       ‚îÇ       ‚îÇ
   s2.s   s3.s    s5.s    s6.s    s7.s
   file   proc   support  fs     interrupt

   s9.s (boot) - standalone, calls s4, s6, s8</code></pre>
<p><strong>Required reading order:</strong> 1. s8.s (no dependencies) 2.
s4.s (depends on s8.s) 3. s1.s, s2.s, s3.s, s5.s, s6.s, s7.s (depend on
s4.s, s8.s) 4. s9.s (uses s4.s, s6.s, s8.s)</p>
<h3 data-number="4.12.3" id="cross-reference-table"><span class="header-section-number">4.12.3</span> Cross-Reference Table</h3>
<p><strong>Function ‚Üí File mapping:</strong></p>
<table>
<thead>
<tr>
<th>Function</th>
<th>File</th>
<th>Called By</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>alloc</code></td>
<td>s4.s</td>
<td>s5.s, s6.s</td>
<td>Allocate disk block</td>
</tr>
<tr>
<td><code>free</code></td>
<td>s4.s</td>
<td>s6.s</td>
<td>Free disk block</td>
</tr>
<tr>
<td><code>copy</code></td>
<td>s4.s</td>
<td>ALL</td>
<td>Copy memory</td>
</tr>
<tr>
<td><code>copyz</code></td>
<td>s4.s</td>
<td>s5.s, s6.s, s9.s</td>
<td>Zero memory</td>
</tr>
<tr>
<td><code>betwen</code></td>
<td>s4.s</td>
<td>ALL</td>
<td>Range check</td>
</tr>
<tr>
<td><code>dskrd</code></td>
<td>s4.s</td>
<td>s6.s</td>
<td>Read disk block</td>
</tr>
<tr>
<td><code>dskwr</code></td>
<td>s4.s</td>
<td>s6.s</td>
<td>Write disk block</td>
</tr>
<tr>
<td><code>iget</code></td>
<td>s6.s</td>
<td>s2.s, s5.s, s6.s</td>
<td>Read inode</td>
</tr>
<tr>
<td><code>iput</code></td>
<td>s6.s</td>
<td>s2.s, s6.s</td>
<td>Write inode</td>
</tr>
<tr>
<td><code>namei</code></td>
<td>s6.s</td>
<td>s2.s, s5.s</td>
<td>Name lookup</td>
</tr>
<tr>
<td><code>iread</code></td>
<td>s6.s</td>
<td>s2.s, s9.s</td>
<td>Read file data</td>
</tr>
<tr>
<td><code>iwrite</code></td>
<td>s6.s</td>
<td>s2.s, s3.s, s9.s</td>
<td>Write file data</td>
</tr>
<tr>
<td><code>dget</code></td>
<td>s6.s</td>
<td>s5.s, s6.s</td>
<td>Read directory entry</td>
</tr>
<tr>
<td><code>dput</code></td>
<td>s6.s</td>
<td>s2.s, s5.s</td>
<td>Write directory entry</td>
</tr>
<tr>
<td><code>fget</code></td>
<td>s5.s</td>
<td>s2.s, s5.s, s6.s</td>
<td>Get file descriptor</td>
</tr>
<tr>
<td><code>fput</code></td>
<td>s5.s</td>
<td>s2.s</td>
<td>Put file descriptor</td>
</tr>
<tr>
<td><code>sleep</code></td>
<td>s5.s</td>
<td>s3.s</td>
<td>Block on event</td>
</tr>
<tr>
<td><code>wakeup</code></td>
<td>s7.s</td>
<td>s7.s</td>
<td>Unblock processes</td>
</tr>
<tr>
<td><code>swap</code></td>
<td>s1.s</td>
<td>s1.s, s3.s</td>
<td>Process switch</td>
</tr>
<tr>
<td><code>fork</code></td>
<td>s3.s</td>
<td>user</td>
<td>Create process</td>
</tr>
<tr>
<td><code>exit</code></td>
<td>s3.s</td>
<td>user</td>
<td>Terminate process</td>
</tr>
</tbody>
</table>
<p><strong>Data structure ‚Üí Access pattern:</strong></p>
<table>
<colgroup>
<col style="width: 21%"/>
<col style="width: 17%"/>
<col style="width: 17%"/>
<col style="width: 23%"/>
<col style="width: 21%"/>
</colgroup>
<thead>
<tr>
<th>Structure</th>
<th>Defined</th>
<th>Read By</th>
<th>Written By</th>
<th>Frequency</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ulist</code></td>
<td>s8.s</td>
<td>s1.s, s3.s, s7.s</td>
<td>s3.s</td>
<td>Every syscall</td>
</tr>
<tr>
<td><code>userdata</code></td>
<td>s8.s</td>
<td>s1.s, s2.s, s3.s</td>
<td>s1.s, s2.s, s3.s</td>
<td>Every syscall</td>
</tr>
<tr>
<td><code>sysdata</code></td>
<td>s8.s</td>
<td>s4.s</td>
<td>s4.s</td>
<td>Every alloc/free</td>
</tr>
<tr>
<td><code>inode</code></td>
<td>s8.s</td>
<td>s6.s, s2.s</td>
<td>s6.s</td>
<td>Every file operation</td>
</tr>
<tr>
<td><code>dnode</code></td>
<td>s8.s</td>
<td>s6.s</td>
<td>s6.s</td>
<td>Directory operations</td>
</tr>
<tr>
<td><code>fnode</code></td>
<td>s8.s</td>
<td>s5.s</td>
<td>s5.s</td>
<td>File descriptor ops</td>
</tr>
<tr>
<td><code>dskbuf</code></td>
<td>s8.s</td>
<td>s4.s, s6.s</td>
<td>s4.s</td>
<td>Every disk I/O</td>
</tr>
</tbody>
</table>
<h3 data-number="4.12.4" id="reading-strategies"><span class="header-section-number">4.12.4</span> Reading Strategies</h3>
<p><strong>Strategy 1: Top-Down (Conceptual)</strong> 1. Read this
chapter thoroughly 2. Read s1.s (system call flow) 3. Pick one system
call (e.g., <code>read</code>) 4. Trace it through all layers: - s2.s:
<code>.read</code> entry point - s6.s: <code>iread</code> implementation
- s4.s: <code>dskrd</code> disk access 5. Repeat for other system
calls</p>
<p><strong>Strategy 2: Bottom-Up (Implementation)</strong> 1. Read s8.s
(data structures) 2. Read s4.s (utilities) 3. Read s6.s (file system
core) 4. Read s2.s (file system calls) 5. Read s5.s (support functions)
6. Read s3.s (process management) 7. Read s7.s (interrupt handling) 8.
Read s1.s (system dispatcher) 9. Read s9.s (boot loader)</p>
<p><strong>Strategy 3: Feature-Focused</strong></p>
<p>For <strong>file system</strong>: - s8.s: Data structures - s4.s:
Disk I/O - s6.s: Inode operations - s2.s: System calls</p>
<p>For <strong>process management</strong>: - s8.s: Process table -
s1.s: Context switching - s3.s: Fork/exit/IPC</p>
<p>For <strong>device I/O</strong>: - s4.s: Character queues - s7.s:
Interrupt handler - s3.s: Device system calls</p>
<p><strong>Strategy 4: Historical Recreation</strong> 1. Imagine you‚Äôre
Ken Thompson in 1969 2. Start with s1.s (first thing needed) 3. Add s2.s
(basic file operations) 4. Add s3.s (processes) 5. Add s4.s (utilities
as needed) 6. Continue in order s5, s6, s7, s8, s9</p>
<h3 data-number="4.12.5" id="common-confusion-points"><span class="header-section-number">4.12.5</span> Common Confusion Points</h3>
<p><strong>1. The <code>9f+t</code> temporary variables</strong></p>
<pre class="assembly"><code>t = 0              " Reset at start of file
...
dac 9f+t           " Store in temporary slot
t = t+1            " Allocate next slot</code></pre>
<p>Think of <code>9</code> as an array, <code>t</code> as the allocation
pointer.</p>
<p><strong>2. Skip returns</strong></p>
<pre class="assembly"><code>jms function
   jmp error       " Taken if function fails (no skip)
" Success path</code></pre>
<p>If function succeeds, it executes <code>isz function</code>, skipping
the error jump.</p>
<p><strong>3. Indirect addressing</strong></p>
<pre class="assembly"><code>lac u.ulistp i     " Load from address stored in u.ulistp
dac 9f+t i         " Store to address stored in 9f+t</code></pre>
<p>The <code>i</code> suffix means ‚Äúindirect‚Äù (pointer dereference).</p>
<p><strong>4. Forward/backward labels</strong></p>
<pre class="assembly"><code>1: ...             " Label '1'
   jmp 1b          " Jump backward to previous '1'
   ...
   jmp 1f          " Jump forward to next '1'
1: ...             " Another label '1'</code></pre>
<p><strong>5. Self-modifying code</strong></p>
<pre class="assembly"><code>dac .+1            " Store into next instruction
lac ..             " Load from address just modified</code></pre>
<p>Common in PDP-7 due to lack of general-purpose registers.</p>
<h3 data-number="4.12.6" id="recommended-reading-order"><span class="header-section-number">4.12.6</span> Recommended Reading
Order</h3>
<p><strong>Day 1</strong> (4 hours): Foundation - This chapter: Sections
1-4 (architecture, syscalls, file system) - s8.s: Complete file - s1.s:
Entry/exit code</p>
<p><strong>Day 2</strong> (4 hours): File System - This chapter:
Sections 4-5 (file system, processes) - s4.s: Disk I/O functions - s6.s:
Functions <code>iget</code>, <code>iput</code>, <code>namei</code></p>
<p><strong>Day 3</strong> (4 hours): File System Continued - s6.s:
Functions <code>iread</code>, <code>iwrite</code>, <code>pget</code> -
s2.s: System calls <code>.read</code>, <code>.write</code>,
<code>.open</code>, <code>.creat</code></p>
<p><strong>Day 4</strong> (4 hours): Process Management - This chapter:
Section 5 (process model) - s3.s: Functions <code>.fork</code>,
<code>.exit</code> - s1.s: Function <code>swap</code></p>
<p><strong>Day 5</strong> (4 hours): Device I/O - This chapter: Section
7 (device I/O) - s7.s: <code>pibreak</code> interrupt handler - s4.s:
Character queue functions - s3.s: Device handlers <code>rttyi</code>,
<code>wttyo</code></p>
<p><strong>Day 6</strong> (4 hours): Advanced Topics - This chapter:
Sections 8-9 (boot, data structures) - s5.s: Support functions - s9.s:
Boot loader</p>
<p><strong>Day 7</strong> (4 hours): Mastery - Re-read s1.s with full
understanding - Trace a complete system call from user to kernel and
back - Understand how interrupts, swapping, and I/O interact</p>
<p><strong>Total</strong>: ~28 hours to master PDP-7 Unix source
code</p>
<p>For comparison: - Understanding Linux kernel basics: ~200 hours -
PDP-7 Unix is 7√ó faster to learn</p>
<h2 data-number="4.13" id="conclusion-1"><span class="header-section-number">4.13</span> Conclusion</h2>
<p>You now have a complete architectural overview of PDP-7 Unix:</p>
<ol type="1">
<li><strong>The Big Picture</strong>: Nine modules totaling 2,489
lines</li>
<li><strong>Kernel Organization</strong>: Each file has a specific
purpose</li>
<li><strong>System Calls</strong>: 26 calls organized by category</li>
<li><strong>File System</strong>: Inodes, directories, free blocks</li>
<li><strong>Process Model</strong>: Simple swapping-based
multitasking</li>
<li><strong>Memory Map</strong>: 8K words, carefully allocated</li>
<li><strong>Device I/O</strong>: Seven devices, character queues</li>
<li><strong>Boot Sequence</strong>: From power-on to /init</li>
<li><strong>Data Structures</strong>: Process table, inodes,
directories</li>
<li><strong>Naming Conventions</strong>: Terse but consistent</li>
<li><strong>Complexity Analysis</strong>: Remarkably efficient
design</li>
<li><strong>Reading Map</strong>: How to navigate the source</li>
</ol>
<p>In the following chapters, we‚Äôll dive deep into each area:</p>
<ul>
<li><strong>Chapter 5</strong>: Complete kernel internals
walkthrough</li>
<li><strong>Chapter 6</strong>: Boot process and initialization
details</li>
<li><strong>Chapter 7</strong>: File system implementation
deep-dive</li>
<li><strong>Chapter 8</strong>: Process management internals</li>
<li><strong>Chapter 9</strong>: Device drivers and I/O subsystem</li>
</ul>
<p>Armed with this architectural understanding, you‚Äôre ready to explore
the details. Remember Thompson‚Äôs philosophy: <strong>simplicity is
key</strong>. Every line of code serves a purpose. There is no cruft, no
legacy compatibility, no unnecessary abstraction. Just pure, elegant
systems programming.</p>
<p>Welcome to the heart of Unix.</p>
<h1 data-number="5" id="boot-and-initialization-1"><span class="header-section-number">5</span> Boot and Initialization</h1>
<h2 data-number="5.1" id="the-cold-start-bringing-unix-to-life"><span class="header-section-number">5.1</span> The Cold Start: Bringing Unix
to Life</h2>
<p>One of the most fascinating aspects of any operating system is how it
bootstraps itself from nothing. The PDP-7 Unix boot process is
remarkable for its simplicity‚Äîjust 20 lines of assembly code in
<code>s9.s</code> prepare an empty disk, and another 20 lines in
<code>s8.s</code> (coldentry) bring the system to life.</p>
<h3 data-number="5.1.1" id="historical-context-bootstrapping-in-1969"><span class="header-section-number">5.1.1</span> Historical Context:
Bootstrapping in 1969</h3>
<p>In 1969, ‚Äúbooting‚Äù a computer was a far more involved process than
today:</p>
<ul>
<li><strong>Physical switches</strong>: Operators manually entered
bootstrap code via front panel switches</li>
<li><strong>Paper tape</strong>: Bootstrap loaders were read from
punched paper tape</li>
<li><strong>Magnetic tape</strong>: Larger systems loaded from tape in
multiple stages</li>
<li><strong>No firmware</strong>: Most computers had no ROM; every bit
of code came from external media</li>
</ul>
<p>The PDP-7 Unix boot process was revolutionary for being: -
<strong>Self-contained</strong>: Everything needed was on DECtape -
<strong>Automated</strong>: Minimal operator intervention required -
<strong>Fast</strong>: Complete boot in under 30 seconds -
<strong>Recoverable</strong>: Could rebuild filesystem from scratch</p>
<h2 data-number="5.2" id="the-cold-boot-process-s9.s"><span class="header-section-number">5.2</span> 6.1 The Cold Boot Process
(s9.s)</h2>
<p>The file <code>s9.s</code> contains the <strong>cold boot
loader</strong>, used only during initial installation. Let‚Äôs examine
the complete process:</p>
<h3 data-number="5.2.1" id="stage-1-disk-initialization"><span class="header-section-number">5.2.1</span> Stage 1: Disk
Initialization</h3>
<pre class="assembly"><code>" S9 - Cold boot loader
" Initialize empty filesystem on disk

" Step 1: Zero out the inode list (tracks 2-711)
    lac d2              " Start at track 2
1:
    jms dskwr; 07700    " Write zeros to track
    tad d5              " Add 5 (skip to next inode track)
    dac lac 1b          " Update track number
    sad d712            " Reached track 712?
    jmp 1b              " No, continue loop

" Step 2: Initialize free block list
    jms copy; initfblk; sysdata; 14    " Copy initial free list
    law track712        " Start of data area
    dac s.nxfblk        " Set as first free block</code></pre>
<p><strong>What this does:</strong> 1. Writes zeros to tracks 2-711 (the
inode storage area) 2. Initializes the free block list starting at track
712 3. Sets up the system data structure (sysdata)</p>
<p><strong>Why this matters:</strong> - Creates a blank filesystem ready
for files - Establishes the free block chain - Prepares system
metadata</p>
<h3 data-number="5.2.2" id="stage-2-reading-files-from-paper-tape"><span class="header-section-number">5.2.2</span> Stage 2: Reading Files from
Paper Tape</h3>
<p>The cold boot loader then reads files from paper tape and writes them
to disk:</p>
<pre class="assembly"><code>" Read files from paper tape reader
1:
    jms getc            " Get character count
    sna                 " Zero = end of tape
    jmp bootdone
    dac count           " Store file size

    jms getc            " Get flags
    dac i.flags

    jms getc            " Get link count
    dac i.nlks

    " Read file data into memory buffer
    law buffer
    dac 8              " Auto-increment pointer
2:
    jms getc
    dac 8 i            " Store in buffer
    isz count
    jmp 2b

    " Compute checksum
    jms checksum
    sad expected
    jmp checksumok
    jms halt           " Checksum failed!

checksumok:
    " Write file to disk
    jms allocblocks    " Allocate disk blocks
    jms writefile      " Write data to blocks
    jms createinode    " Create inode entry
    jmp 1b             " Next file</code></pre>
<p><strong>The Paper Tape Format:</strong></p>
<p>Each file on the tape contains:</p>
<pre><code>+------------------+
| File size (words)|  1 word
+------------------+
| Flags            |  1 word (permissions, type)
+------------------+
| Link count       |  1 word
+------------------+
| File data        |  N words
+------------------+
| Checksum         |  1 word (sum of all previous words)
+------------------+</code></pre>
<p><strong>The Installation Tape Contents:</strong></p>
<ol type="1">
<li><strong>System kernel</strong> (tracks 18-100) - The combined s1-s9
code</li>
<li><strong>init</strong> - First user process (inode 3)</li>
<li><strong>sh</strong> - Shell program</li>
<li><strong>ed</strong> - Text editor</li>
<li><strong>as</strong> - Assembler</li>
<li><strong>Basic utilities</strong> - cat, cp, chmod, etc.</li>
</ol>
<h3 data-number="5.2.3" id="stage-3-jump-to-system"><span class="header-section-number">5.2.3</span> Stage 3: Jump to System</h3>
<p>After loading all files:</p>
<pre class="assembly"><code>bootdone:
    " Read inode #3 (init program)
    lac d3
    jms iget            " Get inode for file 3

    " Load init into memory at location 4096
    cla
    jms iread; 4096; 4096

    " Jump to init
    jmp 4096</code></pre>
<h2 data-number="5.3" id="the-warm-boot-process-s8.s-coldentry"><span class="header-section-number">5.3</span> 6.2 The Warm Boot Process (s8.s
coldentry)</h2>
<p>Once Unix is installed, subsequent boots use
<strong>coldentry</strong> in s8.s. This is much faster:</p>
<pre class="assembly"><code>coldentry:
    dzm 0100            " Clear location 100 (re-entrance guard)
    caf                 " Clear all flags
    ion                 " Interrupts on
    clon                " Clock on

    " Initialize display
    law 3072            " Display buffer size
    wcga                " Write to display
    jms dspinit         " Initialize display system
    law dspbuf
    jms movdsp          " Move display buffer

    " Load system data from disk track 0
    cla
    jms dskio; 06000    " Read track 6000 (system data)
    jms copy; dskbuf; sysdata; ulist-sysdata

    " Load and execute init (inode 3)
    lac d3
    jms namei; initf    " Look up "init"
       jms halt         " Failed - halt system
    jms iget            " Get inode
    cla
    jms iread; 4096; 4096   " Read into memory
    jmp 4096                " Execute init</code></pre>
<p><strong>Boot Sequence Timeline:</strong></p>
<pre><code>T+0ms     : Power on, operator loads bootstrap via front panel
T+100ms   : Bootstrap reads coldentry from DECtape track 0
T+500ms   : coldentry executed, display initialized
T+1000ms  : System data loaded from disk
T+2000ms  : init file read from filesystem (inode 3)
T+2500ms  : Jump to init (first user process starts)
T+3000ms  : init forks login processes
T+5000ms  : Login prompt appears on TTY and display</code></pre>
<p><strong>Total boot time: ~5 seconds</strong> (vs.¬†minutes for
contemporary systems!)</p>
<h2 data-number="5.4" id="the-init-process-unixs-first-program"><span class="header-section-number">5.4</span> 6.3 The Init Process: Unix‚Äôs
First Program</h2>
<p>The file <code>init.s</code> is special‚Äîit‚Äôs the first user-space
program that runs. Let‚Äôs examine it in detail:</p>
<h3 data-number="5.4.1" id="forking-login-processes"><span class="header-section-number">5.4.1</span> Forking Login Processes</h3>
<pre class="assembly"><code>" init - first user process

    -1
    sys intrp           " Set interrupt flag
    jms init1           " Fork TTY login
    jms init2           " Fork display/keyboard login

" Main loop - wait for processes to die, respawn them
1:
    sys rmes            " Receive message (blocking wait)
    sad pid1            " Was it TTY process?
    jmp 1f
    sad pid2            " Was it display process?
    jms init2           " Yes, restart display login
    jmp 1               " Wait for next message
1:
    jms init1           " Restart TTY login
    jmp 1               " Continue forever</code></pre>
<p><strong>What this does:</strong> - Forks two login processes (one for
TTY, one for display/keyboard) - Waits for either to terminate (when
user logs out) - Immediately spawns a replacement - Runs forever,
providing perpetual login capability</p>
<p><strong>Revolutionary concept</strong>: The system never stops
accepting logins!</p>
<h3 data-number="5.4.2" id="the-login-sequence"><span class="header-section-number">5.4.2</span> The Login Sequence</h3>
<pre class="assembly"><code>login:
    -1
    sys intrp           " Set interrupt flag
    sys open; password; 0   " Open password file

    " Display "login:" prompt
    lac d1
    sys write; m1; m1s  " Write "login: "

    " Read username
    jms rline           " Read line from terminal
    lac ebufp
    dac tal             " Save end of buffer pointer</code></pre>
<p>The login process then:</p>
<ol type="1">
<li><strong>Reads the password file</strong> (<code>/etc/password</code>
- though path not yet implemented)</li>
<li><strong>Compares username</strong> line by line</li>
<li><strong>Prompts for password</strong> if username matches</li>
<li><strong>Compares password</strong> (plaintext - no encryption in
1970!)</li>
<li><strong>Extracts user info</strong> (UID and home directory)</li>
<li><strong>Changes to home directory</strong></li>
<li><strong>Executes shell</strong></li>
</ol>
<h3 data-number="5.4.3" id="password-file-format"><span class="header-section-number">5.4.3</span> Password File Format</h3>
<p>The password file has one line per user:</p>
<pre><code>username:password:uid:homedir</code></pre>
<p>Example:</p>
<pre><code>ken:.,12345:1:ken
dmr:secret:2:dmr</code></pre>
<p><strong>Parsing the password file:</strong></p>
<pre class="assembly"><code>" Search password file for username
1:
    jms gline           " Get next line from password file
    law ibuf-1          " Input buffer
    dac 8
    law obuf-1          " Username we're searching for
    dac 9

" Compare characters until mismatch or delimiter
2:
    lac 8 i             " Get char from file
    sac o12             " Skip if not ':'
    lac o72             " Load ':'
    sad 9 i             " Compare with user input
    skp                 " Match - continue
    jmp 1b              " No match - try next line
    sad o72             " End of username?
    skp                 " No, keep comparing
    jmp 2b              " Yes, found user!</code></pre>
<p><strong>Extracting the home directory name:</strong></p>
<p>After finding the matching username, init parses the line to extract:
1. <strong>Password</strong> (between first and second ‚Äò:‚Äô) 2.
<strong>UID</strong> (between second and third ‚Äò:‚Äô) 3. <strong>Directory
name</strong> (after third ‚Äò:‚Äô)</p>
<pre class="assembly"><code>" Extract directory name (after third colon)
    dzm nchar           " Character counter
    law dir-1           " Directory name buffer
    dac 8
1:
    lac 9 i             " Get next character
    sad o72             " Is it ':'?
    jmp 1f              " Yes, end of field
    dac char            " No, save character

    " Pack 2 characters per word (9 bits each)
    lac nchar
    sza                 " Is nchar zero?
    jmp 2f              " No, pack with previous char

    " First character - shift left 9 bits
    lac char
    alss 9              " Arithmetic left shift 9
    xor o40             " Toggle case bit (?)
    dac 8 i             " Store first character
    dac nchar           " Mark as having one char
    jmp 1b

2:  " Second character - combine with first
    dzm nchar           " Reset character count
    lac 8               " Get word with first char
    add char            " Add second character
    dac 8               " Store complete word
    jmp 1b

1:  " Directory name extracted</code></pre>
<h3 data-number="5.4.4" id="setting-user-context"><span class="header-section-number">5.4.4</span> Setting User Context</h3>
<p>Once authenticated, init sets up the user environment:</p>
<pre class="assembly"><code>" Extract UID
    jms getuid          " Parse UID from file

" Set user ID
    sys setuid          " Become that user

" Change to user's home directory
    sys chdir; dirname  " Change to /dd/&lt;dirname&gt;

" Look for user's shell
    sys open; sh; 0     " Try to open "sh" in user's dir
    spa                 " Skip if successful
    jmp 1f              " Failed - try default
    jmp havesh

1:  " Link default shell
    sys link; systemsh; sh

havesh:
    " Load shell into memory at high address
    lac d1
    sys read; 017700; 256   " Read shell code

    " Execute shell
    jmp 017700</code></pre>
<p><strong>What‚Äôs happening here:</strong></p>
<ol type="1">
<li><strong>setuid</strong>: Kernel changes process‚Äôs UID to the user‚Äôs
ID</li>
<li><strong>chdir</strong>: Changes current directory to user‚Äôs home
(e.g., <code>/dd/ken</code>)</li>
<li><strong>Shell loading</strong>: Tries to find shell in user‚Äôs
directory</li>
<li><strong>Fallback</strong>: If no user shell, links from
<code>/system/sh</code></li>
<li><strong>Execution</strong>: Loads shell into high memory and jumps
to it</li>
</ol>
<p><strong>Why load at 017700?</strong> - High memory address (near end
of 8K address space) - Avoids overwriting init‚Äôs code - Shell can use
lower memory for its own data</p>
<h2 data-number="5.5" id="memory-layout-during-boot"><span class="header-section-number">5.5</span> 6.4 Memory Layout During
Boot</h2>
<p>The boot process transforms memory from empty to fully
operational:</p>
<h3 data-number="5.5.1" id="t0-power-on"><span class="header-section-number">5.5.1</span> T+0: Power On</h3>
<pre><code>0000-0100:  [Undefined - random bits]
0100-7777:  [Undefined - random bits]</code></pre>
<h3 data-number="5.5.2" id="t100ms-bootstrap-loaded"><span class="header-section-number">5.5.2</span> T+100ms: Bootstrap
Loaded</h3>
<pre><code>0000-0040:  [Bootstrap code - entered via front panel]
0040-7777:  [Undefined]</code></pre>
<h3 data-number="5.5.3" id="t500ms-coldentry-running"><span class="header-section-number">5.5.3</span> T+500ms: Coldentry
Running</h3>
<pre><code>0000-0020:  Interrupt vectors
0020:       System call vector
0100:       coldentry start
0100-2000:  Kernel code (s1-s9)
2000-3000:  Kernel data structures
3000-4000:  Disk buffers
4000-7777:  [Free for user process]</code></pre>
<h3 data-number="5.5.4" id="t5000ms-init-running"><span class="header-section-number">5.5.4</span> T+5000ms: Init Running</h3>
<pre><code>0000-0020:  Interrupt vectors
0020:       System call vector ‚Üí kernel entry
0100-2000:  Kernel code (resident)
2000-3000:  Kernel data
3000-4000:  Disk buffers
4000-5000:  Init code and data
5000-7777:  [Free]</code></pre>
<h3 data-number="5.5.5" id="t10000ms-user-logged-in-shell-running"><span class="header-section-number">5.5.5</span> T+10000ms: User Logged In,
Shell Running</h3>
<pre><code>0000-0020:  Interrupt vectors
0020:       System call vector
0100-2000:  Kernel code
2000-3000:  Kernel data
3000-4000:  Disk buffers
4000-6000:  Shell code and data
6000-7700:  [Free for shell's use]
7700-7777:  [Shell stack area]</code></pre>
<h2 data-number="5.6" id="historical-context-boot-processes-in-1969"><span class="header-section-number">5.6</span> 6.5 Historical Context: Boot
Processes in 1969</h2>
<h3 data-number="5.6.1" id="other-systems-boot-processes"><span class="header-section-number">5.6.1</span> Other Systems‚Äô Boot
Processes</h3>
<p><strong>IBM System/360 (1964)</strong> - <strong>IPL</strong>
(Initial Program Load) via card deck or tape - Multi-stage bootstrap -
Operator intervention at each stage - Boot time: 5-10 minutes</p>
<p><strong>DEC PDP-10 / TOPS-10 (1967)</strong> - Paper tape bootstrap
(50-100 ft of tape) - Manual switch entry of initial loader - Multiple
program loads from tape - Boot time: 10-15 minutes</p>
<p><strong>Multics on GE 645 (1969)</strong> - Complex multi-volume tape
bootstrap - Operator commands at multiple stages - System generation
could take hours - Reboot time: 20-30 minutes</p>
<p><strong>DEC PDP-11 / Unix V1 (1971)</strong> - Single-stage bootstrap
from disk - Much faster than PDP-7 (better hardware) - Boot time: 3-5
seconds</p>
<h3 data-number="5.6.2" id="what-made-pdp-7-unix-different"><span class="header-section-number">5.6.2</span> What Made PDP-7 Unix
Different</h3>
<ol type="1">
<li><strong>Speed</strong>: 5 seconds vs.¬†10-30 minutes for
competitors</li>
<li><strong>Simplicity</strong>: 40 lines of code vs.¬†thousands</li>
<li><strong>Automation</strong>: Minimal operator intervention</li>
<li><strong>Recovery</strong>: Could rebuild filesystem from tape in
minutes</li>
<li><strong>Self-contained</strong>: Everything on one DECtape</li>
</ol>
<h2 data-number="5.7" id="the-evolution-of-unix-booting"><span class="header-section-number">5.7</span> 6.6 The Evolution of Unix
Booting</h2>
<h3 data-number="5.7.1" id="pdp-7-unix-1970"><span class="header-section-number">5.7.1</span> PDP-7 Unix (1970)</h3>
<ul>
<li>Paper tape cold boot</li>
<li>DECtape warm boot</li>
<li>No bootloader separation</li>
</ul>
<h3 data-number="5.7.2" id="unix-v1-1971---pdp-11"><span class="header-section-number">5.7.2</span> Unix V1 (1971) - PDP-11</h3>
<ul>
<li>Disk bootstrap</li>
<li>Separate boot block</li>
<li>Faster hardware</li>
</ul>
<h3 data-number="5.7.3" id="unix-v6-1975---pdp-11"><span class="header-section-number">5.7.3</span> Unix V6 (1975) - PDP-11</h3>
<ul>
<li>Two-stage boot</li>
<li><code>/boot</code> program loads <code>/unix</code></li>
<li>More sophisticated filesystem</li>
</ul>
<h3 data-number="5.7.4" id="unix-v7-1979---pdp-11"><span class="header-section-number">5.7.4</span> Unix V7 (1979) - PDP-11</h3>
<ul>
<li><code>/boot</code> loads <code>/unix</code></li>
<li>Multi-user init with <code>/etc/inittab</code></li>
<li>Run levels introduced</li>
</ul>
<h3 data-number="5.7.5" id="modern-linux-2020s"><span class="header-section-number">5.7.5</span> Modern Linux (2020s)</h3>
<ul>
<li>Multi-stage boot (BIOS/UEFI ‚Üí bootloader ‚Üí kernel ‚Üí init)</li>
<li>GRUB/systemd complexity</li>
<li>But core concepts unchanged:
<ul>
<li>Kernel loads into memory</li>
<li>init starts as PID 1</li>
<li>init spawns login processes</li>
</ul></li>
</ul>
<p><strong>The PDP-7 pattern persists 50+ years later!</strong></p>
<h2 data-number="5.8" id="clever-optimizations"><span class="header-section-number">5.8</span> 6.7 Clever Optimizations</h2>
<h3 data-number="5.8.1" id="re-entrance-guard"><span class="header-section-number">5.8.1</span> Re-entrance Guard</h3>
<pre class="assembly"><code>coldentry:
    dzm 0100            " Clear location 100</code></pre>
<p><strong>Why?</strong> If cold start code runs twice (operator error),
location 0100 will already be zero on second entry. Code could check
this and halt instead of destroying the running system.</p>
<h3 data-number="5.8.2" id="single-track-system-data"><span class="header-section-number">5.8.2</span> Single-Track System Data</h3>
<p>All system metadata fits in one DECtape track (64 words): - Free
block list (10 blocks cached) - Unique ID counter - System time (2
words)</p>
<p><strong>Benefit</strong>: Single disk I/O operation to save/restore
entire system state.</p>
<h3 data-number="5.8.3" id="shared-buffer-space"><span class="header-section-number">5.8.3</span> Shared Buffer Space</h3>
<p>The disk buffer at 07700 is reused: - During boot: holds system data
being loaded - After boot: serves as disk I/O buffer - Saves precious
memory</p>
<h3 data-number="5.8.4" id="init-as-inode-3"><span class="header-section-number">5.8.4</span> Init as Inode 3</h3>
<p><strong>Why number 3?</strong> - Inode 0: Invalid/unused - Inode 1:
Root directory (<code>/</code>) - Inode 2: <code>/dd</code> directory -
Inode 3: <code>init</code> executable</p>
<p>Hard-coding inode 3 means cold boot can find init without a pathname
parser!</p>
<h2 data-number="5.9" id="lessons-from-pdp-7-boot-process"><span class="header-section-number">5.9</span> 6.8 Lessons from PDP-7 Boot
Process</h2>
<h3 data-number="5.9.1" id="design-principles"><span class="header-section-number">5.9.1</span> Design Principles</h3>
<ol type="1">
<li><strong>Simplicity</strong>: Minimal code, minimal steps</li>
<li><strong>Speed</strong>: Every operation essential</li>
<li><strong>Reliability</strong>: Checksum verification, minimal
operator intervention</li>
<li><strong>Recoverability</strong>: Can rebuild from scratch</li>
<li><strong>Self-contained</strong>: No external dependencies beyond
paper tape</li>
</ol>
<h3 data-number="5.9.2" id="modern-relevance"><span class="header-section-number">5.9.2</span> Modern Relevance</h3>
<p>These principles influenced: - <strong>Embedded systems</strong>:
Many still use similar simple boot processes - <strong>Linux
kernel</strong>: ‚ÄúKeep boot fast and simple‚Äù - <strong>Container
systems</strong>: Fast initialization inspired by Unix - <strong>Cloud
instances</strong>: Rapid boot times essential</p>
<h3 data-number="5.9.3" id="what-we-lost"><span class="header-section-number">5.9.3</span> What We Lost</h3>
<p>Modern systems sacrifice boot simplicity for: - Security (secure
boot, verified boot) - Flexibility (multiple init systems,
configuration) - Hardware support (thousands of drivers) - Features
(graphical boot, recovery modes)</p>
<p><strong>Trade-off</strong>: Boot code grew from 40 lines to
millions.</p>
<h2 data-number="5.10" id="hands-on-tracing-a-complete-boot"><span class="header-section-number">5.10</span> 6.9 Hands-On: Tracing a
Complete Boot</h2>
<p>Let‚Äôs trace every instruction during a cold boot:</p>
<pre><code>[Operator enters bootstrap via front panel switches]

1. Load word 052000 into location 0000
2. Load word 064000 into location 0001
   ...
20. Toggle RUN switch

[Bootstrap code executes]
0000: 052000    " Enable paper tape reader
0001: 064000    " Wait for ready
0002: 030100    " Read word into location 0100
...
0020: 600100    " Jump to location 0100

[Coldentry code now executing from location 0100]
0100: 140100    " DZM 0100 (clear re-entrance guard)
0101: 740000    " CAF (clear all flags)
0102: 760002    " ION (interrupts on)
0103: 760020    " CLON (clock on)
0104: 603000    " LAW 3072 (display buffer size)
0105: 764014    " WCGA (write to graphics)
0106: 100500    " JMS dspinit (initialize display)
...

[Hours later, after filesystem is created, init forks shell]
4096: 140100    " Init code at location 4096
...
4200: 100300    " JMS init1 (fork TTY login)
...

[User types username and password]
...

[Shell loads and executes]
7700: 200377    " Shell code at high memory
...
7720: 740013    " OPR RAL (shell processing command)</code></pre>
<p><strong>Complete boot: 5,000+ instructions executed in 5
seconds.</strong></p>
<h2 data-number="5.11" id="conclusion-2"><span class="header-section-number">5.11</span> 6.10 Conclusion</h2>
<p>The PDP-7 Unix boot process exemplifies the Unix philosophy:</p>
<blockquote>
<p><strong>‚ÄúDo one thing and do it well‚Äù</strong></p>
</blockquote>
<p>Boot code has one job: Get the system running as fast as possible
with maximum reliability. At 40 lines of assembly code achieving a
5-second boot time, it succeeded brilliantly.</p>
<p>Every modern Unix-like system still follows this pattern: 1.
Hardware/firmware loads small bootstrap 2. Bootstrap loads kernel into
memory 3. Kernel initializes hardware and data structures 4. Kernel
starts init as first process 5. Init spawns user environment</p>
<p><strong>Thompson and Ritchie got it right the first time. The design
hasn‚Äôt needed fundamental changes in 55 years.</strong></p>
<hr/>
<p><em>‚ÄúPerfection is achieved, not when there is nothing more to add,
but when there is nothing left to take away.‚Äù</em> ‚Äî Antoine de
Saint-Exup√©ry</p>
<p>The PDP-7 Unix boot process achieved perfection.</p>
<h1 data-number="6" id="chapter-7---file-system-implementation"><span class="header-section-number">6</span> Chapter 7 - File System
Implementation</h1>
<p>The PDP-7 Unix file system represents one of the most significant
innovations in computing history. While constrained by hardware
limitations‚Äîjust 8K words of memory and a 300KB DECtape‚ÄîThompson and
Ritchie created a file system design so elegant and powerful that it
forms the foundation of virtually every modern operating system.</p>
<p>This chapter examines the complete implementation: from low-level
disk layout to high-level operations like opening files and traversing
directories. We‚Äôll trace actual code paths, analyze data structures, and
understand why decisions made in 1969 continue to influence operating
system design today.</p>
<h2 data-number="6.1" id="revolutionary-design"><span class="header-section-number">6.1</span> 7.1 Revolutionary Design</h2>
<h3 data-number="6.1.1" id="the-fundamental-innovation"><span class="header-section-number">6.1.1</span> The Fundamental
Innovation</h3>
<p>In 1969, most file systems tightly coupled filenames with file
storage. The PDP-7 Unix file system introduced a radical separation:</p>
<p><strong>Traditional approach (1960s):</strong></p>
<pre><code>Directory: "MYFILE.DAT" ‚Üí Track 142, Sector 5, Length 200 blocks</code></pre>
<p><strong>Unix approach (1969):</strong></p>
<pre><code>Directory: "myfile" ‚Üí Inode 42
Inode 42: ‚Üí Owner, permissions, size, blocks [5123, 5124, 5125, ...]</code></pre>
<h3 data-number="6.1.2" id="why-this-was-revolutionary"><span class="header-section-number">6.1.2</span> Why This Was
Revolutionary</h3>
<p><strong>1. Hard Links Become Trivial</strong></p>
<p>Multiple directory entries can reference the same inode:</p>
<pre><code>/dd/ken/prog.s    ‚Üí Inode 137
/dd/dmr/test.s    ‚Üí Inode 137  (same file!)</code></pre>
<p><strong>2. Renaming Requires No Data Movement</strong></p>
<p>Traditional systems: Copy entire file to new location, delete old.
Unix: Change directory entry, done. Even for gigabyte files (if they
existed).</p>
<p><strong>3. Permissions and Metadata in One Place</strong></p>
<p>No need to update multiple directory entries when changing
permissions or ownership.</p>
<p><strong>4. Efficient Directory Operations</strong></p>
<p>Directories are just files. No special code paths. Reading a
directory is reading a file.</p>
<h3 data-number="6.1.3" id="comparison-with-contemporary-systems"><span class="header-section-number">6.1.3</span> Comparison with Contemporary
Systems</h3>
<p><strong>IBM OS/360 (1964)</strong> - <strong>Organization:</strong>
Partitioned datasets (PDS) with members - <strong>Naming:</strong>
Hierarchical but rigid (dataset.member) - <strong>Metadata:</strong>
Stored in directory entry - <strong>Rename:</strong> Copy entire dataset
- <strong>Links:</strong> Not supported</p>
<p><strong>DEC TOPS-10 (1967)</strong> - <strong>Organization:</strong>
Flat directory per user [PROJECT,PROGRAMMER] - <strong>Naming:</strong>
FILENAME.EXT - <strong>Metadata:</strong> In directory (UFD - User File
Directory) - <strong>Rename:</strong> Copy file -
<strong>Links:</strong> Not supported</p>
<p><strong>Multics (1969)</strong> - <strong>Organization:</strong>
Hierarchical segments - <strong>Naming:</strong> Path-based
(&gt;user&gt;project&gt;file) - <strong>Metadata:</strong> Separate
‚Äúbranch‚Äù structure (similar concept to inode!) -
<strong>Rename:</strong> Complex pointer updates -
<strong>Links:</strong> Supported but heavyweight</p>
<p><strong>PDP-7 Unix (1969)</strong> - <strong>Organization:</strong>
Hierarchical directories - <strong>Naming:</strong> Flexible paths
(/dd/ken/file) - <strong>Metadata:</strong> Inode separate from name -
<strong>Rename:</strong> Update directory entry only -
<strong>Links:</strong> Natural and efficient</p>
<p><strong>Historical note:</strong> Multics influenced Unix, but Unix
simplified the concept dramatically. Where Multics took 10,000 lines to
implement segments, Unix used 300 lines for inodes.</p>
<h2 data-number="6.2" id="disk-layout-1"><span class="header-section-number">6.2</span> 7.2 Disk Layout</h2>
<p>The DECtape in PDP-7 Unix provides 6,400 tracks, each holding 64
words (18 bits each). This gives approximately 300KB of total storage.
The disk is organized into carefully designed regions:</p>
<h3 data-number="6.2.1" id="complete-disk-organization"><span class="header-section-number">6.2.1</span> Complete Disk
Organization</h3>
<pre><code>Track Range    | Contents              | Size        | Purpose
---------------|-----------------------|-------------|---------------------------
0-1            | Bootstrap Code        | 2 tracks    | Cold/warm boot loaders
2-711          | Inode Area            | 710 tracks  | File metadata storage
712-6399       | Data Area             | 5,688 tracks| File content blocks
Track 6000     | System Data           | 1 track     | Free list, unique ID, time</code></pre>
<p><strong>Calculations:</strong></p>
<ul>
<li><strong>Total capacity:</strong> 6,400 tracks √ó 64 words/track √ó 18
bits/word = 7,372,800 bits ‚âà 922KB</li>
<li><strong>Usable data:</strong> 5,688 tracks √ó 64 words = 364,032
words ‚âà 819KB</li>
<li><strong>Inode capacity:</strong> 710 tracks √∑ (12 words/inode √ó 64
words/track) = 3,796 inodes maximum</li>
</ul>
<h3 data-number="6.2.2" id="detailed-memory-map-diagram"><span class="header-section-number">6.2.2</span> Detailed Memory Map
Diagram</h3>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         PDP-7 UNIX DISK LAYOUT                      ‚îÇ
‚îÇ                     (DECtape - 6400 tracks total)                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Track 0-1: BOOTSTRAP AREA (2 tracks = 128 words)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Track 0:  Cold boot loader (s9.s) - Initialize empty FS     ‚îÇ
‚îÇ Track 1:  Warm boot loader (s8.s coldentry) - Normal boot   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Track 2-711: INODE AREA (710 tracks = 45,440 words)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 5.33 inodes per track (12 words each, 64 words per track)   ‚îÇ
‚îÇ Track 2:   Inodes 0-4   (inode 0 unused, 1 = root dir)      ‚îÇ
‚îÇ Track 3:   Inodes 5-9                                        ‚îÇ
‚îÇ Track 4:   Inodes 10-14                                      ‚îÇ
‚îÇ ...                                                          ‚îÇ
‚îÇ Track 711: Inodes 3790-3794                                  ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ Total: ~3,795 inodes maximum                                ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ Special inodes:                                              ‚îÇ
‚îÇ   Inode 0:  Reserved (unused/invalid marker)                ‚îÇ
‚îÇ   Inode 1:  Root directory "/"                              ‚îÇ
‚îÇ   Inode 2:  /dd directory                                   ‚îÇ
‚îÇ   Inode 3:  /dd/sys directory or init                       ‚îÇ
‚îÇ   Inode 4+: User files                                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Track 712-6399: DATA AREA (5,688 tracks = 364,032 words)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ File content blocks (64 words per block)                    ‚îÇ
‚îÇ Track 712:  Block 0 (first data block)                      ‚îÇ
‚îÇ Track 713:  Block 1                                         ‚îÇ
‚îÇ ...                                                          ‚îÇ
‚îÇ Track 6399: Block 5687 (last data block)                    ‚îÇ
‚îÇ                                                              ‚îÇ
‚îÇ Maximum data storage: 5,688 √ó 64 = 364,032 words           ‚îÇ
‚îÇ                     = 656,457 bytes                         ‚îÇ
‚îÇ                     ‚âà 641 KB                                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Track 6000: SYSTEM DATA TRACK (1 track = 64 words) [SPECIAL LOCATION]
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ sysdata structure (saved/restored on every boot):           ‚îÇ
‚îÇ   Word 0:     s.nxfblk  - Next free block overflow pointer  ‚îÇ
‚îÇ   Word 1:     s.nfblks  - Number of free blocks in memory   ‚îÇ
‚îÇ   Words 2-11: s.fblks   - Free block cache (10 blocks)      ‚îÇ
‚îÇ   Word 12:    s.uniq    - Unique ID counter                 ‚îÇ
‚îÇ   Word 13-14: s.tim     - System time (36-bit)              ‚îÇ
‚îÇ   Words 15+:  Reserved for future use                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
<h3 data-number="6.2.3" id="why-this-layout"><span class="header-section-number">6.2.3</span> Why This Layout?</h3>
<p><strong>1. Bootstrap at Track 0</strong> - Tape can be loaded from
beginning - Minimal seeking during boot - Standard location known to
hardware</p>
<p><strong>2. Inodes Near Beginning</strong> - Frequently accessed
(every file operation) - Shorter seek times from track 0 - Grouped
together for locality</p>
<p><strong>3. Data Area is Contiguous</strong> - Simple block allocation
- No fragmentation issues - Easy to calculate block ‚Üí track mapping</p>
<p><strong>4. System Data at Fixed Location</strong> - Known address for
quick access - Written on clean shutdown - Read on warm boot</p>
<h3 data-number="6.2.4" id="physical-block-addressing"><span class="header-section-number">6.2.4</span> Physical Block
Addressing</h3>
<p>Converting inode number to track:</p>
<pre class="assembly"><code>" Given inode number in AC, find its track
inode_to_track:
    lac inode_num          " Load inode number (e.g., 42)
    div d5                 " Divide by 5 (5.33 inodes per track)
    add d2                 " Add 2 (inode area starts at track 2)
    dac track              " Result: track number

    " Offset within track
    lac inode_num
    div d5                 " Divide by 5
    lac mqr                " Get remainder
    mul d12                " Multiply by 12 (words per inode)
    dac offset             " Offset in words from track start</code></pre>
<p><strong>Example:</strong> Inode 42 - Track = 42 √∑ 5 + 2 = 8 + 2 =
Track 10 - Offset = (42 mod 5) √ó 12 = 2 √ó 12 = 24 words into track</p>
<h2 data-number="6.3" id="inodes---the-heart-of-unix"><span class="header-section-number">6.3</span> 7.3 Inodes - The Heart of
Unix</h2>
<p>The inode (index node) is the central data structure. Every file and
directory has exactly one inode containing all metadata.</p>
<h3 data-number="6.3.1" id="inode-structure-12-words"><span class="header-section-number">6.3.1</span> Inode Structure (12
Words)</h3>
<pre class="assembly"><code>" inode - File metadata structure (12 words = 216 bits)
" Location: Disk tracks 2-711, in-memory copy during operations

inode:
   i.flags: .=.+1    " [Word 0] File type and permissions (18 bits)
   i.dskps: .=.+7    " [Words 1-7] Disk block pointers (7 words)
   i.uid:   .=.+1    " [Word 8] Owner user ID
   i.nlks:  .=.+1    " [Word 9] Number of directory links (negative)
   i.size:  .=.+1    " [Word 10] File size in words
   i.uniq:  .=.+1    " [Word 11] Unique ID (validation)
   .=inode+12</code></pre>
<h3 data-number="6.3.2" id="field-by-field-analysis"><span class="header-section-number">6.3.2</span> Field-by-Field Analysis</h3>
<h4 data-number="6.3.2.1" id="i.flags---type-and-permissions-word-0"><span class="header-section-number">6.3.2.1</span> i.flags - Type and
Permissions (Word 0)</h4>
<p>The 18-bit i.flags word packs file type and permissions:</p>
<pre><code>Bit Layout (18 bits):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 17  ‚îÇ 16  ‚îÇ 15  ‚îÇ 14  ‚îÇ  13  12  11 ... 3  2  1  0  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇLarge‚îÇChar ‚îÇ Dir ‚îÇ Res ‚îÇ    Permission Bits (14)      ‚îÇ
‚îÇFile ‚îÇ Dev ‚îÇ     ‚îÇ     ‚îÇ                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Bit 17: Large file (uses indirect blocks)
Bit 16: Character device
Bit 15: Directory
Bit 14: Reserved
Bits 13-0: Permissions and flags</code></pre>
<p><strong>Permission bit layout:</strong></p>
<pre><code>Owner permissions:
  Bit 2: Read    (040000 octal = 100 000 000 000 000 000 binary)
  Bit 1: Write   (020000 octal = 010 000 000 000 000 000 binary)
  Bit 0: Execute (010000 octal = 001 000 000 000 000 000 binary)

Group permissions (not fully implemented in PDP-7):
  Bits 5-3: (Reserved for future use)

Other permissions:
  Bits 8-6: (Reserved for future use)

Setuid bit:
  Bit 9: Setuid (004000 octal)</code></pre>
<p><strong>Common i.flags values:</strong></p>
<pre><code>0100644  Regular file, rw-r--r--
0040755  Directory, rwxr-xr-x
0104755  Executable with setuid, rwsr-xr-x
0120000  Character device</code></pre>
<p><strong>Code to check permissions:</strong></p>
<pre class="assembly"><code>" Check if user can read file
" Input: AC = inode flags, user ID in u.uid
" Output: AC = 0 if allowed, -1 if denied

check_read:
    dac temp_flags        " Save flags
    lac u.uid            " Get user ID
    sad i.uid            " Same as file owner?
    jmp owner_check

    " Not owner - check world permissions (simplified)
    lac temp_flags
    and o4               " Mask world-read bit
    sza                  " Zero = no permission
    jmp allowed
    lac d-1              " Denied
    jmp ret

owner_check:
    lac temp_flags
    and o40000           " Owner read bit
    sza
    jmp allowed
    lac d-1
    jmp ret

allowed:
    cla                  " AC = 0 = allowed
ret:
    " Return</code></pre>
<h4 data-number="6.3.2.2" id="i.dskps---disk-block-pointers-words-1-7"><span class="header-section-number">6.3.2.2</span> i.dskps - Disk Block
Pointers (Words 1-7)</h4>
<p>Seven words provide block addresses:</p>
<p><strong>For small files (‚â§ 7 blocks = 448 words):</strong></p>
<pre><code>i.dskps[0] = Direct block 0 (track number 712-6399)
i.dskps[1] = Direct block 1
i.dskps[2] = Direct block 2
i.dskps[3] = Direct block 3
i.dskps[4] = Direct block 4
i.dskps[5] = Direct block 5
i.dskps[6] = Direct block 6</code></pre>
<p><strong>For large files (&gt; 7 blocks):</strong></p>
<pre><code>i.dskps[0] = Indirect block (points to array of 64 block numbers)
i.dskps[1-6] = Unused (0)</code></pre>
<p><strong>Maximum file size calculation:</strong></p>
<p>Small file max: 7 blocks √ó 64 words = 448 words = 1,008 bytes</p>
<p>Large file max: 1 indirect block ‚Üí 64 pointers √ó 64 words/block =
4,096 words = 9,216 bytes</p>
<h4 data-number="6.3.2.3" id="i.uid---owner-user-id-word-8"><span class="header-section-number">6.3.2.3</span> i.uid - Owner User ID (Word
8)</h4>
<p>Simple 18-bit user ID. Special values: - 0 or -1: Superuser (root) -
1-32767: Regular users</p>
<h4 data-number="6.3.2.4" id="i.nlks---link-count-word-9"><span class="header-section-number">6.3.2.4</span> i.nlks - Link Count (Word
9)</h4>
<p><strong>Important:</strong> Stored as negative number!</p>
<pre><code>i.nlks = -1  ‚Üí  1 link (normal file)
i.nlks = -2  ‚Üí  2 links (hard-linked file)
i.nlks = -3  ‚Üí  3 links</code></pre>
<p><strong>Why negative?</strong> Efficient check for ‚Äúno links‚Äù:</p>
<pre class="assembly"><code>    lac i.nlks
    sma              " Skip if minus (has links)
    jmp free_inode   " Zero or positive = no links, free it</code></pre>
<h4 data-number="6.3.2.5" id="i.size---file-size-word-10"><span class="header-section-number">6.3.2.5</span> i.size - File Size (Word
10)</h4>
<p>Size in <strong>words</strong>, not bytes. Maximum value: 4096 (for
large files).</p>
<h4 data-number="6.3.2.6" id="i.uniq---unique-id-word-11"><span class="header-section-number">6.3.2.6</span> i.uniq - Unique ID (Word
11)</h4>
<p>Global counter incremented on every file creation. Prevents stale
directory entries from accessing wrong files:</p>
<pre class="assembly"><code>" Creating new file
    lac s.uniq           " Get global counter
    add d1              " Increment
    dac s.uniq          " Store back
    dac new_inode+i.uniq " Set in new inode
    dac dir_entry+d.uniq " Set in directory entry</code></pre>
<p>Later, when accessing file:</p>
<pre class="assembly"><code>" Validate directory entry still points to correct file
    lac dir_entry+d.uniq
    sad inode+i.uniq
    jmp ok              " Match - safe to use
    " Mismatch - file was deleted and inode reused!
    jms error</code></pre>
<h3 data-number="6.3.3" id="complete-inode-code-analysis"><span class="header-section-number">6.3.3</span> Complete inode Code
Analysis</h3>
<h4 data-number="6.3.3.1" id="iget---load-inode-from-disk"><span class="header-section-number">6.3.3.1</span> iget - Load Inode from
Disk</h4>
<pre class="assembly"><code>" iget - Get inode from disk
" Input: AC = inode number
" Output: Inode loaded into core at 'inodebuf'
" Destroys: All registers

iget:
    0                    " Return address
    dac iget_inum       " Save inode number

    " Calculate track number
    div d5              " Divide by 5 inodes per track
    add d2              " Add 2 (inode area starts at track 2)
    dac track_num       " Save track number

    " Calculate offset within track
    lac iget_inum
    div d5
    lac mqr             " Remainder in MQ
    mul d12             " √ó 12 words per inode
    dac inode_offset

    " Read track into buffer
    lac track_num
    jms dskrd; inodeblock  " Read track

    " Copy inode to inodebuf
    law inodeblock-1
    add inode_offset    " Start address
    dac 8               " Auto-increment pointer
    law inodebuf-1
    dac 9
    law d12             " 12 words to copy
    dac count

1:  lac 8 i             " Copy word
    dac 9 i
    isz count
    jmp 1b

    " Return inode number in AC
    lac iget_inum
    jmp iget i          " Return

iget_inum: 0
track_num: 0
inode_offset: 0
inodeblock: .=.+64      " Buffer for track
inodebuf: .=.+12        " Active inode</code></pre>
<h4 data-number="6.3.3.2" id="iput---write-inode-to-disk"><span class="header-section-number">6.3.3.2</span> iput - Write Inode to
Disk</h4>
<pre class="assembly"><code>" iput - Put inode back to disk
" Input: AC = inode number, inodebuf contains modified inode
" Output: Inode written to disk

iput:
    0
    dac iput_inum

    " Calculate track and offset (same as iget)
    div d5
    add d2
    dac track_num

    lac iput_inum
    div d5
    lac mqr
    mul d12
    dac inode_offset

    " Read track (need to preserve other inodes)
    lac track_num
    jms dskrd; inodeblock

    " Copy inodebuf into correct position
    law inodebuf-1
    dac 8
    law inodeblock-1
    add inode_offset
    dac 9
    law d12
    dac count

1:  lac 8 i
    dac 9 i
    isz count
    jmp 1b

    " Write track back
    lac track_num
    jms dskwr; inodeblock

    jmp iput i

iput_inum: 0</code></pre>
<h3 data-number="6.3.4" id="example-inode-a-text-file"><span class="header-section-number">6.3.4</span> Example Inode: A Text
File</h3>
<p>Let‚Äôs examine a real inode for <code>/dd/ken/prog.s</code>:</p>
<pre><code>Offset  Field      Value (Octal)  Meaning
------  -----      -------------  -------
0       i.flags    040644         Regular file, rw-r--r--
1       i.dskps[0] 005231        Block 5231 (track 5943)
2       i.dskps[1] 005232        Block 5232
3       i.dskps[2] 005233        Block 5233
4       i.dskps[3] 000000        (unused)
5       i.dskps[4] 000000        (unused)
6       i.dskps[5] 000000        (unused)
7       i.dskps[6] 000000        (unused)
8       i.uid      000001         Owner: ken (UID 1)
9       i.nlks     177777         -1 in 18-bit = 1 link
10      i.size     000173         123 words = 276 bytes
11      i.uniq     001437         Unique ID 799</code></pre>
<p><strong>Interpretation:</strong> - Regular file (bit 15 clear, bit 16
clear, bit 17 clear) - Owner can read/write (bits 0-1 set for owner) -
Others can read (bit 2 set for world) - Occupies 3 blocks (123 words √∑
64 words/block = 2.9 ‚Üí 3 blocks) - Single directory link - Created as
the 799th file since system initialization</p>
<h2 data-number="6.4" id="directories"><span class="header-section-number">6.4</span> 7.4 Directories</h2>
<p>A directory is simply a file with the directory bit set (i.flags bit
15). Its content is an array of directory entries.</p>
<h3 data-number="6.4.1" id="directory-entry-structure-8-words"><span class="header-section-number">6.4.1</span> Directory Entry Structure (8
Words)</h3>
<pre class="assembly"><code>" Directory entry (8 words)
dnode:
   d.i:    .=.+1    " [Word 0] Inode number
   d.name: .=.+4    " [Words 1-4] Filename (4 words = 6-8 chars)
   d.uniq: .=.+1    " [Word 5] Unique ID (must match inode)
   .=.+2             " [Words 6-7] Padding/reserved
   .=dnode+8</code></pre>
<h3 data-number="6.4.2" id="filename-encoding"><span class="header-section-number">6.4.2</span> Filename Encoding</h3>
<p>PDP-7 stores two 9-bit characters per word:</p>
<pre><code>Word layout (18 bits):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Char 0  ‚îÇ Char 1  ‚îÇ
‚îÇ (9 bits)‚îÇ (9 bits)‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

4 words = 8 characters maximum, but only 6 used in practice</code></pre>
<p><strong>Example: ‚Äúprog.s‚Äù filename</strong></p>
<pre><code>ASCII values (9-bit):
  'p' = 160 (octal) = 001 110 000
  'r' = 162 (octal) = 001 110 010
  'o' = 157 (octal) = 001 101 111
  'g' = 147 (octal) = 001 100 111
  '.' = 056 (octal) = 000 101 110
  's' = 163 (octal) = 001 110 011

Packing:
  d.name[0] = 'p' 'r' = 160162 (octal)
  d.name[1] = 'o' 'g' = 157147 (octal)
  d.name[2] = '.' 's' = 056163 (octal)
  d.name[3] = '\0''\0' = 000000 (padding)</code></pre>
<p><strong>Code to pack filename:</strong></p>
<pre class="assembly"><code>" Pack ASCII string into directory name format
" Input: String at 'filename', output at 'dname'

pack_name:
    0
    law filename-1
    dac 8               " Source pointer
    law dname-1
    dac 9               " Dest pointer
    law d4              " 4 words max
    dac word_count

pack_word:
    lac 8 i             " Get first char
    sza                 " Check for null
    jmp 1f
    " Null terminator - fill rest with zeros
    cla
    jmp pack_store

1:  alss 9             " Shift to high 9 bits
    dac temp
    lac 8 i            " Get second char
    sza
    jmp 2f
    " Second char is null
    lac temp
    jmp pack_store

2:  add temp           " Combine both chars

pack_store:
    dac 9 i            " Store packed word
    isz word_count
    jmp pack_word

    jmp pack_name i

temp: 0
word_count: 0</code></pre>
<h3 data-number="6.4.3" id="example-directory-root-directory"><span class="header-section-number">6.4.3</span> Example Directory: Root
Directory ‚Äú/‚Äù</h3>
<p>Inode 1 contents (the root directory):</p>
<pre><code>Directory entry 0: (current directory)
  d.i    = 1          " Points to self
  d.name = ". "       " 056000, 000000, 000000, 000000
  d.uniq = 1

Directory entry 1: (parent directory)
  d.i    = 1          " Root's parent is root
  d.name = ".."       " 056056, 000000, 000000, 000000
  d.uniq = 1

Directory entry 2:
  d.i    = 2          " /dd directory
  d.name = "dd"       " 144144, 000000, 000000, 000000
  d.uniq = 2

Directory entry 3:
  d.i    = 15         " /sys directory
  d.name = "sys"      " 163171, 163000, 000000, 000000
  d.uniq = 15</code></pre>
<p><strong>Total directory size:</strong> 4 entries √ó 8 words = 32
words</p>
<h3 data-number="6.4.4" id="directory-operations-code"><span class="header-section-number">6.4.4</span> Directory Operations
Code</h3>
<h4 data-number="6.4.4.1" id="dget---read-directory-entry"><span class="header-section-number">6.4.4.1</span> dget - Read Directory
Entry</h4>
<pre class="assembly"><code>" dget - Get directory entry
" Input: AC = entry number, u.cdir = directory inode
" Output: dirbuf contains entry

dget:
    0
    dac entry_num       " Save entry number
    mul d8              " √ó 8 words per entry
    dac byte_offset     " Offset in words

    " Get directory inode
    lac u.cdir
    jms iget            " Load into inodebuf

    " Calculate which block contains entry
    lac byte_offset
    div d64             " 64 words per block
    dac block_num
    lac mqr
    dac block_offset

    " Get block number from inode
    lac block_num
    sad d0
    lac inodebuf+i.dskps+0   " Block 0
    sad d1
    lac inodebuf+i.dskps+1   " Block 1
    " ... (more blocks)

    " Read block
    jms dskrd; dirbuf_block

    " Copy entry to dirbuf
    law dirbuf_block-1
    add block_offset
    dac 8
    law dirbuf-1
    dac 9
    law d8
    dac count

1:  lac 8 i
    dac 9 i
    isz count
    jmp 1b

    jmp dget i

entry_num: 0
byte_offset: 0
block_num: 0
block_offset: 0
dirbuf_block: .=.+64
dirbuf: .=.+8</code></pre>
<h4 data-number="6.4.4.2" id="dput---write-directory-entry"><span class="header-section-number">6.4.4.2</span> dput - Write Directory
Entry</h4>
<pre class="assembly"><code>" dput - Write directory entry
" Input: AC = entry number, dirbuf = entry to write

dput:
    0
    " Similar to dget but copies from dirbuf to disk
    " (Code mirrors dget with reversed copy direction)
    jmp dput i</code></pre>
<h4 data-number="6.4.4.3" id="search_dir---find-file-in-directory"><span class="header-section-number">6.4.4.3</span> search_dir - Find File in
Directory</h4>
<pre class="assembly"><code>" search_dir - Search directory for filename
" Input: AC = directory inode, 'searchname' = name to find
" Output: AC = inode number if found, -1 if not found

search_dir:
    0
    dac dir_inode

    " Load directory inode
    lac dir_inode
    jms iget

    " Get directory size in entries
    lac inodebuf+i.size
    div d8              " Size in words √∑ 8 words per entry
    dac num_entries

    " Search each entry
    cla
    dac entry_index

search_loop:
    lac entry_index
    jms dget            " Get entry

    " Check if entry is used (d.i ‚â† 0)
    lac dirbuf+d.i
    sza
    jmp check_name
    jmp next_entry      " Empty entry, skip

check_name:
    " Compare names (4 words)
    law searchname-1
    dac 8
    law dirbuf+d.name-1
    dac 9
    law d4
    dac count

compare_loop:
    lac 8 i
    sad 9 i
    jmp name_match
    " Mismatch
    jmp next_entry

name_match:
    isz count
    jmp compare_loop

    " All 4 words matched!
    " Verify unique ID
    lac dirbuf+d.i
    jms iget            " Load file's inode
    lac inodebuf+i.uniq
    sad dirbuf+d.uniq
    jmp found_it
    " Unique ID mismatch - stale entry
    jmp next_entry

found_it:
    lac dirbuf+d.i      " Return inode number
    jmp search_dir i

next_entry:
    isz entry_index
    lac entry_index
    sad num_entries
    jmp not_found
    jmp search_loop

not_found:
    lac d-1
    jmp search_dir i

dir_inode: 0
num_entries: 0
entry_index: 0
searchname: .=.+4       " Caller fills this</code></pre>
<h2 data-number="6.5" id="free-block-management-1"><span class="header-section-number">6.5</span> 7.5 Free Block Management</h2>
<p>The free block list uses an elegant two-level cache structure that
minimizes disk I/O.</p>
<h3 data-number="6.5.1" id="free-block-list-structure"><span class="header-section-number">6.5.1</span> Free Block List
Structure</h3>
<p><strong>In-memory cache (in sysdata structure):</strong></p>
<pre class="assembly"><code>" sysdata - System-wide data (64 words total)
sysdata:
    s.nxfblk: .=.+1    " Next overflow block pointer
    s.nfblks: .=.+1    " Number of blocks in cache (0-10)
    s.fblks:  .=.+10   " Cached free block numbers
    s.uniq:   .=.+1    " Unique ID counter
    s.tim:    .=.+2    " System time (36-bit)
    .=.+49             " Reserved
    .=sysdata+64</code></pre>
<p><strong>On-disk overflow blocks:</strong></p>
<p>When the in-memory cache overflows, blocks are stored on disk. Each
overflow block contains:</p>
<pre><code>Word 0:     Pointer to next overflow block (or 0)
Words 1-63: Free block numbers (up to 63 blocks)</code></pre>
<h3 data-number="6.5.2" id="visual-representation"><span class="header-section-number">6.5.2</span> Visual Representation</h3>
<pre><code>In-Memory (sysdata):                     On-Disk Overflow:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ s.nxfblk: 5234  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ s.nfblks: 10         ‚îÇ    ‚îÇ            ‚îÇ Block 5234:     ‚îÇ
‚îÇ s.fblks[0]: 1234     ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ&gt; ‚îÇ  [0]: 5500      ‚îÇ ‚Üí Block 5500...
‚îÇ s.fblks[1]: 1235     ‚îÇ                 ‚îÇ  [1]: 3456      ‚îÇ
‚îÇ s.fblks[2]: 1236     ‚îÇ                 ‚îÇ  [2]: 3457      ‚îÇ
‚îÇ s.fblks[3]: 1237     ‚îÇ                 ‚îÇ  ...            ‚îÇ
‚îÇ s.fblks[4]: 1238     ‚îÇ                 ‚îÇ  [63]: 3519     ‚îÇ
‚îÇ s.fblks[5]: 1239     ‚îÇ                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ s.fblks[6]: 1240     ‚îÇ
‚îÇ s.fblks[7]: 1241     ‚îÇ
‚îÇ s.fblks[8]: 1242     ‚îÇ
‚îÇ s.fblks[9]: 1243     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

When s.nfblks = 10 (full), allocating a block:
1. Return s.fblks[9] (block 1243)
2. Decrement s.nfblks to 9

When s.nfblks = 0 (empty), allocating a block:
1. Read block s.nxfblk (5234)
2. s.nxfblk = block[0] (5500)
3. Copy block[1..63] ‚Üí s.fblks[0..62]
4. s.nfblks = 63
5. Return s.fblks[62]</code></pre>
<h3 data-number="6.5.3" id="allocation-algorithm-alloc"><span class="header-section-number">6.5.3</span> Allocation Algorithm
(alloc)</h3>
<pre class="assembly"><code>" alloc - Allocate a free block
" Input: None
" Output: AC = block number, or halts if no blocks available

alloc:
    0

    " Check if we have blocks in cache
    lac s.nfblks
    sza                 " Zero blocks?
    jmp alloc_from_cache

    " Cache empty - need to refill from overflow
    lac s.nxfblk
    sza                 " Zero = no more blocks!
    jmp refill_cache

    " Out of disk space!
    jms halt_msg; "OUT OF DISK SPACE\0"

refill_cache:
    " Read overflow block
    lac s.nxfblk
    dac temp_block
    jms dskrd; overflow_buf

    " Get next overflow pointer
    lac overflow_buf+0
    dac s.nxfblk

    " Copy blocks to cache
    law overflow_buf
    dac 8
    law s.fblks-1
    dac 9
    law d63             " 63 blocks (word 0 is pointer)
    dac count

1:  lac 8 i
    dac 9 i
    isz count
    jmp 1b

    law d63
    dac s.nfblks

    " Mark overflow block as allocated
    " (Use it as the allocated block to avoid waste)
    lac temp_block
    jmp alloc i

alloc_from_cache:
    " Decrement count
    lac s.nfblks
    add d-1
    dac s.nfblks

    " Get block from cache
    tad s.fblks         " Add to base address
    dac 8
    lac 8 i             " Get block number

    " Clear the block before returning
    dac return_block
    jms dskwr; zero_block

    lac return_block
    jmp alloc i

temp_block: 0
return_block: 0
overflow_buf: .=.+64
zero_block: .=.+64      " Pre-zeroed block</code></pre>
<h3 data-number="6.5.4" id="free-algorithm-free"><span class="header-section-number">6.5.4</span> Free Algorithm (free)</h3>
<pre class="assembly"><code>" free - Return block to free list
" Input: AC = block number to free

free:
    0
    dac block_to_free

    " Check if cache has room
    lac s.nfblks
    sad d10             " Cache full (10 blocks)?
    jmp overflow_cache

    " Add to cache
    tad s.fblks         " Calculate address
    dac 8
    lac block_to_free
    dac 8 i             " Store in cache

    " Increment count
    lac s.nfblks
    add d1
    dac s.nfblks

    jmp free i

overflow_cache:
    " Cache full - flush to disk
    " Use the block being freed as new overflow block
    lac block_to_free
    dac new_overflow

    " Write current cache to this block
    law overflow_buf
    dac 9

    " Word 0: pointer to previous overflow
    lac s.nxfblk
    dac 9 i

    " Words 1-63: copy cache (but only 10 valid)
    law s.fblks-1
    dac 8
    law d10
    dac count

1:  lac 8 i
    dac 9 i
    isz count
    jmp 1b

    " Write overflow block
    lac new_overflow
    jms dskwr; overflow_buf

    " Update in-memory pointers
    lac new_overflow
    dac s.nxfblk
    lac d1              " One block in cache (the one we just freed)
    dac s.nfblks

    jmp free i

block_to_free: 0
new_overflow: 0</code></pre>
<h3 data-number="6.5.5" id="why-this-design"><span class="header-section-number">6.5.5</span> Why This Design?</h3>
<p><strong>Advantages:</strong></p>
<ol type="1">
<li><strong>Fast common case:</strong> Allocate/free usually requires no
disk I/O</li>
<li><strong>Memory efficient:</strong> Only 12 words for entire free
list management</li>
<li><strong>Handles overflow gracefully:</strong> Scales to any disk
size</li>
<li><strong>Simple:</strong> ~50 lines of code total</li>
</ol>
<p><strong>Disadvantages:</strong></p>
<ol type="1">
<li><strong>Fragmentation:</strong> Blocks allocated in order used, no
locality</li>
<li><strong>No wear leveling:</strong> Same blocks reused
repeatedly</li>
<li><strong>Crash vulnerability:</strong> Cache not synced to disk
continuously</li>
</ol>
<p><strong>Historical note:</strong> This exact algorithm (with minor
enhancements) was used through Unix V6 (1975). Modern file systems use
bitmaps or B-trees, but the basic concept of caching free blocks
persists.</p>
<h2 data-number="6.6" id="file-operations"><span class="header-section-number">6.6</span> 7.6 File Operations</h2>
<h3 data-number="6.6.1" id="open---opening-a-file"><span class="header-section-number">6.6.1</span> 7.6.1 open - Opening a
File</h3>
<p>The <code>open</code> system call converts a filename to a file
descriptor.</p>
<p><strong>System call interface:</strong></p>
<pre class="assembly"><code>sys open; filename; mode   " mode: 0=read, 1=write, 2=read+write</code></pre>
<p><strong>Complete implementation:</strong></p>
<pre class="assembly"><code>" .open - Open file system call
" User provides: filename address, access mode
" Returns: File descriptor (0-9) in AC, or -1 on error

.open:
    " Get filename address from user space
    lac u.base          " System call arg 1
    dac filename_ptr

    " Get access mode
    lac u.base+1        " System call arg 2
    dac access_mode

    " Resolve filename to inode
    lac filename_ptr
    jms namei           " Returns inode number in AC
    spa                 " Positive = found
    jmp open_error      " Negative = not found

    dac file_inode

    " Get inode metadata
    lac file_inode
    jms iget            " Load into inodebuf

    " Check permissions
    lac inodebuf+i.flags
    jms check_access; access_mode
    spa
    jmp open_perm_error

    " Find free file descriptor slot
    jms find_free_fd    " Returns FD number in AC
    spa
    jmp open_too_many   " All 10 FDs in use

    dac fd_num

    " Calculate FD address in u.ofiles
    mul d3              " √ó 3 words per FD
    tad u.ofiles
    dac fd_addr

    " Initialize file descriptor
    law fd_addr
    dac 9

    lac access_mode
    add o100000         " Set "in use" bit
    dac 9 i             " f.flags

    cla                 " Position = 0
    dac 9 i             " f.badd (byte address)

    lac file_inode
    dac 9 i             " f.i (inode number)

    " Return file descriptor number
    lac fd_num
    jmp .open i

open_error:
    lac d-1
    jmp .open i

open_perm_error:
    lac d-1
    jmp .open i

open_too_many:
    lac d-1
    jmp .open i

filename_ptr: 0
access_mode: 0
file_inode: 0
fd_num: 0
fd_addr: 0</code></pre>
<p><strong>Supporting function: find_free_fd</strong></p>
<pre class="assembly"><code>" find_free_fd - Find unused file descriptor
" Output: AC = FD number (0-9), or -1 if all used

find_free_fd:
    0
    law d10
    dac fd_count
    cla
    dac fd_index

check_fd:
    " Calculate address of FD
    lac fd_index
    mul d3
    tad u.ofiles
    dac fd_ptr

    " Check if in use (high bit of f.flags)
    lac fd_ptr
    dac 8
    lac 8 i             " Get f.flags
    and o100000         " Check "in use" bit
    sza                 " Zero = not in use
    jmp try_next

    " Found free FD
    lac fd_index
    jmp find_free_fd i

try_next:
    isz fd_index
    isz fd_count
    jmp check_fd

    " All FDs in use
    lac d-1
    jmp find_free_fd i

fd_count: 0
fd_index: 0
fd_ptr: 0</code></pre>
<h3 data-number="6.6.2" id="read---reading-from-a-file"><span class="header-section-number">6.6.2</span> 7.6.2 read - Reading from a
File</h3>
<p><strong>System call interface:</strong></p>
<pre class="assembly"><code>sys read; fd; buffer; count   " Read 'count' words into 'buffer'</code></pre>
<p><strong>Implementation:</strong></p>
<pre class="assembly"><code>" .read - Read from file
" Input: FD number, buffer address, word count
" Output: AC = words read, or -1 on error

.read:
    " Get file descriptor
    lac u.base          " FD number
    jms get_fd_addr     " Returns FD address in AC
    spa
    jmp read_bad_fd

    dac fd_addr
    law fd_addr
    dac 8

    " Extract FD fields
    lac 8 i
    dac f.flags
    lac 8 i
    dac f.badd          " Current position
    lac 8 i
    dac f.i             " Inode number

    " Get buffer and count
    lac u.base+1
    dac buffer_addr
    lac u.base+2
    dac read_count

    " Load inode
    lac f.i
    jms iget

    " Check if position beyond EOF
    lac f.badd
    sad inodebuf+i.size
    jmp read_eof        " At end of file

    " Read character by character (simple but slow!)
    cla
    dac words_read
    law buffer_addr-1
    dac 9               " Output pointer

read_loop:
    " Calculate which block contains current position
    lac f.badd
    div d64             " Block number
    dac block_num
    lac mqr
    dac block_offset    " Offset within block

    " Get block address from inode
    lac block_num
    jms get_block_addr  " Returns track number
    spa
    jmp read_error

    " Read block
    jms dskrd; block_buf

    " Get word from block
    law block_buf-1
    add block_offset
    dac 8
    lac 8 i
    dac 9 i             " Store in user buffer

    " Update position
    lac f.badd
    add d1
    dac f.badd

    " Check for EOF
    sad inodebuf+i.size
    jmp read_done

    " Update count
    isz words_read
    lac words_read
    sad read_count
    jmp read_done
    jmp read_loop

read_done:
    " Update FD position
    lac fd_addr
    law fd_addr
    dac 8
    lac 8 i             " Skip f.flags
    lac f.badd
    dac 8 i             " Update f.badd

    " Return words read
    lac words_read
    jmp .read i

read_eof:
    cla                 " 0 words read
    jmp .read i

read_bad_fd:
read_error:
    lac d-1
    jmp .read i

fd_addr: 0
f.flags: 0
f.badd: 0
f.i: 0
buffer_addr: 0
read_count: 0
words_read: 0
block_num: 0
block_offset: 0
block_buf: .=.+64</code></pre>
<p><strong>Note:</strong> This simple implementation reads one word at a
time. Real implementation would buffer entire blocks for efficiency.</p>
<h3 data-number="6.6.3" id="write---writing-to-a-file"><span class="header-section-number">6.6.3</span> 7.6.3 write - Writing to a
File</h3>
<pre class="assembly"><code>" .write - Write to file
" Input: FD number, buffer address, word count
" Output: AC = words written, or -1 on error

.write:
    " Similar to .read but:
    " 1. Check write permission
    " 2. Allocate new blocks if needed
    " 3. Update i.size if file grows
    " 4. Write blocks back to disk

    " (Implementation mirrors .read with modifications)
    jmp .write i</code></pre>
<h3 data-number="6.6.4" id="creat---creating-a-file"><span class="header-section-number">6.6.4</span> 7.6.4 creat - Creating a
File</h3>
<p><strong>System call interface:</strong></p>
<pre class="assembly"><code>sys creat; filename; mode   " Create file with permissions 'mode'</code></pre>
<p><strong>Implementation:</strong></p>
<pre class="assembly"><code>" .creat - Create new file
" Input: filename, permission mode
" Output: FD number, or -1 on error

.creat:
    lac u.base
    dac filename_ptr
    lac u.base+1
    dac perm_mode

    " Check if file already exists
    lac filename_ptr
    jms namei
    spa                 " Exists?
    jmp create_new

    " File exists - truncate it
    dac existing_inode
    jms iget

    " Free all blocks
    jms free_all_blocks; inodebuf

    " Reset size
    dzm inodebuf+i.size

    lac existing_inode
    jms iput

    " Open the truncated file
    lac filename_ptr
    law d1              " Write mode
    jms .open
    jmp .creat i

create_new:
    " Allocate new inode
    jms icreat          " Returns inode number
    spa
    jmp creat_no_inodes

    dac new_inode
    jms iget

    " Initialize inode
    lac perm_mode
    dac inodebuf+i.flags

    " Clear block pointers
    law inodebuf+i.dskps-1
    dac 8
    law d7
    dac count
1:  dzm 8 i
    isz count
    jmp 1b

    lac u.uid
    dac inodebuf+i.uid

    lac d-1             " -1 = 1 link
    dac inodebuf+i.nlks

    dzm inodebuf+i.size

    lac s.uniq
    add d1
    dac s.uniq
    dac inodebuf+i.uniq

    " Write inode
    lac new_inode
    jms iput

    " Add to directory
    lac u.cdir          " Current directory
    jms add_dir_entry; filename_ptr; new_inode
    spa
    jmp creat_dir_full

    " Open the new file
    lac filename_ptr
    law d1              " Write mode
    jms .open
    jmp .creat i

creat_no_inodes:
creat_dir_full:
    lac d-1
    jmp .creat i

filename_ptr: 0
perm_mode: 0
existing_inode: 0
new_inode: 0</code></pre>
<h3 data-number="6.6.5" id="link---creating-hard-links"><span class="header-section-number">6.6.5</span> 7.6.5 link - Creating Hard
Links</h3>
<p><strong>System call interface:</strong></p>
<pre class="assembly"><code>sys link; oldname; newname   " Create newname ‚Üí same inode as oldname</code></pre>
<p><strong>Implementation:</strong></p>
<pre class="assembly"><code>" .link - Create hard link
" Input: existing filename, new filename
" Output: 0 on success, -1 on error

.link:
    " Get existing file's inode
    lac u.base
    jms namei
    spa
    jmp link_not_found

    dac link_inode
    jms iget

    " Increment link count
    lac inodebuf+i.nlks
    add d-1             " Remember: stored negative
    dac inodebuf+i.nlks

    lac link_inode
    jms iput

    " Add new directory entry
    lac u.cdir
    lac u.base+1        " New filename
    jms add_dir_entry; link_inode
    spa
    jmp link_dir_full

    cla                 " Success
    jmp .link i

link_not_found:
link_dir_full:
    lac d-1
    jmp .link i

link_inode: 0</code></pre>
<h3 data-number="6.6.6" id="unlink---removing-directory-entries"><span class="header-section-number">6.6.6</span> 7.6.6 unlink - Removing
Directory Entries</h3>
<pre class="assembly"><code>" .unlink - Remove directory entry
" Input: filename
" Output: 0 on success, -1 on error

.unlink:
    " Find file
    lac u.base
    jms namei
    spa
    jmp unlink_not_found

    dac unlink_inode
    jms iget

    " Increment link count (toward zero)
    lac inodebuf+i.nlks
    add d1              " -2 ‚Üí -1, -1 ‚Üí 0
    dac inodebuf+i.nlks

    " If links = 0, free inode and blocks
    sma                 " Skip if still negative (has links)
    jms free_inode; unlink_inode

    " Remove directory entry
    lac u.cdir
    lac u.base
    jms remove_dir_entry

    lac unlink_inode
    jms iput

    cla
    jmp .unlink i

unlink_not_found:
    lac d-1
    jmp .unlink i

unlink_inode: 0</code></pre>
<h2 data-number="6.7" id="path-name-lookup"><span class="header-section-number">6.7</span> 7.7 Path Name Lookup</h2>
<p>The <code>namei</code> function is the core of Unix pathname
resolution.</p>
<h3 data-number="6.7.1" id="namei-algorithm"><span class="header-section-number">6.7.1</span> namei Algorithm</h3>
<p><strong>Input:</strong> Pathname string (e.g., ‚Äú/dd/ken/prog.s‚Äù or
‚Äúsubdir/file‚Äù) <strong>Output:</strong> Inode number, or -1 if not
found</p>
<p><strong>Algorithm:</strong></p>
<ol type="1">
<li>Start with root inode (1) for absolute paths, current directory
(u.cdir) for relative</li>
<li>Extract first component (‚Äúdd‚Äù)</li>
<li>Search directory for component</li>
<li>If found and not last component, load that inode as directory</li>
<li>Repeat for next component</li>
<li>Return final inode number</li>
</ol>
<pre class="assembly"><code>" namei - Name to inode lookup
" Input: AC = pointer to pathname string
" Output: AC = inode number, or -1 if not found

namei:
    0
    dac path_ptr

    " Check if absolute or relative path
    law path_ptr
    dac 8
    lac 8 i             " Get first character
    and o777            " Mask to char (9 bits)
    sad o57             " '/' = 057 octal
    jmp absolute_path

    " Relative path - start with current directory
    lac u.cdir
    jmp start_lookup

absolute_path:
    " Absolute path - start with root
    law d1              " Root inode = 1

    " Skip leading '/'
    lac path_ptr
    add d1
    dac path_ptr

start_lookup:
    dac current_inode

component_loop:
    " Extract next component
    lac path_ptr
    jms extract_component  " Returns component in 'component', advances path_ptr
    sza                    " Zero length = end of path
    jmp lookup_component

    " End of path - return current inode
    lac current_inode
    jmp namei i

lookup_component:
    " Load current directory
    lac current_inode
    jms iget

    " Check if it's a directory
    lac inodebuf+i.flags
    and o100000         " Directory bit
    sza
    jmp is_directory

    " Not a directory - error
    lac d-1
    jmp namei i

is_directory:
    " Search directory for component
    lac current_inode
    jms search_dir      " Uses 'component' as search name
    spa
    jmp not_found

    " Found - this becomes current inode
    dac current_inode

    " Check if more components
    lac path_ptr
    dac 8
    lac 8 i
    sza                 " Null terminator?
    jmp component_loop

    " End of path
    lac current_inode
    jmp namei i

not_found:
    lac d-1
    jmp namei i

path_ptr: 0
current_inode: 0
component: .=.+4        " Buffer for component name</code></pre>
<p><strong>Supporting function: extract_component</strong></p>
<pre class="assembly"><code>" extract_component - Extract one path component
" Input: AC = pointer to path (updated on return)
" Output: 'component' filled with name, AC = length

extract_component:
    0
    dac comp_ptr

    " Clear component buffer
    law component-1
    dac 9
    law d4
    dac count
1:  dzm 9 i
    isz count
    jmp 1b

    " Copy characters until '/' or null
    law comp_ptr
    dac 8
    law component-1
    dac 9
    cla
    dac char_count

extract_loop:
    lac 8 i             " Get character
    sza                 " Null?
    jmp check_slash

    " End of string
    lac comp_ptr
    dac path_ptr        " Update global
    lac char_count
    jmp extract_component i

check_slash:
    sad o57             " '/' ?
    jmp found_slash

    " Regular character - pack it
    dac current_char
    lac char_count
    and o1              " Odd or even?
    sza
    jmp pack_second

    " First char of word
    lac current_char
    alss 9
    dac temp_word
    jmp next_char

pack_second:
    " Second char of word
    lac temp_word
    add current_char
    dac 9 i             " Store packed word

next_char:
    isz char_count
    jmp extract_loop

found_slash:
    " Skip the slash
    lac comp_ptr
    add d1
    dac path_ptr
    lac char_count
    jmp extract_component i

comp_ptr: 0
char_count: 0
current_char: 0
temp_word: 0</code></pre>
<h3 data-number="6.7.2" id="execution-trace-opening-ddkenprog.s"><span class="header-section-number">6.7.2</span> Execution Trace: Opening
‚Äú/dd/ken/prog.s‚Äù</h3>
<p>Let‚Äôs trace complete execution:</p>
<pre><code>User program:
    sys open; filename; 0

filename: "dd/ken/prog.s\0"

Step 1: System call entry (s1.s)
    - Save user registers to u.ac, u.mq, etc.
    - AC now contains first arg address
    - Jump to .open

Step 2: .open extracts arguments
    - filename_ptr = address of "dd/ken/prog.s"
    - access_mode = 0 (read)

Step 3: namei called with "dd/ken/prog.s"
    - Not absolute path (no leading /)
    - current_inode = u.cdir = 1 (root)

Step 4: Extract "dd"
    - component = "dd\0\0\0\0\0\0"
    - path_ptr now points to "ken/prog.s"

Step 5: Search root directory for "dd"
    - Load inode 1 (root directory)
    - Read directory blocks
    - Entry 2: d.i = 2, d.name = "dd"
    - Match! current_inode = 2

Step 6: Extract "ken"
    - component = "ken\0\0\0\0\0"
    - path_ptr now points to "prog.s"

Step 7: Search /dd for "ken"
    - Load inode 2 (/dd directory)
    - Scan entries
    - Entry 5: d.i = 25, d.name = "ken"
    - Match! current_inode = 25

Step 8: Extract "prog.s"
    - component = "prog.s\0\0"
    - path_ptr now points to "\0"

Step 9: Search /dd/ken for "prog.s"
    - Load inode 25
    - Scan entries
    - Entry 8: d.i = 137, d.name = "prog.s"
    - Match! current_inode = 137

Step 10: End of path
    - Return inode 137

Step 11: .open continues
    - Load inode 137
    - Check permissions (read allowed)
    - Find free FD: slot 3
    - u.ofiles[3].flags = 0100000 (in use, read)
    - u.ofiles[3].badd = 0
    - u.ofiles[3].i = 137

Step 12: Return to user
    - AC = 3 (file descriptor)
    - Restore user registers
    - Continue at instruction after system call

Total operations:
- 3 inode reads (inodes 1, 2, 25)
- 3 directory searches
- 1 FD allocation
- ~200 instructions executed
- ~15 milliseconds on PDP-7</code></pre>
<h2 data-number="6.8" id="buffer-cache"><span class="header-section-number">6.8</span> 7.8 Buffer Cache</h2>
<p>To improve performance, Unix caches disk blocks in memory.</p>
<h3 data-number="6.8.1" id="buffer-cache-structure"><span class="header-section-number">6.8.1</span> Buffer Cache Structure</h3>
<pre class="assembly"><code>" Disk buffer cache (4 buffers)
" Each buffer is 64 words + metadata

buf1: .=.+64
buf1_track: 0           " Track number (0 = invalid)
buf1_dirty: 0           " 1 = modified, needs writeback

buf2: .=.+64
buf2_track: 0
buf2_dirty: 0

buf3: .=.+64
buf3_track: 0
buf3_dirty: 0

buf4: .=.+64
buf4_track: 0
buf4_dirty: 0

" LRU tracking
buf_lru: 0;1;2;3        " Least recently used order</code></pre>
<h3 data-number="6.8.2" id="dskrd-with-caching"><span class="header-section-number">6.8.2</span> dskrd with Caching</h3>
<pre class="assembly"><code>" dskrd - Read disk block with caching
" Input: AC = track number, arg = buffer address
" Output: Data in buffer

dskrd:
    0
    dac track_num
    lac dskrd i
    dac buffer_addr
    isz dskrd

    " Check each buffer
    lac track_num
    sad buf1_track
    jmp hit_buf1
    sad buf2_track
    jmp hit_buf2
    sad buf3_track
    jmp hit_buf3
    sad buf4_track
    jmp hit_buf4

    " Cache miss - need to read
    jms find_lru_buffer    " Returns buffer number
    jms evict_buffer       " Write if dirty

    " Read into buffer
    lac track_num
    jms physical_read; buf1  " Read to buffer

    " Update metadata
    lac track_num
    dac buf1_track
    dzm buf1_dirty

    " Copy to user buffer
    jms copy; buf1; buffer_addr; 64

    jms update_lru; 0
    jmp dskrd i

hit_buf1:
    jms copy; buf1; buffer_addr; 64
    jms update_lru; 0
    jmp dskrd i

    " (Similar for buf2, buf3, buf4)

track_num: 0
buffer_addr: 0</code></pre>
<h3 data-number="6.8.3" id="performance-impact"><span class="header-section-number">6.8.3</span> Performance Impact</h3>
<p><strong>Without cache:</strong> - Every file operation requires disk
I/O - Latency: 50ms per block (DECtape seek + read) - Reading 10-block
file: 500ms</p>
<p><strong>With cache (4 blocks):</strong> - Hot blocks served from
memory - Latency: 10Œºs (memory access) - Reading 10-block file: ~100ms
(cache hits on frequently accessed blocks)</p>
<p><strong>Limitation:</strong> Only 4 buffers (256 words = 576 bytes).
Modern systems cache megabytes or gigabytes.</p>
<h2 data-number="6.9" id="large-files"><span class="header-section-number">6.9</span> 7.9 Large Files</h2>
<p>Files larger than 7 blocks (448 words) use indirect blocks.</p>
<h3 data-number="6.9.1" id="direct-vs.-indirect-blocks"><span class="header-section-number">6.9.1</span> Direct vs.¬†Indirect
Blocks</h3>
<p><strong>Small file (‚â§ 448 words):</strong></p>
<pre><code>inode:
  i.dskps[0] = 1234  ‚îÄ‚îÄ‚Üí  Block 1234: [data words 0-63]
  i.dskps[1] = 1235  ‚îÄ‚îÄ‚Üí  Block 1235: [data words 64-127]
  i.dskps[2] = 1236  ‚îÄ‚îÄ‚Üí  Block 1236: [data words 128-191]
  i.dskps[3] = 1237  ‚îÄ‚îÄ‚Üí  Block 1237: [data words 192-255]
  i.dskps[4] = 1238  ‚îÄ‚îÄ‚Üí  Block 1238: [data words 256-319]
  i.dskps[5] = 1239  ‚îÄ‚îÄ‚Üí  Block 1239: [data words 320-383]
  i.dskps[6] = 1240  ‚îÄ‚îÄ‚Üí  Block 1240: [data words 384-447]</code></pre>
<p><strong>Large file (&gt; 448 words):</strong></p>
<pre><code>inode:
  i.flags = 0140644  (bit 17 set = large file)
  i.dskps[0] = 2000  ‚îÄ‚îÄ‚Üí  Indirect block 2000:
                            [0]: 3000 ‚îÄ‚îÄ‚Üí Block 3000: [data 0-63]
                            [1]: 3001 ‚îÄ‚îÄ‚Üí Block 3001: [data 64-127]
                            [2]: 3002 ‚îÄ‚îÄ‚Üí Block 3002: [data 128-191]
                            ...
                            [63]: 3063 ‚îÄ‚îÄ‚Üí Block 3063: [data 4032-4095]
  i.dskps[1-6] = 0   (unused)</code></pre>
<h3 data-number="6.9.2" id="maximum-file-size"><span class="header-section-number">6.9.2</span> Maximum File Size</h3>
<ul>
<li><strong>Indirect block:</strong> 64 pointers</li>
<li><strong>Each pointer:</strong> Points to 64-word data block</li>
<li><strong>Maximum:</strong> 64 √ó 64 = 4,096 words = 9,216 bytes ‚âà
9KB</li>
</ul>
<p><strong>Why so small?</strong> 1. Total disk is only 640KB 2. 9KB is
1.4% of disk - reasonable for largest file 3. Most files were tiny (&lt;
1KB)</p>
<h3 data-number="6.9.3" id="implementation-get_block_addr"><span class="header-section-number">6.9.3</span> Implementation:
get_block_addr</h3>
<pre class="assembly"><code>" get_block_addr - Get track number for logical block
" Input: AC = logical block number, inodebuf = file inode
" Output: AC = track number, or -1 if beyond EOF

get_block_addr:
    0
    dac logical_block

    " Check if large file
    lac inodebuf+i.flags
    and o200000         " Bit 17 = large file
    sza
    jmp large_file

    " Small file - direct blocks
    lac logical_block
    sad d7              " Block 7 or higher?
    jmp beyond_eof
    sma cla
    jmp beyond_eof

    " Get direct block pointer
    lac logical_block
    tad inodebuf+i.dskps
    dac 8
    lac 8 i
    jmp get_block_addr i

large_file:
    " Read indirect block
    lac inodebuf+i.dskps
    jms dskrd; indirect_buf

    " Get pointer from indirect block
    lac logical_block
    sad d64             " Block 64 or higher?
    jmp beyond_eof
    sma cla
    jmp beyond_eof

    tad indirect_buf-1
    dac 8
    lac 8 i
    jmp get_block_addr i

beyond_eof:
    lac d-1
    jmp get_block_addr i

logical_block: 0
indirect_buf: .=.+64</code></pre>
<h2 data-number="6.10" id="file-permissions"><span class="header-section-number">6.10</span> 7.10 File Permissions</h2>
<h3 data-number="6.10.1" id="permission-bit-layout"><span class="header-section-number">6.10.1</span> Permission Bit Layout</h3>
<p>From i.flags (18 bits):</p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Bit  ‚îÇ Octal  ‚îÇ Meaning                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  0   ‚îÇ 000001 ‚îÇ Owner execute           ‚îÇ
‚îÇ  1   ‚îÇ 000002 ‚îÇ Owner write             ‚îÇ
‚îÇ  2   ‚îÇ 000004 ‚îÇ Owner read              ‚îÇ
‚îÇ  3   ‚îÇ 000010 ‚îÇ Group execute (unused)  ‚îÇ
‚îÇ  4   ‚îÇ 000020 ‚îÇ Group write (unused)    ‚îÇ
‚îÇ  5   ‚îÇ 000040 ‚îÇ Group read (unused)     ‚îÇ
‚îÇ  6   ‚îÇ 000100 ‚îÇ Other execute (unused)  ‚îÇ
‚îÇ  7   ‚îÇ 000200 ‚îÇ Other write (unused)    ‚îÇ
‚îÇ  8   ‚îÇ 000400 ‚îÇ Other read (unused)     ‚îÇ
‚îÇ  9   ‚îÇ 001000 ‚îÇ Setuid                  ‚îÇ
‚îÇ 10-14‚îÇ 036000 ‚îÇ Reserved                ‚îÇ
‚îÇ  15  ‚îÇ 040000 ‚îÇ Directory               ‚îÇ
‚îÇ  16  ‚îÇ 100000 ‚îÇ Character device        ‚îÇ
‚îÇ  17  ‚îÇ 200000 ‚îÇ Large file              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
<p><strong>Note:</strong> Only owner permissions fully implemented in
PDP-7. Group/other bits reserved.</p>
<h3 data-number="6.10.2" id="permission-check-algorithm"><span class="header-section-number">6.10.2</span> Permission Check
Algorithm</h3>
<pre class="assembly"><code>" check_access - Check if user can access file
" Input: inodebuf = file inode, access_mode (0=read, 1=write, 2=execute)
" Output: AC = 0 if allowed, -1 if denied

check_access:
    0
    dac req_mode

    " Superuser can do anything
    lac u.uid
    sza                 " UID 0 or -1 = superuser
    add d1
    sza
    jmp check_owner

    cla                 " Superuser: allow
    jmp check_access i

check_owner:
    " Check if user owns file
    lac u.uid
    sad inodebuf+i.uid
    jmp owner_check_perm

    " Not owner - deny (group/other not implemented)
    lac d-1
    jmp check_access i

owner_check_perm:
    " Check requested permission
    lac req_mode
    sza                 " Read (mode 0)?
    jmp check_write

    " Check read permission
    lac inodebuf+i.flags
    and o4              " Owner read bit
    sza
    jmp access_ok
    jmp access_denied

check_write:
    lac req_mode
    sad d1              " Write (mode 1)?
    jmp 1f
    jmp check_exec

1:  lac inodebuf+i.flags
    and o2              " Owner write bit
    sza
    jmp access_ok
    jmp access_denied

check_exec:
    lac inodebuf+i.flags
    and o1              " Owner execute bit
    sza
    jmp access_ok
    jmp access_denied

access_ok:
    cla
    jmp check_access i

access_denied:
    lac d-1
    jmp check_access i

req_mode: 0</code></pre>
<h3 data-number="6.10.3" id="setuid-implementation"><span class="header-section-number">6.10.3</span> Setuid Implementation</h3>
<p>The setuid bit (bit 9) allows a program to run with the permissions
of the file owner, not the user running it.</p>
<pre class="assembly"><code>" exec - Execute program (simplified)
exec:
    " Load executable into memory
    lac filename
    jms namei
    jms iget

    " Check if setuid
    lac inodebuf+i.flags
    and o1000           " Setuid bit
    sza
    jmp do_setuid
    jmp normal_exec

do_setuid:
    " Change effective UID to file owner
    lac inodebuf+i.uid
    dac u.uid

normal_exec:
    " Load and execute program
    " ...</code></pre>
<p><strong>Security model:</strong> Very simple. No saved UID, no
groups, no capabilities. But effective for basic multi-user system.</p>
<h2 data-number="6.11" id="historical-context"><span class="header-section-number">6.11</span> 7.11 Historical Context</h2>
<h3 data-number="6.11.1" id="file-systems"><span class="header-section-number">6.11.1</span> 1969 File Systems</h3>
<p><strong>Flat file systems (most common):</strong> - CDC 6600, IBM
1401, DEC PDP-8 - All files in one directory - Naming: simple
identifiers or numbers</p>
<p><strong>Hierarchical file systems (rare):</strong> - Multics: Full
hierarchy with segments - CTSS: Two-level (user + file) - Atlas
Supervisor: Limited hierarchy</p>
<p><strong>Unix innovation:</strong> - Simple hierarchical structure -
Inode separation - Unified I/O model (files, devices, directories all
‚Äúfiles‚Äù) - Permissions integrated into file system</p>
<h3 data-number="6.11.2" id="comparison-table"><span class="header-section-number">6.11.2</span> Comparison Table</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>PDP-7 Unix</th>
<th>Multics</th>
<th>OS/360</th>
<th>TOPS-10</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hierarchy depth</td>
<td>Unlimited</td>
<td>Unlimited</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>Hard links</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>Rename cost</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>Permissions</td>
<td>Per-file</td>
<td>Per-segment</td>
<td>Dataset</td>
<td>File</td>
</tr>
<tr>
<td>Max file size</td>
<td>9KB</td>
<td>Unlimited</td>
<td>Unlimited</td>
<td>Large</td>
</tr>
<tr>
<td>Directory as file</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>Implementation lines</td>
<td>~500</td>
<td>~15,000</td>
<td>~50,000</td>
<td>~10,000</td>
</tr>
</tbody>
</table>
<h3 data-number="6.11.3" id="influence-on-modern-file-systems"><span class="header-section-number">6.11.3</span> Influence on Modern File
Systems</h3>
<p><strong>Unix V6 (1975):</strong> - Same basic structure - Improved: 3
indirect levels, larger blocks - Max file size: 1GB (theoretically)</p>
<p><strong>Unix V7 (1979):</strong> - Long filenames (14 chars ‚Üí 255
chars in later versions) - Improved performance - Better locking</p>
<p><strong>BSD FFS (1983):</strong> - Cylinder groups - Fragment support
- Performance optimizations - <strong>Still</strong> uses inodes and
directories as files</p>
<p><strong>ext2/ext3/ext4 (1993-2008):</strong> - Linux standard file
system - Inode-based (exactly like PDP-7!) - Extent-based allocation
(ext4) - Journaling (ext3/ext4)</p>
<p><strong>Modern file systems that use inode concept:</strong> - XFS,
JFS, ReiserFS, Btrfs (Linux) - HFS+, APFS (macOS) - UFS (BSD) - ZFS
(Solaris/FreeBSD)</p>
<p><strong>File systems WITHOUT inodes:</strong> - FAT12/16/32 (MS-DOS,
Windows) - NTFS (Windows) - uses MFT, similar concept but different
implementation</p>
<h3 data-number="6.11.4" id="what-changed-what-didnt"><span class="header-section-number">6.11.4</span> What Changed, What
Didn‚Äôt</h3>
<p><strong>What changed:</strong> - ‚úì File size limits (9KB ‚Üí terabytes)
- ‚úì Filename length (6 chars ‚Üí 255+ chars) - ‚úì Block size (64 words ‚Üí
4KB or larger) - ‚úì Caching (4 blocks ‚Üí gigabytes) - ‚úì Performance
optimizations (thousands of tweaks)</p>
<p><strong>What didn‚Äôt change:</strong> - ‚úó Inode structure (still ~12
pointers + metadata) - ‚úó Directory as file - ‚úó Separation of name and
metadata - ‚úó Hard link implementation - ‚úó Permission model (extended,
but same base)</p>
<p><strong>The PDP-7 file system got the fundamentals right. 55 years
later, we‚Äôre still using the same architecture.</strong></p>
<h2 data-number="6.12" id="complete-example-creating-and-reading-a-file"><span class="header-section-number">6.12</span> 7.12 Complete Example:
Creating and Reading a File</h2>
<p>Let‚Äôs trace a complete workflow from system initialization through
file creation and reading.</p>
<h3 data-number="6.12.1" id="scenario"><span class="header-section-number">6.12.1</span> Scenario</h3>
<p>User ken creates file <code>/dd/ken/memo</code> containing ‚Äúhello
world‚Äù, then reads it back.</p>
<h3 data-number="6.12.2" id="step-by-step-execution"><span class="header-section-number">6.12.2</span> Step-by-Step Execution</h3>
<pre><code>‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
STEP 1: System Boot
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

[Track 0 loaded and executed - coldentry]

1. Load sysdata from track 6000:
   s.nxfblk = 0       (no overflow blocks yet)
   s.nfblks = 10      (10 free blocks in cache)
   s.fblks = [5000, 5001, 5002, 5003, 5004, 5005, 5006, 5007, 5008, 5009]
   s.uniq = 100       (100 files created since installation)
   s.tim = 12345,67000 (system time)

2. Load and execute init (inode 3)

3. Init forks login process

4. User ken logs in, UID becomes 1

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
STEP 2: Create File
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

User types to shell: create memo

Shell executes:
   sys creat; "memo\0"; 0644

Kernel (.creat):

5. Call namei("memo")
   - Relative path, start with u.cdir = 25 (ken's directory)
   - Search directory inode 25 for "memo"
   - Not found ‚Üí return -1

6. Allocate new inode
   - Call icreat
   - Scan from inode 20 upward
   - Find inode 137 is free (i.flags = 0)
   - Return 137

7. Initialize inode 137:
   i.flags  = 040644  (regular file, rw-r--r--)
   i.dskps  = 0,0,0,0,0,0,0 (no blocks yet)
   i.uid    = 1       (ken)
   i.nlks   = -1      (one link)
   i.size   = 0       (empty)
   i.uniq   = 101     (s.uniq incremented: 100‚Üí101)

8. Write inode 137 to disk
   - Track = 137√∑5 + 2 = 27 + 2 = 29
   - Offset = (137 mod 5) √ó 12 = 2 √ó 12 = 24
   - Read track 29, modify words 24-35, write back

9. Add directory entry to /dd/ken (inode 25):
   - Load inode 25
   - Read directory blocks
   - Find empty slot (entry 8)
   - entry[8].d.i = 137
   - entry[8].d.name = "memo\0\0\0\0"
   - entry[8].d.uniq = 101
   - Write directory block back

10. Open file for writing
    - Find FD slot 3
    - u.ofiles[3].flags = 0100001 (in use, write)
    - u.ofiles[3].badd = 0
    - u.ofiles[3].i = 137

11. Return FD 3 to user

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
STEP 3: Write Data
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

User program:
   sys write; 3; buffer; 2   " Write 2 words

buffer: "he"; "ll"   (packed: 'h'&lt;&lt;9|'e', 'l'&lt;&lt;9|'l')

Kernel (.write):

12. Get file descriptor 3
    - f.flags = 0100001 (write mode)
    - f.badd = 0 (position)
    - f.i = 137 (inode)

13. Load inode 137
    - Currently: i.size = 0, no blocks

14. Need to allocate first block
    - Call alloc
    - s.nfblks = 10
    - Return s.fblks[9] = 5009
    - s.nfblks = 9
    - Clear block 5009

15. Store in inode:
    - i.dskps[0] = 5009

16. Write data:
    - block_buf[0] = "he"
    - block_buf[1] = "ll"

17. Write block 5009 to disk

18. Update inode 137:
    - i.size = 2
    - Write to disk

19. Update FD:
    - u.ofiles[3].badd = 2

20. Return 2 (words written)

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
STEP 4: Close File
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

User program:
   sys close; 3

Kernel (.close):

21. Clear FD 3:
    - u.ofiles[3].flags = 0 (not in use)

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
STEP 5: Re-open and Read
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

User program:
   sys open; "memo\0"; 0   " Read mode

Kernel (.open):

22. Call namei("memo")
    - Search directory inode 25
    - Find entry 8: d.i = 137, d.name = "memo"
    - Verify d.uniq (101) matches inode 137 i.uniq (101) ‚úì
    - Return 137

23. Load inode 137:
    - i.flags = 040644 (readable)
    - i.size = 2
    - i.dskps[0] = 5009

24. Allocate FD 4:
    - u.ofiles[4].flags = 0100000 (in use, read)
    - u.ofiles[4].badd = 0
    - u.ofiles[4].i = 137

25. Return FD 4

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
STEP 6: Read Data
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

User program:
   sys read; 4; buffer; 2

Kernel (.read):

26. Get FD 4:
    - f.badd = 0
    - f.i = 137

27. Load inode 137

28. Calculate block:
    - Block = 0 √∑ 64 = 0
    - Block address = i.dskps[0] = 5009

29. Read block 5009 (from cache if available!)
    - block_buf[0] = "he"
    - block_buf[1] = "ll"

30. Copy to user buffer:
    - buffer[0] = "he"
    - buffer[1] = "ll"

31. Update FD:
    - u.ofiles[4].badd = 2

32. Return 2 (words read)

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
FINAL STATE
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Disk:
  Track 29: Inode 137 (memo)
  Track 5721: Block 5009 (data: "hell")
  Track ?: Directory block with entry pointing to 137

Memory:
  sysdata:
    s.nfblks = 9 (one block allocated)
    s.uniq = 101

Process:
  u.cdir = 25 (/dd/ken)
  u.uid = 1 (ken)
  u.ofiles[4] is open to inode 137, position 2

Total operations:
  - Disk writes: 5 (inode, directory, data, inode update, sysdata)
  - Disk reads: 8 (inode loads, directory searches, data read)
  - System calls: 5 (creat, write, close, open, read)
  - Time: ~250ms on PDP-7</code></pre>
<h2 data-number="6.13" id="summary-1"><span class="header-section-number">6.13</span> Summary</h2>
<p>The PDP-7 Unix file system achieved extraordinary sophistication
within severe constraints:</p>
<ul>
<li><strong>8K words</strong> of memory</li>
<li><strong>640KB</strong> disk</li>
<li><strong>No MMU</strong> or memory protection</li>
<li><strong>18-bit</strong> word size</li>
</ul>
<p>Yet it introduced concepts that persist today:</p>
<ol type="1">
<li><strong>Separation of name and metadata</strong> (inodes)</li>
<li><strong>Hierarchical directories</strong> (as files)</li>
<li><strong>Hard links</strong> (multiple names ‚Üí one file)</li>
<li><strong>Unified permissions model</strong></li>
<li><strong>Simple, elegant algorithms</strong></li>
</ol>
<p>Every time you <code>ls -l</code>, create a hard link, or rename a
gigabyte file instantly, you‚Äôre using ideas that Ken Thompson and Dennis
Ritchie perfected in 1969 on a computer with less power than a digital
watch.</p>
<p>The PDP-7 Unix file system wasn‚Äôt just ahead of its time‚Äîit defined
the future.</p>
<hr/>
<p><strong>Next Chapter:</strong> <a href="08-process-management.md">Chapter 8 - Process Management</a></p>
<p><strong>Previous Chapter:</strong> <a href="06-boot-initialization.md">Chapter 6 - Boot and
Initialization</a></p>
<h1 data-number="7" id="chapter-8---process-management"><span class="header-section-number">7</span> Chapter 8 - Process
Management</h1>
<p>The process is the fundamental abstraction in Unix‚Äîthe unit of
computation, resource allocation, and protection. In PDP-7 Unix, we see
this revolutionary concept in its earliest and simplest form: just 4
words per process in the process table, 64 words of saved state, and a
handful of system calls. Yet from this minimal foundation emerges true
multiprogramming: multiple programs sharing a single processor through
time-slicing and swapping.</p>
<p>This chapter explores how PDP-7 Unix implements processes, from the
data structures that represent them to the algorithms that create,
schedule, swap, and terminate them. We‚Äôll trace the complete lifecycle
of a process from fork to exit, examine the swapping mechanism that
enables multiprogramming in just 8K of memory, and understand the simple
but effective round-robin scheduler.</p>
<h2 data-number="7.1" id="the-process-abstraction"><span class="header-section-number">7.1</span> 8.1 The Process
Abstraction</h2>
<h3 data-number="7.1.1" id="what-is-a-process-in-pdp-7-unix"><span class="header-section-number">7.1.1</span> What is a Process in PDP-7
Unix?</h3>
<p>A process in PDP-7 Unix is an executing instance of a program. More
precisely, it consists of:</p>
<ol type="1">
<li><strong>Code</strong>: The program instructions loaded from a
file</li>
<li><strong>Data</strong>: Variables and working storage (in the upper
2K of memory)</li>
<li><strong>Context</strong>: Saved register values (AC, MQ, program
counter, link register)</li>
<li><strong>Resources</strong>: Open file descriptors and current
directory</li>
<li><strong>Identity</strong>: Process ID (PID) and user ID (UID)</li>
<li><strong>State</strong>: Whether the process is running, ready, or
swapped out</li>
</ol>
<p>Unlike modern systems with virtual memory, PDP-7 Unix processes share
a single 8K memory space. Only one process can be in memory at a
time‚Äîthe others are swapped out to disk tracks 06000 and 07000.</p>
<h3 data-number="7.1.2" id="the-revolutionary-concept-in-1969"><span class="header-section-number">7.1.2</span> The Revolutionary Concept in
1969</h3>
<p>In 1969, most computer systems ran <strong>batch jobs</strong> or
<strong>interactive sessions</strong>:</p>
<p><strong>Batch systems</strong> (like IBM OS/360): - Jobs submitted on
punched cards - Queued and run sequentially - No interaction during
execution - One job at a time per partition</p>
<p><strong>Timesharing systems</strong> (like CTSS, Multics): - Multiple
users share CPU time - Complex schedulers with priorities - Heavyweight
processes with separate address spaces - Required sophisticated hardware
(MMU, page tables)</p>
<p><strong>PDP-7 Unix processes</strong> were different: - Lightweight
(minimal per-process overhead) - Uniform (all processes treated equally,
no priorities) - Simple (no virtual memory, no protection rings) - Fast
(fork creates process in ~100ms) - Elegant (same abstraction for
interactive and batch)</p>
<p>The genius was <strong>making processes so cheap</strong> that
programs could create them freely. This led directly to the Unix
philosophy of small tools combined via pipes‚Äîbut that came later, in
PDP-11 Unix.</p>
<h3 data-number="7.1.3" id="comparison-with-batch-jobs"><span class="header-section-number">7.1.3</span> Comparison with Batch
Jobs</h3>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Batch Job (OS/360)</th>
<th>Process (PDP-7 Unix)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Creation</td>
<td>Operator loads cards</td>
<td>fork() system call</td>
</tr>
<tr>
<td>Identity</td>
<td>Job name</td>
<td>Numeric PID</td>
</tr>
<tr>
<td>Scheduling</td>
<td>FIFO queue</td>
<td>Round-robin time-slicing</td>
</tr>
<tr>
<td>Memory</td>
<td>Fixed partition</td>
<td>Entire 8K (swapped)</td>
</tr>
<tr>
<td>I/O</td>
<td>Dedicated devices</td>
<td>Shared via file descriptors</td>
</tr>
<tr>
<td>Termination</td>
<td>Job complete</td>
<td>exit() system call</td>
</tr>
<tr>
<td>Parent/Child</td>
<td>No relationship</td>
<td>Parent waits for child</td>
</tr>
<tr>
<td>Lifetime</td>
<td>Minutes to hours</td>
<td>Seconds to minutes</td>
</tr>
</tbody>
</table>
<p>The PDP-7 Unix process model was simpler than batch jobs in some ways
(no job control language, no complex scheduling) but more powerful in
others (dynamic creation, parent/child relationships, uniform
abstraction).</p>
<h2 data-number="7.2" id="process-table"><span class="header-section-number">7.2</span> 8.2 Process Table</h2>
<p>The process table (<code>ulist</code>) is the central data structure
for process management. It‚Äôs an array of 10 entries, each representing
one potential process slot.</p>
<h3 data-number="7.2.1" id="the-ulist-structure"><span class="header-section-number">7.2.1</span> The ulist Structure</h3>
<p>Located in <code>s8.s</code>, the process table is declared as:</p>
<pre class="assembly"><code>" Process table (ulist) - 4 words per process
" Maximum of 10 processes (mnproc = 10)

ulist: .=.+mnproc*4     " Allocate 40 words (10 processes √ó 4 words)</code></pre>
<p>Each entry contains exactly <strong>4 words</strong>:</p>
<pre><code>Process Table Entry (4 words):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Word 0: State and flags                 ‚îÇ
‚îÇ         Bits 0-1:  State (0-3)          ‚îÇ
‚îÇ         Bits 2-17: Flags (unused)       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Word 1: Process ID (PID)                ‚îÇ
‚îÇ         Unique number 1-65535           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Word 2: Swap track address              ‚îÇ
‚îÇ         06000 or 07000 (disk track)     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Word 3: Reserved                        ‚îÇ
‚îÇ         (unused in PDP-7 Unix)          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
<h3 data-number="7.2.2" id="maximum-10-processes"><span class="header-section-number">7.2.2</span> Maximum 10 Processes</h3>
<p>The manifest constant <code>mnproc</code> defines the maximum number
of concurrent processes:</p>
<pre class="assembly"><code>mnproc = 10     " Maximum number of processes</code></pre>
<p><strong>Why only 10?</strong> - <strong>Memory constraints</strong>:
With 8K total memory and ~2K for each process, swapping more than a few
processes would be slow - <strong>Swap space</strong>: Only 2 disk
tracks allocated for swapping (06000, 07000) -
<strong>Simplicity</strong>: Small process table means fast search -
<strong>Practical limit</strong>: On a single-user system (usually), 10
processes was plenty</p>
<p>In practice, a typical PDP-7 Unix session might have: 1.
<code>init</code> (PID 1) - waiting for login 2. <code>sh</code> (shell)
- running user commands 3. User program - executing command 4.
<code>ed</code> - editing a file</p>
<p>That‚Äôs only 3-4 processes, well under the limit.</p>
<h3 data-number="7.2.3" id="the-state-field-2-bits"><span class="header-section-number">7.2.3</span> The State Field (2 bits)</h3>
<p>The low 2 bits of word 0 encode the process state:</p>
<pre class="assembly"><code>" Process states (bits 0-1 of ulist[proc,0])
" State 0: Unused (process slot is free)
" State 1: In memory, ready to run
" State 2: In memory, waiting (not ready)
" State 3: On disk, ready to run</code></pre>
<p>Only 2 bits are needed because there are just 4 possible states. The
implementation is elegantly minimal:</p>
<pre class="assembly"><code>" Get process state
    law ulist       " Address of process table
    tad proc        " Add process number √ó 4
    tad proc
    tad proc
    tad proc
    dac 8           " Auto-increment pointer
    lac 8 i         " Load word 0
    and d3          " Mask to get bits 0-1
    " AC now contains state (0-3)

d3: 3              " Mask for 2-bit state field</code></pre>
<h3 data-number="7.2.4" id="pid-allocation"><span class="header-section-number">7.2.4</span> PID Allocation</h3>
<p>Process IDs are allocated sequentially using a global counter:</p>
<pre class="assembly"><code>" In s8.s - System data
nproc: 0           " Next process ID to allocate

" In fork (s3.s) - Allocate new PID
    isz nproc      " Increment and skip if zero
    jmp .+1        " (never zero, so always continue)
    lac nproc      " Get new PID
    dac 8 i        " Store in ulist[new_proc, 1]</code></pre>
<p>PIDs start at 1 and increment forever. In a long-running system, they
would eventually wrap around after 262,143 processes (18-bit word), but
this would take weeks of continuous forking.</p>
<p><strong>PID 1 is special</strong>: It‚Äôs always <code>init</code>, the
first process created during boot. When a process‚Äôs parent exits, the
process is reparented to PID 1.</p>
<h3 data-number="7.2.5" id="complete-process-table-structure-analysis"><span class="header-section-number">7.2.5</span> Complete Process Table
Structure Analysis</h3>
<p>Let‚Äôs examine the full structure with an example of 3 running
processes:</p>
<pre><code>Memory Layout of ulist (10 processes √ó 4 words = 40 words):

Address  Process  Word  Contents          Description
-------  -------  ----  ----------------  ------------------------------------
ulist+0    0       0    0000000000000001  State=1 (in memory, ready)
ulist+1    0       1    0000000000000001  PID=1 (init)
ulist+2    0       2    0000000006000     Swap track = 06000
ulist+3    0       3    0000000000000000  (unused)

ulist+4    1       0    0000000000000001  State=1 (in memory, ready)
ulist+5    1       1    0000000000000042  PID=42 (shell)
ulist+6    1       2    0000000007000     Swap track = 07000
ulist+7    1       3    0000000000000000  (unused)

ulist+10   2       0    0000000000000011  State=3 (on disk, ready)
ulist+11   2       1    0000000000000043  PID=43 (ed)
ulist+12   2       2    0000000007000     Swap track = 07000
ulist+13   2       3    0000000000000000  (unused)

ulist+14   3       0    0000000000000000  State=0 (unused)
ulist+15   3       1    0000000000000000  PID=0
ulist+16   3       2    0000000000000000  No swap track
ulist+17   3       3    0000000000000000  (unused)

... (6 more unused slots)</code></pre>
<h3 data-number="7.2.6" id="finding-a-free-process-slot"><span class="header-section-number">7.2.6</span> Finding a Free Process
Slot</h3>
<p>When <code>fork()</code> needs to create a new process, it searches
for an unused slot:</p>
<pre class="assembly"><code>" Find free process slot
    law ulist-4     " Start before first entry
    dac 8           " Auto-increment pointer
    law mnproc      " Loop counter = 10
    dac count

1:
    lac 8 i         " Get ulist[i,0]
    and d3          " Extract state bits
    sza             " Skip if state == 0 (unused)
    jmp 2f          " Used, try next

    " Found free slot
    lac 8           " Get pointer address
    tad dm4         " Back up to start of entry
    " AC now has address of free entry
    jmp found

2:
    isz 8           " Skip words 1, 2, 3
    isz 8
    isz 8
    isz count       " Decrement counter
    jmp 1b          " Try next slot

    " No free slots
    error           " Fork fails!

found:
    " Initialize new process entry
    ...</code></pre>
<h2 data-number="7.3" id="user-data-structure-1"><span class="header-section-number">7.3</span> 8.3 User Data Structure</h2>
<p>While the process table entry contains minimal metadata, the bulk of
a process‚Äôs state is stored in the <strong>userdata</strong>
structure‚Äî64 words of saved context that gets swapped in and out with
the process.</p>
<h3 data-number="7.3.1" id="the-userdata-structure-64-words"><span class="header-section-number">7.3.1</span> The userdata Structure (64
words)</h3>
<p>Located in <code>s8.s</code>:</p>
<pre class="assembly"><code>" User data structure - 64 words
" Saved with process when swapped out
" Loaded when process swapped in

userdata:
    uac:    0      " +0  Saved AC (accumulator)
    umq:    0      " +1  Saved MQ (multiplier-quotient)
    urq:    0      " +2  Saved rq (return address register)
    upc:    0      " +3  Saved PC (program counter, for debugging)

    uid:    0      " +4  User ID (for permissions)
    upid:   0      " +5  Process ID
    uppid:  0      " +6  Parent process ID

    " File descriptor table (30 slots)
    ufil:   .=.+30 " +7 to +36  File descriptor array

    ucdir:  0      " +37 Current directory inode number

    ustack: .=.+26 " +38 to +63 Kernel stack space</code></pre>
<p>This structure occupies exactly 64 words and is loaded at a fixed
memory location (typically around address 7700) when a process is
active.</p>
<h3 data-number="7.3.2" id="saved-registers"><span class="header-section-number">7.3.2</span> Saved Registers</h3>
<p>The first few words preserve the CPU state:</p>
<pre class="assembly"><code>uac:    " Saved accumulator
    " Contains the value of AC when process was interrupted
    " Restored on context switch back to this process

umq:    " Saved multiplier-quotient register
    " Used in multiply/divide operations
    " Must be preserved across context switches

urq:    " Saved return address
    " The rq register holds subroutine return addresses
    " Critical for resuming execution correctly

upc:    " Saved program counter (for debugging)
    " Not always used, but helpful for crash dumps</code></pre>
<p><strong>Why save these?</strong> When the kernel switches from one
process to another, it must preserve the complete CPU state. Otherwise,
when the process resumes, its registers would contain garbage from
whatever else was running.</p>
<h3 data-number="7.3.3" id="file-descriptors-30-slots"><span class="header-section-number">7.3.3</span> File Descriptors (30
slots)</h3>
<p>The <code>ufil</code> array is the process‚Äôs <strong>file descriptor
table</strong>:</p>
<pre class="assembly"><code>ufil:   .=.+30     " 30 file descriptor slots

" Each entry is a single word containing:
"   - File number (index into system-wide file table)
"   - Or 0 if slot is unused

" Example file descriptor table:
"   ufil+0:  0      (fd 0 unused - no stdin yet in PDP-7!)
"   ufil+1:  0      (fd 1 unused - no stdout yet)
"   ufil+2:  0      (fd 2 unused - no stderr yet)
"   ufil+3:  14     (fd 3 open, refers to file table entry 14)
"   ufil+4:  7      (fd 4 open, refers to file table entry 7)
"   ...</code></pre>
<p><strong>Important historical note</strong>: PDP-7 Unix did NOT have
the stdin/stdout/stderr convention (file descriptors 0, 1, 2). That was
invented later for PDP-11 Unix. In PDP-7 Unix, file descriptors started
at 0 and were just indices into the file table.</p>
<p><strong>Why 30 slots?</strong> This seems arbitrary, but it‚Äôs based
on: - 64 words total for userdata - 7 words for registers/IDs - 1 word
for current directory - ~26 words for kernel stack - Leaves ~30 words
for file descriptors</p>
<h3 data-number="7.3.4" id="current-directory"><span class="header-section-number">7.3.4</span> Current Directory</h3>
<pre class="assembly"><code>ucdir:  0      " Current directory inode number

" Example values:
"   ucdir = 41     Process is in inode 41 (the root directory)
"   ucdir = 123    Process is in inode 123 (some subdirectory)</code></pre>
<p>Every process has a current working directory, stored as an inode
number. When the user opens a file with a relative path, the kernel
searches starting from this directory.</p>
<p><strong>Example</strong>: If a process‚Äôs <code>ucdir</code> is 41
(root) and it opens ‚Äúusr/ken/file‚Äù, the kernel: 1. Starts at inode 41 2.
Searches for ‚Äúusr‚Äù in that directory 3. Searches for ‚Äúken‚Äù in the ‚Äúusr‚Äù
directory 4. Opens ‚Äúfile‚Äù in the ‚Äúken‚Äù directory</p>
<h3 data-number="7.3.5" id="uid-and-pid"><span class="header-section-number">7.3.5</span> UID and PID</h3>
<pre class="assembly"><code>uid:    0      " User ID (who owns this process)
upid:   0      " Process ID (unique identifier)
uppid:  0      " Parent process ID</code></pre>
<p><strong>UID</strong> determines permissions: - UID 0 = superuser (can
do anything) - UID &gt; 0 = normal user (restricted access)</p>
<p><strong>PID</strong> is the unique process identifier, used for: -
Wait system call (parent waits for child‚Äôs PID) - Messages (send/receive
between specific PIDs) - Process table lookups</p>
<p><strong>PPID</strong> (parent PID) tracks the parent/child
relationship: - When a process exits, it sends a message to its parent -
If the parent has exited, the child is reparented to PID 1 (init)</p>
<h3 data-number="7.3.6" id="full-code-walkthrough-saving-context"><span class="header-section-number">7.3.6</span> Full Code Walkthrough: Saving
Context</h3>
<p>Here‚Äôs how the kernel saves a process‚Äôs context during a system call
entry:</p>
<pre class="assembly"><code>" System call entry point (location 020)
" Entered via hardware trap when user executes 'sys' instruction

020:
    dac uac         " Save AC to userdata.uac
    law 020         " Load address 020
    dac urq         " Save as return address
    lac 017         " Get MQ register
    dac umq         " Save to userdata.umq

    " At this point, all critical registers are saved
    " Kernel can freely use AC, MQ without corrupting user state

    lac s.insys     " Check if already in system call
    sna             " Skip if non-zero (recursive call)
    jmp entry       " First entry, proceed normally

    " Recursive system call - panic
    error

entry:
    lac d1
    dac s.insys     " Set "inside system call" flag

    " Dispatch to system call handler
    ...</code></pre>
<h3 data-number="7.3.7" id="restoring-context-on-return"><span class="header-section-number">7.3.7</span> Restoring Context on
Return</h3>
<p>When returning to user mode:</p>
<pre class="assembly"><code>" System call exit point
sysexit:
    dza             " Clear AC
    dac s.insys     " Clear "inside system call" flag

    " Check if process should be swapped out
    jms swap        " Swap scheduling

    lac umq         " Restore MQ register
    dac 017
    lac urq         " Get return address
    dac 8           " Set up auto-increment pointer
    lac uac         " Restore AC

    " Return to user space
    jmp 8 i         " Jump indirect through rq</code></pre>
<h3 data-number="7.3.8" id="complete-memory-layout-of-userdata"><span class="header-section-number">7.3.8</span> Complete Memory Layout of
userdata</h3>
<p>Let‚Äôs visualize a real example with a process that has opened 3
files:</p>
<pre><code>Address  Offset  Field    Value   Description
-------  ------  -------  ------  ----------------------------------
7700     +0      uac      004217  Saved AC = 004217 (octal)
7701     +1      umq      000000  Saved MQ = 0
7702     +2      urq      001234  Saved return address = 001234
7703     +3      upc      001233  Saved PC = 001233

7704     +4      uid      000012  User ID = 12 (user "ken")
7705     +5      upid     000043  Process ID = 43
7706     +6      uppid    000042  Parent PID = 42 (the shell)

7707     +7      ufil[0]  000000  fd 0: unused
7710     +8      ufil[1]  000000  fd 1: unused
7711     +9      ufil[2]  000000  fd 2: unused
7712     +10     ufil[3]  000014  fd 3: file table entry 14 (open)
7713     +11     ufil[4]  000007  fd 4: file table entry 7 (open)
7714     +12     ufil[5]  000021  fd 5: file table entry 21 (open)
7715     +13     ufil[6]  000000  fd 6: unused
...      ...     ...      ...     (23 more unused fd slots)
7736     +36     ufil[29] 000000  fd 29: unused

7737     +37     ucdir    000041  Current directory = inode 41 (root)

7740     +38     ustack   ...     Kernel stack begins here
...      ...     ...      ...     (26 words of stack space)
7763     +63     ustack   ...     Top of kernel stack</code></pre>
<h2 data-number="7.4" id="process-states-1"><span class="header-section-number">7.4</span> 8.4 Process States</h2>
<p>PDP-7 Unix has exactly <strong>4 process states</strong>, encoded in
2 bits. This is far simpler than modern operating systems with 10+
states (running, ready, blocked, sleeping, zombie, traced, etc.).</p>
<h3 data-number="7.4.1" id="state-definitions"><span class="header-section-number">7.4.1</span> State Definitions</h3>
<pre class="assembly"><code>" Process states (bits 0-1 of ulist entry word 0)

" State 0: NOT USED
"   Process slot is free
"   Can be allocated by fork()

" State 1: IN MEMORY, READY
"   Process is loaded in memory (addresses 0-7777)
"   Ready to run (not waiting for I/O)
"   Will be selected by scheduler

" State 2: IN MEMORY, NOT READY
"   Process is loaded in memory
"   Waiting for something (I/O completion, message, etc.)
"   Will NOT be selected by scheduler

" State 3: ON DISK, READY
"   Process is swapped out to disk (track 06000 or 07000)
"   Ready to run if swapped back in
"   Will be selected by swap scheduler</code></pre>
<h3 data-number="7.4.2" id="state-0-not-used-free-slot"><span class="header-section-number">7.4.2</span> State 0: Not Used (Free
Slot)</h3>
<pre class="assembly"><code>" Example: ulist[5,0] = 0
"   Process slot 5 is unused
"   Available for fork() to allocate</code></pre>
<p>When <code>fork()</code> searches for a free process slot, it looks
for entries with state 0. When a process exits, its state is set to 0,
freeing the slot for reuse.</p>
<h3 data-number="7.4.3" id="state-1-in-memory-ready"><span class="header-section-number">7.4.3</span> State 1: In Memory,
Ready</h3>
<pre class="assembly"><code>" Example: ulist[2,0] = 1
"   Process 2 is in memory
"   Ready to execute
"   Eligible for CPU time slicing</code></pre>
<p>This is the ‚Äúrunning‚Äù or ‚Äúrunnable‚Äù state. The process could be: -
Currently executing (if it‚Äôs the active process) - Waiting for its time
slice (if another process is running)</p>
<p>The scheduler‚Äôs <code>lookfor</code> function searches for processes
in state 1:</p>
<pre class="assembly"><code>lookfor:
    " Find next ready process
    law ulist-4
    dac 8
    law mnproc
    dac count

1:
    lac 8 i         " Get state field
    and d3
    sad d1          " State == 1?
    jmp found       " Yes, found ready process

    isz 8           " Skip to next entry
    isz 8
    isz 8
    isz 8
    isz count
    jmp 1b

    " No ready processes, idle loop
    jmp idle

found:
    " Dispatch this process
    ...</code></pre>
<h3 data-number="7.4.4" id="state-2-in-memory-not-ready-blocked"><span class="header-section-number">7.4.4</span> State 2: In Memory, Not Ready
(Blocked)</h3>
<pre class="assembly"><code>" Example: ulist[3,0] = 2
"   Process 3 is in memory
"   Waiting for I/O or message
"   NOT eligible for scheduling</code></pre>
<p>A process enters state 2 when it blocks on: - <strong>Disk
I/O</strong>: Reading or writing a file - <strong>Message
receive</strong>: Waiting for inter-process message -
<strong>Sleep</strong>: Explicitly sleeping for a time</p>
<p>The process remains in memory but won‚Äôt be scheduled until it becomes
ready (state changes back to 1).</p>
<p><strong>Example: Waiting for disk I/O:</strong></p>
<pre class="assembly"><code>.read:
    " User called read() system call
    jms finac       " Find file descriptor
    jms iread       " Read from inode

iread:
    " Determine which disk block to read
    jms pget        " Get physical block number
    jms dskrd       " Read from disk

dskrd:
    " Initiate disk transfer
    jms dsktrans    " Start I/O

    " Block until I/O completes
    lac proc        " Current process number
    alss 2          " √ó 4 for ulist entry
    tad ulist
    dac 8
    lac d2          " State 2 = blocked
    dac 8 i         " Set process state

    " Give up CPU
    jmp swapnow     " Swap to another process</code></pre>
<p>When the disk interrupt fires, it sets the process back to state
1:</p>
<pre class="assembly"><code>" Disk interrupt handler
diskint:
    " Disk I/O completed
    lac waitproc    " Which process was waiting?
    alss 2
    tad ulist
    dac 8
    lac d1          " State 1 = ready
    dac 8 i         " Unblock process
    ...</code></pre>
<h3 data-number="7.4.5" id="state-3-on-disk-ready-swapped-out"><span class="header-section-number">7.4.5</span> State 3: On Disk, Ready
(Swapped Out)</h3>
<pre class="assembly"><code>" Example: ulist[7,0] = 3
"   Process 7 is swapped out to disk
"   Ready to run if swapped back
"   Eligible for swap-in</code></pre>
<p>When memory is needed for another process, the kernel swaps the
current process out:</p>
<pre class="assembly"><code>swap:
    " Decide whether to swap current process out
    lac s.quantum   " Check time quantum
    sna             " Skip if non-zero
    jmp doswap      " Quantum expired, swap out
    jmp noswap      " Quantum remains, keep running

doswap:
    " Write process memory to disk
    lac proc        " Current process
    jms dskswap     " Swap to disk (track 06000 or 07000)

    " Update process state
    lac proc
    alss 2
    tad ulist
    dac 8
    lac d3          " State 3 = swapped out, ready
    dac 8 i

    " Select another process
    jms lookfor     " Find next ready process
    jms dskswapin   " Swap it into memory
    ...</code></pre>
<h3 data-number="7.4.6" id="state-transitions"><span class="header-section-number">7.4.6</span> State Transitions</h3>
<p>Here‚Äôs how processes move between states:</p>
<pre><code>State Transition Diagram:

                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ   State 0   ‚îÇ
                    ‚îÇ  NOT USED   ‚îÇ
                    ‚îÇ  (FREE)     ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                           ‚îÇ
                         fork()
                           ‚îÇ
                           ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ              State 1                     ‚îÇ
    ‚îÇ         IN MEMORY, READY                 ‚îÇ
    ‚îÇ       (Running/Runnable)                 ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                     ‚îÇ
         ‚îÇ wait for I/O        ‚îÇ I/O complete
         ‚îÇ wait for msg        ‚îÇ message arrived
         ‚îÇ sleep               ‚îÇ wakeup
         ‚îÇ                     ‚îÇ
         ‚ñº                     ‚ñº
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ          State 2                ‚îÇ
    ‚îÇ     IN MEMORY, NOT READY        ‚îÇ
    ‚îÇ        (Blocked)                ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
                  ‚îÇ quantum expired
                  ‚îÇ another process needs memory
                  ‚îÇ
                  ‚ñº
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ     State 3        ‚îÇ
         ‚îÇ  ON DISK, READY    ‚îÇ
         ‚îÇ  (Swapped out)     ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
                  ‚îÇ swap in
                  ‚îÇ
                  ‚ñº
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ     State 1        ‚îÇ
         ‚îÇ  IN MEMORY, READY  ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
<p><strong>Key transitions:</strong></p>
<ol type="1">
<li><strong>0 ‚Üí 1</strong>: <code>fork()</code> creates new process in
memory, ready state</li>
<li><strong>1 ‚Üí 2</strong>: Process blocks on I/O or message</li>
<li><strong>2 ‚Üí 1</strong>: I/O completes or message arrives, process
becomes ready</li>
<li><strong>1 ‚Üí 3</strong>: Time quantum expires, process swapped
out</li>
<li><strong>3 ‚Üí 1</strong>: Process swapped back in</li>
<li><strong>1 ‚Üí 0</strong> or <strong>2 ‚Üí 0</strong> or <strong>3 ‚Üí
0</strong>: <code>exit()</code> terminates process</li>
</ol>
<h3 data-number="7.4.7" id="state-checking-in-system-calls"><span class="header-section-number">7.4.7</span> State Checking in System
Calls</h3>
<p>Many system calls check process state:</p>
<pre class="assembly"><code>.wait:
    " Wait for child process to exit
1:
    jms lookchild   " Search for child in state 0 (exited)
    sna             " Found one?
    jmp .+3         " No, sleep
    " Child exited, return its PID
    jmp sysexit

    " No exited child yet, block
    lac d2          " State 2 = blocked
    dac procstate
    jmp schedule    " Give up CPU</code></pre>
<h3 data-number="7.4.8" id="complete-state-example"><span class="header-section-number">7.4.8</span> Complete State Example</h3>
<p>Let‚Äôs trace a process through all states from creation to
termination:</p>
<pre><code>Time  Event                    State  Location   Description
----  -----------------------  -----  ---------  ---------------------------
0     fork() called            1      Memory     Parent creates child
1     Child begins executing   1      Memory     Child process gets CPU
2     Child calls read()       2      Memory     Blocks waiting for disk
3     Disk I/O completes       1      Memory     Becomes ready again
4     Quantum expires          3      Disk       Swapped out to track 06000
5     Scheduler picks it       1      Memory     Swapped back in
6     Calls exit()             0      None       Process terminates, slot freed</code></pre>
<h2 data-number="7.5" id="process-creation---fork"><span class="header-section-number">7.5</span> 8.5 Process Creation -
fork()</h2>
<p>The <code>fork()</code> system call is the <strong>only way</strong>
to create a new process in Unix. It‚Äôs one of the most elegant and
revolutionary ideas in operating system design: create a copy of the
current process, and have them both continue execution with different
return values.</p>
<h3 data-number="7.5.1" id="the-fork-concept"><span class="header-section-number">7.5.1</span> The fork() Concept</h3>
<p>When a process calls <code>fork()</code>:</p>
<ol type="1">
<li>The kernel creates a <strong>new process table entry</strong></li>
<li>Allocates a <strong>new PID</strong></li>
<li><strong>Copies</strong> the parent‚Äôs memory to the child (via disk
swapping)</li>
<li><strong>Duplicates</strong> all open file descriptors</li>
<li>Sets the <strong>parent‚Äôs return value</strong> to the child‚Äôs
PID</li>
<li>Sets the <strong>child‚Äôs return value</strong> to 0</li>
<li>Both processes continue execution from the <strong>same
point</strong></li>
</ol>
<p>The genius is that <strong>the same code runs in both
processes</strong>, but they can detect which one they are by checking
the return value:</p>
<pre class="assembly"><code>" In user code:
    sys fork        " Create child process

    " Execution continues here in BOTH processes
    sza             " Skip if AC == 0 (child)
    jmp parent      " Non-zero (child PID), must be parent

child:
    " Child process code
    " AC was 0 after fork
    ...
    sys exit

parent:
    " Parent process code
    " AC contains child's PID
    ...</code></pre>
<h3 data-number="7.5.2" id="complete-fork-implementation"><span class="header-section-number">7.5.2</span> Complete fork()
Implementation</h3>
<p>Located in <code>s3.s</code>, the <code>fork()</code> system call is
about 50 lines of carefully crafted code:</p>
<pre class="assembly"><code>" fork - Create new process
" Returns: AC = child PID in parent
"          AC = 0 in child

.fork:
    " Step 1: Find free process slot
    law ulist-4     " Start before first entry
    dac 8           " Auto-increment pointer
    law mnproc      " Counter = 10 processes
    dac count

1:
    lac 8 i         " Get ulist[i,0] (state field)
    and d3          " Mask to state bits
    sza             " Skip if state == 0 (free)
    jmp 2f          " In use, try next

    " Found free slot
    lac 8           " Get current pointer
    tad dm4         " Back up to start of entry
    dac newproc     " Save new process number
    jmp found

2:
    isz 8           " Skip words 1, 2, 3
    isz 8
    isz 8
    isz count       " Decrement loop counter
    jmp 1b          " Try next slot

    " No free slots - fork fails
    lac dm1         " Return -1
    jmp sysexit

found:
    " Step 2: Allocate new PID
    isz nproc       " Increment global PID counter
    lac nproc       " Get new PID
    dac childpid    " Save it

    " Step 3: Set up new process table entry
    lac newproc     " Address of new entry
    dac 8
    lac d1          " State 1 = in memory, ready
    dac 8 i         " ulist[new,0] = 1

    lac childpid    " Child PID
    dac 8 i         " ulist[new,1] = PID

    lac swaptrack   " Get available swap track
    dac 8 i         " ulist[new,2] = swap track

    dza             " Clear word 3
    dac 8 i         " ulist[new,3] = 0

    " Step 4: Copy parent's userdata to child
    "         This includes:
    "         - All open file descriptors
    "         - Current directory
    "         - User ID
    "         - Saved registers

    law userdata    " Source = parent's userdata
    dac from
    law childdata   " Destination = child's userdata
    dac to
    law 64          " Copy 64 words
    dac count
    jms copy        " Perform block copy

    " Step 5: Update child's userdata fields
    lac childpid
    dac childdata+5 " Child's upid = new PID

    lac upid        " Parent's PID
    dac childdata+6 " Child's uppid = parent PID

    dza
    dac childdata+0 " Child's uac = 0 (return value)

    " Step 6: Increment reference counts for open files
    "         Both parent and child now point to same files
    law ufil        " File descriptor table
    dac 8
    law 30          " 30 file descriptor slots
    dac count

1:
    lac 8 i         " Get file descriptor
    sza             " Skip if unused (0)
    jms incref      " Increment reference count
    isz count
    jmp 1b

    " Step 7: Write child to disk (swap out)
    lac newproc     " Child process number
    jms dskswap     " Write to swap track

    " Child is now on disk in state 1 (ready)
    " When scheduler picks it, it will be swapped in

    " Step 8: Return to parent with child PID
    lac childpid    " Load child PID
    dac uac         " Set return value
    jmp sysexit     " Return to user mode</code></pre>
<h3 data-number="7.5.3" id="parentchild-relationship"><span class="header-section-number">7.5.3</span> Parent/Child
Relationship</h3>
<p>After fork completes:</p>
<p><strong>Parent process:</strong> - Continues execution after the
<code>sys fork</code> instruction - AC contains the child‚Äôs PID
(non-zero) - Can wait for child to terminate using <code>wait()</code>
system call - Can send messages to child using its PID</p>
<p><strong>Child process:</strong> - Starts execution at the
<strong>same point</strong> (after <code>sys fork</code>) - AC contains
0 (distinguishing it from parent) - Has PPID set to parent‚Äôs PID - Has
its own copy of all file descriptors - Shares the same files (same file
table entries)</p>
<p><strong>Shared resources:</strong> - Open files (both processes have
descriptors to same file table entries) - Current directory inode number
- User ID</p>
<p><strong>Separate resources:</strong> - Process ID (different PIDs) -
Memory (child has its own copy on disk) - Process state (independent
scheduling)</p>
<h3 data-number="7.5.4" id="memory-copying-via-swapping"><span class="header-section-number">7.5.4</span> Memory Copying via
Swapping</h3>
<p>This is the clever part: PDP-7 Unix doesn‚Äôt have enough memory to
hold both parent and child simultaneously. Instead:</p>
<ol type="1">
<li><strong>Parent is in memory</strong> when fork is called</li>
<li><strong>Child‚Äôs memory is created</strong> by swapping:
<ul>
<li>Allocate a swap track (06000 or 07000)</li>
<li>Write parent‚Äôs memory to that track</li>
<li>Mark child as state 3 (swapped out, ready)</li>
</ul></li>
<li><strong>Parent continues</strong> running in memory</li>
<li><strong>Child waits</strong> on disk until scheduled</li>
<li>When child is scheduled, it‚Äôs <strong>swapped in</strong> (and
parent swapped out)</li>
</ol>
<p>This is much simpler than copying memory within RAM, which would
require: - Temporary buffer space - Complex memory management - Dual
mapping of address space</p>
<p><strong>Performance cost</strong>: Each fork takes about 100ms‚Äî50ms
to write child to disk, 50ms to eventually swap it in.</p>
<h3 data-number="7.5.5" id="process-table-setup"><span class="header-section-number">7.5.5</span> Process Table Setup</h3>
<p>After fork, the process table looks like this:</p>
<pre><code>Before fork (1 process):
ulist[0]: State=1, PID=42, Track=06000   (parent, in memory)
ulist[1]: State=0, PID=0,  Track=0       (unused)
...

After fork (2 processes):
ulist[0]: State=1, PID=42, Track=06000   (parent, in memory)
ulist[1]: State=3, PID=43, Track=07000   (child, on disk, ready)
...

userdata (parent):
  uac = 43 (child PID)
  upid = 42
  uppid = 1 (init)

childdata (on disk track 07000):
  uac = 0 (child return value)
  upid = 43
  uppid = 42 (parent)</code></pre>
<h3 data-number="7.5.6" id="return-value-difference"><span class="header-section-number">7.5.6</span> Return Value Difference</h3>
<p>The <strong>magic</strong> of fork is the different return
values:</p>
<pre class="assembly"><code>" Before fork (parent only):
"   AC = (doesn't matter)
"   upid = 42

    sys fork

" After fork returns to PARENT:
"   AC = 43 (child PID)
"   upid = 42 (still parent)

" When child is scheduled:
"   AC = 0 (child return value)
"   upid = 43 (now child)</code></pre>
<p>This is set up in two places:</p>
<p><strong>For parent</strong> (in fork code):</p>
<pre class="assembly"><code>    lac childpid    " Load child PID
    dac uac         " Set parent's return AC</code></pre>
<p><strong>For child</strong> (in fork code):</p>
<pre class="assembly"><code>    dza
    dac childdata+0 " Set child's uac = 0</code></pre>
<p>When child is later swapped in, <code>uac</code> is restored to AC,
giving it 0.</p>
<h3 data-number="7.5.7" id="full-annotated-fork-code-with-comments"><span class="header-section-number">7.5.7</span> Full Annotated fork() Code
with Comments</h3>
<p>Here‚Äôs the complete implementation with detailed annotations:</p>
<pre class="assembly"><code>.fork:
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 1: FIND FREE PROCESS SLOT
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    law ulist-4     " Start at ulist-4 (auto-inc will add 4)
    dac 8           " Set up auto-increment pointer 8
    law mnproc      " Load -10 (negative count)
    dac count       " Initialize loop counter

findslot:
    lac 8 i         " Load ulist[i,0] via auto-increment
                    " This also advances pointer by 1
    and d3          " Mask to get state bits (0-1)
    sza             " Skip if state == 0 (free slot)
    jmp tryslot     " State != 0, try next slot

    " Found free slot!
    lac 8           " Get current pointer value
    tad dm4         " Subtract 4 to get entry start
    dac newproc     " Save entry address
    jmp found       " Proceed to allocate

tryslot:
    isz 8           " Skip ulist[i,1]
    isz 8           " Skip ulist[i,2]
    isz 8           " Skip ulist[i,3]
                    " Pointer now at ulist[i+1,0]
    isz count       " Increment counter (toward 0)
    jmp findslot    " Continue if not yet 0

    " All slots full - fork fails
    lac dm1         " Load -1
    jmp sysexit     " Return error to user

found:
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 2: ALLOCATE NEW PROCESS ID
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    isz nproc       " Increment global PID counter
    lac nproc       " Load new PID value
    dac childpid    " Save for later use

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 3: INITIALIZE PROCESS TABLE ENTRY
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac newproc     " Load entry address
    dac 8           " Set up pointer

    lac d1          " State 1 = in memory, ready
    dac 8 i         " ulist[new,0] = 1

    lac childpid    " Load child PID
    dac 8 i         " ulist[new,1] = childpid

    lac swaptrack   " Get free swap track (06000 or 07000)
    dac 8 i         " ulist[new,2] = track

    dza             " Zero accumulator
    dac 8 i         " ulist[new,3] = 0

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 4: COPY PARENT'S USERDATA TO CHILD
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " This creates duplicate of parent's entire state:
    " - Saved registers (AC, MQ, PC, rq)
    " - User ID
    " - All 30 file descriptors
    " - Current directory
    " - Kernel stack

    law userdata    " Source address
    dac from
    law childdata   " Destination (temporary buffer)
    dac to
    law 64          " Copy 64 words
    dac count
    jms copy        " Block copy routine

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 5: CUSTOMIZE CHILD'S USERDATA
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Update fields that must differ from parent:

    lac childpid
    dac childdata+5 " upid = new child PID

    lac upid        " Parent's PID
    dac childdata+6 " uppid = parent PID

    dza
    dac childdata+0 " uac = 0 (child's fork return value)

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 6: INCREMENT FILE REFERENCE COUNTS
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Both processes now share the same open files
    " Must increment reference counts so files aren't
    " closed prematurely when one process closes them

    law ufil        " File descriptor table
    dac 8           " Set up pointer
    law 30          " 30 slots
    dac count

copyfd:
    lac 8 i         " Get file descriptor
    sza             " Skip if 0 (unused)
    jms incref      " Increment reference count in file table
    isz count
    jmp copyfd

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 7: SWAP CHILD TO DISK
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Child can't run yet - need to free memory
    " Write child's memory image to its swap track

    lac newproc     " Child process number
    lac childdata   " Child's userdata (in temp buffer)
    jms dskswap     " Write to track 06000 or 07000

    " Update child's state
    lac newproc
    alss 2          " √ó 4 for entry offset
    tad ulist
    dac 8
    lac d3          " State 3 = on disk, ready
    dac 8 i         " Update ulist[new,0]

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 8: RETURN TO PARENT
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac childpid    " Load child PID
    dac uac         " Set parent's return value
    jmp sysexit     " Return to user mode

    " Parent continues execution with AC = child PID
    " Child is on disk, will run when scheduled</code></pre>
<h3 data-number="7.5.8" id="execution-trace-example"><span class="header-section-number">7.5.8</span> Execution Trace Example</h3>
<p>Let‚Äôs trace a complete fork operation:</p>
<pre><code>Initial State (parent process 42):
  Memory 0-7777:  Parent's code and data
  userdata.upid:  42
  userdata.uppid: 1
  userdata.uid:   12 (user "ken")
  ulist[0]:       State=1, PID=42, Track=06000

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Parent executes:  sys fork

T=0ms: Enter .fork
  - Search process table
  - Find free slot at ulist[1]

T=1ms: Allocate PID
  - nproc: 42 ‚Üí 43
  - childpid = 43

T=2ms: Initialize ulist[1]
  - ulist[1,0] = 1 (state: in memory, ready)
  - ulist[1,1] = 43 (PID)
  - ulist[1,2] = 07000 (swap track)
  - ulist[1,3] = 0

T=3ms: Copy userdata
  - Copy 64 words: userdata ‚Üí childdata buffer
  - All registers, files, directory copied

T=4ms: Customize child's userdata
  - childdata.uac = 0
  - childdata.upid = 43
  - childdata.uppid = 42

T=5ms: Update file references
  - For each open file, increment refcount
  - Both processes now share files

T=50ms: Swap child to disk
  - Write 2048 words to track 07000
  - Takes ~45ms for disk I/O

T=51ms: Update child state
  - ulist[1,0] = 3 (on disk, ready)

T=52ms: Return to parent
  - uac = 43
  - Return to user mode

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Final State:
  Memory 0-7777:  Parent's code and data (unchanged)

  Parent (PID 42):
    AC = 43 (child PID)
    State = 1 (in memory, ready, running)

  Child (PID 43):
    AC = 0 (swapped-out value, not yet seen)
    State = 3 (on disk, ready, waiting)
    Disk track 07000: Complete memory image

  Process table:
    ulist[0]: State=1, PID=42, Track=06000
    ulist[1]: State=3, PID=43, Track=07000

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Later (when child is scheduled):

T=100ms: Swap child in
  - Swap parent to track 06000
  - Read child from track 07000
  - Restore childdata to userdata

T=150ms: Child begins execution
  - AC = 0 (restored from uac)
  - Execution continues after 'sys fork'
  - Child detects AC=0 and knows it's child</code></pre>
<h2 data-number="7.6" id="process-termination---exit"><span class="header-section-number">7.6</span> 8.6 Process Termination -
exit()</h2>
<p>The <code>exit()</code> system call terminates the current process.
It‚Äôs simpler than fork‚Äîno new process to create, just cleanup and
notification.</p>
<h3 data-number="7.6.1" id="what-exit-does"><span class="header-section-number">7.6.1</span> What exit() Does</h3>
<ol type="1">
<li><strong>Close all open files</strong> (release file
descriptors)</li>
<li><strong>Send exit message</strong> to parent process</li>
<li><strong>Free process table entry</strong> (set state to 0)</li>
<li><strong>Never return</strong> (process ceases to exist)</li>
</ol>
<h3 data-number="7.6.2" id="complete-exit-implementation"><span class="header-section-number">7.6.2</span> Complete exit()
Implementation</h3>
<p>Located in <code>s3.s</code>:</p>
<pre class="assembly"><code>" exit - Terminate current process
" Never returns to caller

.exit:
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 1: CLOSE ALL OPEN FILE DESCRIPTORS
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    law ufil        " File descriptor table
    dac 8           " Auto-increment pointer
    law 30          " 30 file descriptor slots
    dac count

closeloop:
    lac 8 i         " Get file descriptor
    sza             " Skip if unused (0)
    jms closefd     " Close this file
    isz count       " Decrement counter
    jmp closeloop   " Next descriptor

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 2: SEND EXIT MESSAGE TO PARENT
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Parent may be waiting for child to finish
    " Send message with our PID so parent can collect

    lac upid        " Our process ID
    dac mesg        " Message = our PID
    lac uppid       " Parent's PID
    jms smes        " Send message to parent

    " If parent has exited (uppid=0), message goes nowhere
    " In real PDP-11 Unix, child would be reparented to init

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 3: FREE PROCESS TABLE ENTRY
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac proc        " Current process number
    alss 2          " √ó 4 for entry offset
    tad ulist       " Add base address
    dac 8           " Pointer to our entry

    dza             " Zero accumulator
    dac 8 i         " ulist[proc,0] = 0 (state = unused)
    dac 8 i         " ulist[proc,1] = 0 (clear PID)
    dac 8 i         " ulist[proc,2] = 0 (clear track)
    dac 8 i         " ulist[proc,3] = 0

    " Process table entry is now free for reuse

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 4: SCHEDULE ANOTHER PROCESS
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " We can't return to user mode - process is gone!
    " Must immediately switch to another process

    jms schedule    " Find next ready process
                    " This never returns</code></pre>
<h3 data-number="7.6.3" id="cleanup-operations"><span class="header-section-number">7.6.3</span> Cleanup Operations</h3>
<h4 data-number="7.6.3.1" id="closing-file-descriptors"><span class="header-section-number">7.6.3.1</span> Closing File
Descriptors</h4>
<p>When a process exits, all its open files must be closed:</p>
<pre class="assembly"><code>closefd:
    " Input: AC = file descriptor number
    dac fd          " Save fd

    " Get file table entry
    lac fd
    tad filelist    " Address of file table
    dac 8
    lac 8 i         " Get file structure pointer
    dac fptr

    " Decrement reference count
    lac fptr
    dac 8
    isz 8           " Point to refcount field
    lac 8 i         " Get current refcount
    cma             " Complement
    tad d1          " Add 1 (equivalent to subtract 1)
    dac 8 i         " Store decremented refcount

    sza             " Skip if now zero
    jmp notlast     " Still references, don't close file

    " Last reference - close file
    lac fptr
    jms reallyclose " Write inode, free blocks

notlast:
    " Clear descriptor slot
    lac fd
    tad ufil
    dac 8
    dza
    dac 8 i         " ufil[fd] = 0

    jmp closefd i   " Return</code></pre>
<p><strong>Why decrement reference counts?</strong> Because fork creates
shared file descriptors. If parent and child both have file 3 open: -
Parent‚Äôs ufil[3] = 14 (file table entry) - Child‚Äôs ufil[3] = 14 (same
entry) - File table entry 14 has refcount = 2</p>
<p>When child exits and closes file 3: - Refcount: 2 ‚Üí 1 - File stays
open (parent still using it)</p>
<p>When parent later closes file 3: - Refcount: 1 ‚Üí 0 - File actually
closed</p>
<h3 data-number="7.6.4" id="message-to-parent"><span class="header-section-number">7.6.4</span> Message to Parent</h3>
<p>The exit message allows the parent to detect termination:</p>
<pre class="assembly"><code>" Parent process can wait for child:
.wait:
    jms rmes        " Receive message (blocking)
    " AC now contains child PID that exited
    jmp sysexit     " Return child PID to caller</code></pre>
<p>The message format is simple: - <strong>Sender</strong>: Child
process (automatically added by smes) - <strong>Recipient</strong>:
Parent PID (from uppid) - <strong>Data</strong>: Child‚Äôs PID (so parent
knows which child exited)</p>
<p>If the parent has already exited (uppid=0 or invalid), the message is
lost. In later Unix versions, orphaned processes are reparented to PID 1
(init), which periodically collects exit messages.</p>
<h3 data-number="7.6.5" id="process-table-cleanup"><span class="header-section-number">7.6.5</span> Process Table Cleanup</h3>
<p>Setting the state to 0 is critical:</p>
<pre class="assembly"><code>    dza
    dac 8 i         " ulist[proc,0] = 0</code></pre>
<p>This makes the slot available for the next <code>fork()</code>. The
PID is also cleared to prevent confusion:</p>
<pre class="assembly"><code>    dac 8 i         " ulist[proc,1] = 0</code></pre>
<h3 data-number="7.6.6" id="no-return-path"><span class="header-section-number">7.6.6</span> No Return Path</h3>
<p>Unlike most system calls, <code>exit()</code> does NOT call
<code>sysexit</code>:</p>
<pre class="assembly"><code>" Normal system call:
.open:
    " ... do work ...
    jmp sysexit     " Return to user mode

" Exit is different:
.exit:
    " ... cleanup ...
    jms schedule    " Switch to another process
    " NEVER REACHED</code></pre>
<p>The <code>schedule</code> function finds another ready process and
jumps to it. There‚Äôs no way back‚Äîthe process is gone.</p>
<h3 data-number="7.6.7" id="complete-execution-trace"><span class="header-section-number">7.6.7</span> Complete Execution Trace</h3>
<p>Let‚Äôs trace a process exiting:</p>
<pre><code>Initial State (child process 43):
  PID: 43
  PPID: 42 (parent)
  Open files: 3, 4, 7
  State: 1 (in memory, running)

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Child executes:  sys exit

T=0ms: Enter .exit

T=1ms: Close file descriptor 3
  - ufil[3] = 14 (file table entry)
  - File 14 refcount: 2 ‚Üí 1 (parent still has it)
  - Keep file open
  - ufil[3] = 0 (clear descriptor)

T=2ms: Close file descriptor 4
  - ufil[4] = 7
  - File 7 refcount: 1 ‚Üí 0 (last reference)
  - Really close file 7
  - Write inode to disk
  - Free disk blocks
  - ufil[4] = 0

T=3ms: Close file descriptor 7
  - ufil[7] = 21
  - File 21 refcount: 1 ‚Üí 0
  - Really close file 21
  - ufil[7] = 0

T=15ms: Send exit message
  - Message: PID 43
  - Destination: PID 42 (parent)
  - smes: enqueue message

T=16ms: Free process table entry
  - ulist[1,0] = 0 (state unused)
  - ulist[1,1] = 0 (clear PID)
  - ulist[1,2] = 0 (clear track)
  - ulist[1,3] = 0

T=17ms: Schedule another process
  - Search for ready process
  - Find process 42 (parent, state 2‚Üí1, was blocked in wait)
  - Swap parent in (if needed)
  - Jump to parent's saved PC
  - Parent's AC = 43 (from message)

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Final State:
  Process 43: GONE (state 0, no longer exists)
  Process 42 (parent): running, AC=43 (child PID)

  File table:
    Entry 14: refcount=1 (parent still has it open)
    Entry 7:  freed (refcount was 0)
    Entry 21: freed (refcount was 0)</code></pre>
<h3 data-number="7.6.8" id="orphaned-processes"><span class="header-section-number">7.6.8</span> Orphaned Processes</h3>
<p>What if the parent exits before the child?</p>
<pre class="assembly"><code>" Parent (PID 42):
    sys fork
    sza
    jmp parent

child:
    " Child process
    " ... do work ...
    sys exit        " Try to send message to parent

parent:
    " Parent doesn't wait
    sys exit        " Parent exits immediately!</code></pre>
<p><strong>Problem</strong>: Child‚Äôs exit message has nowhere to go
(uppid=42, but PID 42 no longer exists).</p>
<p><strong>PDP-7 Unix solution</strong>: Message is lost. Child‚Äôs exit
is not collected.</p>
<p><strong>PDP-11 Unix solution</strong> (later): Orphaned processes are
reparented to PID 1 (init), which periodically calls <code>wait()</code>
to collect zombies.</p>
<h2 data-number="7.7" id="process-swapping"><span class="header-section-number">7.7</span> 8.7 Process Swapping</h2>
<p>With only 8K of memory and support for multiple processes, PDP-7 Unix
needs a way to multiplex memory among processes. The solution is
<strong>swapping</strong>: move inactive processes to disk, load active
processes into memory.</p>
<h3 data-number="7.7.1" id="why-swapping"><span class="header-section-number">7.7.1</span> Why Swapping?</h3>
<p><strong>The fundamental problem:</strong> - 8K words of memory
(addresses 0-7777 octal) - Each process needs ~2K words for code and
data - Maximum 4 processes could fit simultaneously - But with kernel,
buffers, file cache, only ~6K available for user processes -
<strong>Conclusion</strong>: Only 1 user process fits in memory at a
time</p>
<p><strong>The solution:</strong> - Keep only the
<strong>active</strong> process in memory - Write
<strong>inactive</strong> processes to disk (swap out) - Read processes
back when needed (swap in) - Processes ‚Äútake turns‚Äù using memory</p>
<p><strong>Advantages:</strong> - Support many more than 4 processes (up
to 10) - Simple memory management (no partitions, no fragmentation) -
Fair CPU sharing via time-slicing</p>
<p><strong>Disadvantages:</strong> - Swapping is slow (~100ms per swap)
- Context switch overhead - Limited by disk I/O speed</p>
<h3 data-number="7.7.2" id="swap-algorithm-in-s1.s"><span class="header-section-number">7.7.2</span> Swap Algorithm in s1.s</h3>
<p>The swap scheduler runs at every system call exit and clock tick:</p>
<pre class="assembly"><code>" Swap scheduler - called before returning to user mode
swap:
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " CHECK 1: Has time quantum expired?
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac s.quantum   " Time remaining in quantum
    sna             " Skip if non-zero
    jmp needswap    " Quantum expired, must swap

    " Quantum remains, keep running
    jmp noswap

needswap:
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " CHECK 2: Is there another ready process?
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    jms lookfor     " Search for ready process
    sza             " Skip if found one
    jmp doswap      " Found another, swap out

    " No other ready process, keep running
    law quantum     " Reset quantum
    dac s.quantum
    jmp noswap

doswap:
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 1: SAVE CURRENT PROCESS TO DISK
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac proc        " Current process number
    jms dskswap     " Write to disk

    " Update process state
    lac proc
    alss 2          " √ó 4
    tad ulist
    dac 8
    lac d3          " State 3 = on disk, ready
    dac 8 i

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 2: LOAD NEXT PROCESS FROM DISK
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac nextproc    " Process to run (from lookfor)
    jms dskswapin   " Read from disk

    " Update process state
    lac nextproc
    alss 2
    tad ulist
    dac 8
    lac d1          " State 1 = in memory, ready
    dac 8 i

    " Update current process pointer
    lac nextproc
    dac proc

    " Reset quantum
    law quantum
    dac s.quantum

noswap:
    " Return to process (old or new)
    jmp swapdone</code></pre>
<h3 data-number="7.7.3" id="quantum-based-preemption"><span class="header-section-number">7.7.3</span> Quantum-Based Preemption</h3>
<p>Each process gets a <strong>time quantum</strong> of 30 clock ticks
(approximately 0.5 seconds):</p>
<pre class="assembly"><code>" In s8.s - Constants
quantum = 30    " Clock ticks per quantum (60Hz clock)

" In s7.s - Clock interrupt handler
clkint:
    " Clock tick (60 Hz)
    isz s.quantum   " Increment quantum counter
                    " (stored as negative)
    jmp clkdone     " Not expired yet

    " Quantum expired!
    " Set flag to swap at next system call exit
    lac d1
    dac s.needswap

clkdone:
    " Continue interrupt processing
    jmp intdone</code></pre>
<p><strong>How it works:</strong> 1. s.quantum starts at -30 (negative
of quantum) 2. Each clock tick, ISZ increments it (-30, -29, -28, ‚Ä¶) 3.
When it reaches 0, ISZ skips (quantum expired) 4. Set s.needswap flag 5.
At next system call exit, swap scheduler runs</p>
<p><strong>Why not swap immediately in clock interrupt?</strong> -
Interrupts should be short - Swapping requires disk I/O (slow) - Safer
to swap at controlled exit point</p>
<h3 data-number="7.7.4" id="disk-tracks-0600007000"><span class="header-section-number">7.7.4</span> Disk Tracks 06000/07000</h3>
<p>Two disk tracks are reserved for swapping:</p>
<pre class="assembly"><code>" In s8.s - Swap tracks
swaptrk1: 06000     " First swap track
swaptrk2: 07000     " Second swap track

" Process table entries contain swap track:
"   ulist[proc,2] = 06000 or 07000</code></pre>
<p><strong>Why only 2 tracks?</strong> - Each process needs 1 track
(2048 words) - With 10 processes max, need 10 tracks - But only 1
process is in memory at a time - The other 9 are on disk -
<strong>Actually need 9 tracks, but PDP-7 Unix only supports
2!</strong></p>
<p>This is a <strong>bug</strong> or limitation: PDP-7 Unix cannot
actually support 10 concurrent processes. In practice, only 2-3
processes were ever used simultaneously.</p>
<p><strong>Track layout:</strong> - Track 06000: Contains swapped-out
process memory - Track 07000: Contains another swapped-out process
memory</p>
<p>Each track holds: - Words 0-7777: Full 8K memory image - Includes
code, data, stack - Does NOT include hardware registers (those are in
userdata)</p>
<h3 data-number="7.7.5" id="complete-swapping-implementation"><span class="header-section-number">7.7.5</span> Complete Swapping
Implementation</h3>
<p>The <code>dskswap</code> function in <code>s5.s</code> performs the
actual I/O:</p>
<pre class="assembly"><code>" dskswap - Write current process memory to disk
" Input: AC = process number
" Uses track from ulist[proc,2]

dskswap:
    dac savproc     " Save process number

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 1: GET SWAP TRACK ADDRESS
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac savproc
    alss 2          " √ó 4 for entry offset
    tad ulist
    dac 8
    isz 8           " Skip to ulist[proc,2]
    isz 8
    lac 8 i         " Get track number
    dac track

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 2: WRITE MEMORY TO DISK
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Write all 8K words (addresses 0-7777)
    " DECtape track = 1024 words
    " Need 8 track writes to save 8K

    dza             " Start at memory address 0
    dac addr
    lac track       " Disk track
    dac dskaddr
    law 8           " Write 8 √ó 1024 words
    dac count

swploop:
    lac addr        " Memory address
    dac from
    lac dskaddr     " Disk address
    jms dskwr       " Write 1024 words

    lac addr
    tad d1024       " Advance memory pointer
    dac addr

    lac dskaddr
    tad d1          " Next disk sector
    dac dskaddr

    isz count
    jmp swploop

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 3: WRITE USERDATA TO DISK
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Write userdata (64 words) to end of track
    law userdata
    dac from
    lac track
    tad d8          " Sector 8 (after memory image)
    jms dskwr       " Write 64 words

    jmp dskswap i   " Return

d1024: 1024        " Words per sector</code></pre>
<p>The swap-in function is similar:</p>
<pre class="assembly"><code>" dskswapin - Read process memory from disk
" Input: AC = process number

dskswapin:
    dac savproc

    " Get track number
    lac savproc
    alss 2
    tad ulist
    dac 8
    isz 8
    isz 8
    lac 8 i
    dac track

    " Read 8K memory from disk
    dza
    dac addr
    lac track
    dac dskaddr
    law 8
    dac count

swpinloop:
    lac dskaddr     " Disk address
    lac addr        " Memory address
    dac to
    jms dskrd       " Read 1024 words

    lac addr
    tad d1024
    dac addr

    lac dskaddr
    tad d1
    dac dskaddr

    isz count
    jmp swpinloop

    " Read userdata from disk
    lac track
    tad d8
    law userdata
    dac to
    jms dskrd       " Read 64 words

    jmp dskswapin i</code></pre>
<h3 data-number="7.7.6" id="performance-analysis"><span class="header-section-number">7.7.6</span> Performance Analysis</h3>
<p><strong>Swap-out time</strong> (write process to disk): - 8K words √∑
1024 words/sector = 8 sectors - Each sector write ‚âà 6ms (DECtape speed)
- Total: 8 √ó 6ms = <strong>48ms</strong> - Plus userdata (64 words) ‚âà
1ms - <strong>Total swap-out: ~50ms</strong></p>
<p><strong>Swap-in time</strong> (read process from disk): - Same as
swap-out: <strong>~50ms</strong></p>
<p><strong>Total context switch time:</strong> - Swap-out: 50ms -
Swap-in: 50ms - Overhead (scheduling, state update): 2ms -
<strong>Total: ~102ms</strong></p>
<p><strong>Throughput impact:</strong> - With 30-tick quantum (0.5s) and
102ms swap time - Effective CPU utilization: 500ms / (500ms + 102ms) =
<strong>83%</strong> - 17% overhead from swapping</p>
<p><strong>Comparison with other systems:</strong> -
<strong>Multics</strong> (1969): Paging overhead ~5% (much faster disk)
- <strong>OS/360</strong> (batch): No swapping, 0% overhead (but no
multitasking) - <strong>Modern Linux</strong>: Context switch ~1-10Œºs
(4-5 orders of magnitude faster!)</p>
<h3 data-number="7.7.7" id="complete-execution-trace-1"><span class="header-section-number">7.7.7</span> Complete Execution Trace</h3>
<p>Let‚Äôs trace a full swap cycle between two processes:</p>
<pre><code>Initial State:
  Process 42 (shell): State 1, in memory
  Process 43 (user program): State 3, on disk (track 07000)
  s.quantum = -5 (5 ticks remaining)
  Current proc = 42

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

T=0ms: Clock tick (59th this quantum)
  - ISZ s.quantum: -5 ‚Üí -4
  - Quantum not yet expired

T=16ms: Clock tick (60th this quantum)
  - ISZ s.quantum: -1 ‚Üí 0
  - Skip occurs, quantum expired
  - Set s.needswap = 1

T=17ms: Process 42 makes system call (read)
  - Enter system call handler
  - Process read operation
  - Return to swap scheduler

T=20ms: Swap scheduler runs
  - Check s.needswap: 1 (must swap)
  - Call lookfor: finds process 43 (state 3)
  - Decide to swap

T=21ms: Swap out process 42
  - dskswap(42)
  - Write memory 0-7777 to track 06000
  - Write userdata to track 06000, sector 8
  - DECtape transfer: 48ms

T=69ms: Swap out complete
  - Update ulist[42,0] = 3 (on disk, ready)

T=70ms: Swap in process 43
  - dskswapin(43)
  - Read track 07000 to memory 0-7777
  - Read userdata from track 07000, sector 8
  - DECtape transfer: 48ms

T=118ms: Swap in complete
  - Update ulist[43,0] = 1 (in memory, ready)
  - Set proc = 43
  - Reset s.quantum = -30

T=120ms: Resume process 43
  - Restore AC, MQ from userdata
  - Jump to saved PC
  - Process 43 is now running!

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Final State:
  Process 42: State 3, on disk (track 06000)
  Process 43: State 1, in memory, running
  s.quantum = -30
  Current proc = 43

  Total swap time: 100ms
  Processes "traded places" in memory</code></pre>
<h2 data-number="7.8" id="scheduling"><span class="header-section-number">7.8</span> 8.8 Scheduling</h2>
<p>Process scheduling in PDP-7 Unix is refreshingly simple:
<strong>round-robin</strong> with equal time quanta and no priorities.
Every process gets exactly 30 clock ticks (0.5 seconds) before being
preempted.</p>
<h3 data-number="7.8.1" id="simple-round-robin"><span class="header-section-number">7.8.1</span> Simple Round-Robin</h3>
<p>The scheduler has one goal: <strong>find the next ready
process</strong>. That‚Äôs it. No priority calculations, no fairness
adjustments, no complex heuristics.</p>
<pre class="assembly"><code>" lookfor - Find next ready process
" Returns: AC = process number, or 0 if none ready

lookfor:
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STRATEGY: Search process table circularly, starting
    "           after current process
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    lac proc        " Current process number
    tad d1          " Start with next process
    dac search      " Initialize search pointer

    law mnproc      " Counter = 10 (max processes)
    dac count

searchloop:
    lac search      " Get candidate process number
    dac temp

    " Wrap around if past end
    lac temp
    sad mnproc      " At limit?
    dza             " Yes, wrap to 0
    dac search

    " Get process state
    lac search
    alss 2          " √ó 4 for entry offset
    tad ulist
    dac 8
    lac 8 i         " Get ulist[search,0]
    and d3          " Mask to state bits

    " Check if ready
    sad d1          " State 1 = in memory, ready?
    jmp foundready
    sad d3          " State 3 = on disk, ready?
    jmp foundready

    " Not ready, try next
    lac search
    tad d1
    dac search
    isz count
    jmp searchloop

    " No ready processes found
    dza             " Return 0
    jmp lookfor i

foundready:
    lac search      " Return process number
    jmp lookfor i</code></pre>
<h3 data-number="7.8.2" id="quantum-30-clock-ticks"><span class="header-section-number">7.8.2</span> Quantum = 30 Clock Ticks</h3>
<p>The time quantum is a compile-time constant:</p>
<pre class="assembly"><code>" In s8.s
quantum = 30        " Clock ticks per quantum
                    " At 60Hz, this is 0.5 seconds</code></pre>
<p><strong>Why 30 ticks (0.5 seconds)?</strong></p>
<p><strong>Too short</strong> (e.g., 10 ticks = 0.17s): - Frequent
context switches - High swapping overhead (102ms per swap) - Poor
throughput</p>
<p><strong>Too long</strong> (e.g., 300 ticks = 5s): - Poor
responsiveness - Feels like batch processing - User waits long time for
interaction</p>
<p><strong>30 ticks is a compromise:</strong> - User gets response
within 1-2 seconds - Swapping overhead only ~20% - Feels reasonably
interactive</p>
<p><strong>Comparison with other systems:</strong> -
<strong>Multics</strong> (1969): 200ms quantum (similar) - <strong>Unix
v6</strong> (1975): 100ms quantum (faster hardware) - <strong>Modern
Linux</strong>: 1-10ms quantum (much faster I/O)</p>
<h3 data-number="7.8.3" id="no-priorities"><span class="header-section-number">7.8.3</span> No Priorities</h3>
<p><strong>Every process is equal.</strong> There are no: - Priority
levels (nice values) - Real-time processes - Interactive vs.¬†batch
distinction - Aging or starvation prevention</p>
<p>This simplicity is both a strength and weakness:</p>
<p><strong>Strengths:</strong> - Predictable scheduling (easy to reason
about) - No priority inversion problems - No starvation (everyone gets
equal time) - Minimal code complexity</p>
<p><strong>Weaknesses:</strong> - CPU-bound processes can make system
feel sluggish - No way to prioritize important work - Batch jobs get
same treatment as interactive shell</p>
<p><strong>In practice</strong>, with 1-2 users and simple programs,
priorities weren‚Äôt needed. The system was fast enough.</p>
<h3 data-number="7.8.4" id="the-lookfor-function---complete-code"><span class="header-section-number">7.8.4</span> The lookfor Function -
Complete Code</h3>
<p>Here‚Äôs the full scheduler with detailed comments:</p>
<pre class="assembly"><code>lookfor:
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Find next ready process using round-robin search
    " Returns: AC = process number (0-9), or 0 if none ready
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    lac proc        " Start with current process
    tad d1          " Look at next one first
    dac search      " search = proc + 1

    law mnproc      " Initialize counter
    dac count       " Will check all 10 slots

searchloop:
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Wrap around if we've gone past last slot
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac search
    sad mnproc      " search == 10?
    dza             " Yes, wrap to 0
    dac search      " search = 0

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Get process table entry
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac search      " Process number
    alss 2          " √ó 4 (4 words per entry)
    tad ulist       " Add base address
    dac 8           " Set up auto-increment pointer

    lac 8 i         " Load ulist[search,0]
    and d3          " Mask to state bits (0-1)
    dac pstate      " Save for comparison

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Check for ready states (1 or 3)
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac pstate
    sad d1          " State 1 (in memory, ready)?
    jmp foundone    " Yes!

    lac pstate
    sad d3          " State 3 (on disk, ready)?
    jmp foundone    " Yes!

    " State 0 (unused) or 2 (blocked) - skip this process

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Try next process
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac search
    tad d1          " search++
    dac search

    isz count       " Decrement counter
    jmp searchloop  " Continue if more to check

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Checked all processes, none ready
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    jmp idle        " Idle loop (wait for interrupt)

foundone:
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Found ready process
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac search      " Return process number
    jmp lookfor i   " Return to caller</code></pre>
<h3 data-number="7.8.5" id="idle-loop"><span class="header-section-number">7.8.5</span> Idle Loop</h3>
<p>What happens when <strong>no processes are ready</strong>? The system
enters an idle loop:</p>
<pre class="assembly"><code>idle:
    " All processes are blocked or swapped out
    " Wait for interrupt to make something ready

    " Enable interrupts
    " (on PDP-7, interrupts are always enabled in user mode)

idleloop:
    " Spin waiting for interrupt
    " When clock tick or I/O interrupt occurs,
    " interrupt handler may unblock a process

    jms lookfor     " Check again
    sza             " Found ready process?
    jmp schedule    " Yes, run it

    jmp idleloop    " No, keep waiting</code></pre>
<p><strong>What wakes the system from idle?</strong> - <strong>Clock
interrupt</strong>: May deliver a message or wake sleeping process -
<strong>Disk interrupt</strong>: I/O completes, process becomes ready -
<strong>Keyboard interrupt</strong>: Input arrives, shell becomes ready
- <strong>Display interrupt</strong>: Output completes</p>
<h3 data-number="7.8.6" id="complete-scheduling-example"><span class="header-section-number">7.8.6</span> Complete Scheduling
Example</h3>
<p>Let‚Äôs trace scheduling decisions over time:</p>
<pre><code>Initial State:
  Process 1 (init):  State 2 (blocked, waiting for message)
  Process 42 (sh):   State 1 (in memory, ready, running)
  Process 43 (user): State 3 (on disk, ready)
  Current process: 42
  Quantum: -10 (10 ticks remaining)

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

T=0ms: Process 42 running
  - Executing user commands
  - Quantum counts down

T=150ms: Clock tick (10 ticks later)
  - ISZ s.quantum: 0
  - Quantum expired
  - Set s.needswap = 1

T=151ms: Process 42 makes system call
  - Enter kernel
  - swap() scheduler runs
  - lookfor() searches:
    - Check proc 43: State 3 (on disk, ready) ‚úì
  - Decision: Swap out 42, swap in 43

T=200ms: Context switch completes
  - Process 42: State 3 (on disk)
  - Process 43: State 1 (in memory)
  - Current proc = 43
  - Quantum reset to -30

T=700ms: Process 43 blocks on I/O
  - Calls read(), disk starts
  - Process 43: State 2 (blocked)
  - lookfor() searches:
    - Check proc 1: State 2 (blocked) ‚úó
    - Check proc 42: State 3 (on disk, ready) ‚úì
  - Decision: Swap in 42

T=800ms: Context switch completes
  - Process 43: State 2 (in memory, blocked)
  - Process 42: State 1 (in memory, ready)
  - Current proc = 42

T=850ms: Disk interrupt
  - I/O for process 43 completes
  - Process 43: State 1 (ready, but in memory!)
  - Now TWO processes ready (42 and 43)
  - But only one can be in memory!
  - Current process 42 continues

T=1300ms: Quantum expires for process 42
  - lookfor() searches:
    - Check proc 43: State 1 (in memory, ready) ‚úì
  - Decision: No swap needed!
  - Both in memory, just switch context
  - Current proc = 43

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Note: In real PDP-7 Unix, two processes can't both be in
memory. One must be swapped. The example above shows a
simplified view. In reality:
  - When proc 43's I/O completes, it stays State 2
  - State only becomes 1 when scheduled
  - Only one process is ever State 1 at a time</code></pre>
<h2 data-number="7.9" id="inter-process-communication"><span class="header-section-number">7.9</span> 8.9 Inter-Process
Communication</h2>
<p>PDP-7 Unix provides a simple message-passing system for inter-process
communication. Processes can send and receive short messages identified
by the sender‚Äôs and recipient‚Äôs PIDs.</p>
<h3 data-number="7.9.1" id="smes---send-message"><span class="header-section-number">7.9.1</span> smes - Send Message</h3>
<pre class="assembly"><code>" smes - Send message
" Input:  AC = recipient PID
"         mesgdata = message value
" Returns: AC = 0 on success, -1 if queue full

.smes:
    dac rpid        " Save recipient PID

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 1: FIND FREE MESSAGE SLOT
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    law mesqueue    " Message queue array
    dac 8
    law nmesgs      " Maximum messages
    dac count

findmsg:
    lac 8 i         " Get message slot
    sza             " Skip if empty (0)
    jmp trynext

    " Found free slot
    jmp gotslot

trynext:
    isz 8           " Skip to next slot
    isz 8           " (each message is 2 words)
    isz count
    jmp findmsg

    " No free slots
    lac dm1         " Return -1 (error)
    jmp sysexit

gotslot:
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 2: STORE MESSAGE
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac rpid        " Recipient PID
    dac 8 i         " mesqueue[slot,0] = recipient

    lac mesgdata    " Message value
    dac 8 i         " mesqueue[slot,1] = data

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 3: WAKE UP RECIPIENT IF BLOCKED
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac rpid        " Which process to wake?
    jms wakeup      " Change state 2 ‚Üí 1

    dza             " Return 0 (success)
    jmp sysexit</code></pre>
<h3 data-number="7.9.2" id="rmes---receive-message-blocking"><span class="header-section-number">7.9.2</span> rmes - Receive Message
(Blocking)</h3>
<pre class="assembly"><code>" rmes - Receive message
" Blocks until message arrives for current process
" Returns: AC = message value
"          rmespid = sender PID

.rmes:
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 1: SEARCH FOR MESSAGE TO US
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
checkagain:
    law mesqueue    " Start of message queue
    dac 8
    law nmesgs      " Message count
    dac count

searchmsg:
    lac 8 i         " Get recipient PID from message
    sza             " Skip if empty slot
    jmp checkmsg

    " Empty slot, try next
    jmp nextmsg

checkmsg:
    lac 8 i         " Get recipient (already loaded)
    sad upid        " Message for us?
    jmp gotmsg      " Yes!

nextmsg:
    isz 8           " Skip to next message
    isz 8
    isz count
    jmp searchmsg

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 2: NO MESSAGE FOUND - BLOCK
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac d2          " State 2 = blocked
    dac procstate   " Update our state

    jms schedule    " Give up CPU
    " When we wake up, a message has arrived
    jmp checkagain  " Search again

gotmsg:
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " STEP 3: EXTRACT MESSAGE AND CLEAR SLOT
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac 8           " Pointer to message
    tad dm1         " Back up to recipient field
    dac 8
    lac 8 i         " Get recipient (for verification)
    lac 8 i         " Get message data
    dac mesgdata    " Save message value

    " Clear message slot
    lac 8
    tad dm1
    dac 8
    dza
    dac 8 i         " mesqueue[slot,0] = 0 (free)
    dac 8 i         " mesqueue[slot,1] = 0

    " Return message value
    lac mesgdata
    jmp sysexit</code></pre>
<h3 data-number="7.9.3" id="message-queue-structure"><span class="header-section-number">7.9.3</span> Message Queue Structure</h3>
<p>The message queue is a simple array in <code>s8.s</code>:</p>
<pre class="assembly"><code>" Message queue - 10 messages maximum
nmesgs = 10

mesqueue: .=.+nmesgs*2    " 10 messages √ó 2 words = 20 words

" Each message:
"   Word 0: Recipient PID (0 = free slot)
"   Word 1: Message data</code></pre>
<p><strong>Example message queue:</strong></p>
<pre><code>Address  Slot  Word  Value   Meaning
-------  ----  ----  ------  ---------------------------
mesqueue  0     0    000042  Message for PID 42
mesqueue  0     1    000123  Data = 123

mesqueue  1     0    000001  Message for PID 1 (init)
mesqueue  1     1    000043  Data = 43 (child exited)

mesqueue  2     0    000000  Free slot
mesqueue  2     1    000000

mesqueue  3     0    000042  Another message for PID 42
mesqueue  3     1    000077  Data = 77

...</code></pre>
<h3 data-number="7.9.4" id="use-in-init"><span class="header-section-number">7.9.4</span> Use in init</h3>
<p>The <code>init</code> process uses messages to detect child
termination:</p>
<pre class="assembly"><code>" In init.s - Login process
init:
    " Fork shell for user
    sys fork
    sza
    jmp parent

child:
    " Execute shell
    sys exec; shell
    sys exit        " If exec fails

parent:
    " Parent waits for child to exit
    dac childpid    " Save child PID

waitloop:
    sys rmes        " Receive message (blocks)

    " AC now contains message
    " For exit, message = child PID
    sad childpid    " Is it our child?
    jmp childdone   " Yes!

    " Message from someone else, ignore
    jmp waitloop

childdone:
    " Child has exited, spawn new login
    jmp init        " Start over</code></pre>
<p><strong>Message flow:</strong> 1. Init forks shell (PID 42) 2. Init
blocks in <code>rmes</code> 3. User types ‚Äúexit‚Äù in shell 4. Shell calls
<code>sys exit</code> 5. Exit sends message: recipient=1 (init), data=42
(shell PID) 6. Init wakes up with AC=42 7. Init detects child
termination 8. Init spawns new login</p>
<h3 data-number="7.9.5" id="full-ipc-implementation"><span class="header-section-number">7.9.5</span> Full IPC Implementation</h3>
<p>Let‚Äôs examine the complete message-passing mechanism:</p>
<pre class="assembly"><code>" ============================================================
" smes - Send message to another process
" ============================================================
.smes:
    " User setup:
    "   sys smes; pid
    "   Message data in AC

    " Get recipient PID from user instruction
    lac urq         " Return address
    dac 8
    lac 8 i         " Get argument (recipient PID)
    dac rpid

    " Get message data from AC
    lac uac         " User's AC
    dac mesgdata

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Find free message slot
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    law mesqueue-2  " Start before first entry
    dac 8
    law nmesgs      " Counter = 10
    dac count

sloop:
    isz 8           " Advance to next message
    isz 8           " (2 words per message)
    lac 8 i         " Get recipient field
    sza             " Skip if 0 (free)
    jmp snext       " In use, try next

    " Found free slot
    jmp sfound

snext:
    isz 8           " Skip data field
    isz count
    jmp sloop

    " Queue full
    lac dm1         " Error return
    jmp sysexit

sfound:
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Store message
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac 8           " Pointer to slot
    tad dm1         " Back to recipient field
    dac 8
    lac rpid        " Recipient PID
    dac 8 i         " Store
    lac mesgdata    " Message data
    dac 8 i         " Store

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Wake recipient if blocked
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac rpid
    jms findproc    " Find in process table
    sza             " Skip if not found
    jmp checkstate

    " Process not found
    jmp sdone

checkstate:
    dac pnum        " Save process number
    alss 2          " √ó 4
    tad ulist
    dac 8
    lac 8 i         " Get state
    and d3
    sad d2          " State 2 (blocked)?
    jmp wakeproc    " Yes, wake it

    " Not blocked, message will wait
    jmp sdone

wakeproc:
    lac d1          " State 1 = ready
    dac 8 i         " Update process state

sdone:
    dza             " Success
    jmp sysexit

" ============================================================
" rmes - Receive message (blocking)
" ============================================================
.rmes:
    " No user arguments needed
    " Returns message data in AC

rcvloop:
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Search message queue for message to us
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    law mesqueue-2
    dac 8
    law nmesgs
    dac count

rloop:
    isz 8
    isz 8
    lac 8 i         " Get recipient PID
    sza             " Skip if empty
    jmp rcheck      " Check if for us

    " Empty slot
    jmp rnext

rcheck:
    lac 8 i         " Get recipient again
    sad upid        " For us?
    jmp rfound      " Yes!

rnext:
    isz 8           " Skip data field
    isz count
    jmp rloop

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " No message found - block
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac proc        " Our process number
    alss 2
    tad ulist
    dac 8
    lac d2          " State 2 = blocked
    dac 8 i         " Update our state

    jms schedule    " Give up CPU
    " When awakened, try again
    jmp rcvloop

rfound:
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Extract message and free slot
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac 8           " Pointer to data field
    tad dm1         " Back to recipient field
    dac 8
    lac 8 i         " Skip recipient
    lac 8 i         " Get data
    dac mesgdata    " Save

    " Free the slot
    lac 8
    tad dm2         " Back to start
    dac 8
    dza
    dac 8 i         " Clear recipient
    dac 8 i         " Clear data

    " Return message data
    lac mesgdata
    jmp sysexit</code></pre>
<h3 data-number="7.9.6" id="message-passing-execution-trace"><span class="header-section-number">7.9.6</span> Message-Passing Execution
Trace</h3>
<p>Let‚Äôs trace a complete message exchange:</p>
<pre><code>Initial State:
  Process 1 (init): State 2 (blocked in rmes)
  Process 42 (shell): State 1 (running)
  Message queue: all empty

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

T=0ms: Shell decides to exit
  - User typed "exit"
  - Shell prepares to call exit()

T=1ms: Shell calls exit()
  - Enter .exit system call
  - Close all files (3ms)

T=4ms: Exit sends message to parent
  - rpid = uppid = 1 (init)
  - mesgdata = upid = 42 (shell PID)
  - Call smes

T=5ms: smes searches for free message slot
  - mesqueue[0,0] = 0 (free!)
  - Found slot 0

T=6ms: smes stores message
  - mesqueue[0,0] = 1 (recipient = init)
  - mesqueue[0,1] = 42 (data = shell PID)

T=7ms: smes wakes init
  - Find process 1 in table
  - State = 2 (blocked)
  - Change to state 1 (ready)

T=8ms: Exit continues
  - Free process table entry
  - Process 42 no longer exists

T=9ms: Schedule another process
  - lookfor finds process 1 (init, state 1)
  - Swap init into memory

T=60ms: Init resumes in rmes
  - Was blocked at rloop
  - Jump to rcvloop to search again

T=61ms: rmes searches message queue
  - mesqueue[0,0] = 1 (for init!) ‚úì
  - mesqueue[0,1] = 42
  - Found message!

T=62ms: rmes extracts message
  - mesgdata = 42
  - Clear mesqueue[0,0] = 0
  - Clear mesqueue[0,1] = 0

T=63ms: rmes returns
  - AC = 42 (child PID)
  - Init knows child 42 exited

T=64ms: Init spawns new login
  - jmp init (restart)
  - Fork new shell

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Final State:
  Process 1 (init): State 1 (running, spawning new shell)
  Process 42 (shell): Gone (exited)
  Message queue: empty again</code></pre>
<h2 data-number="7.10" id="context-switching"><span class="header-section-number">7.10</span> 8.10 Context Switching</h2>
<p>Context switching is the mechanism that saves one process‚Äôs state and
restores another‚Äôs. In PDP-7 Unix, this happens during system calls and
interrupts.</p>
<h3 data-number="7.10.1" id="saverestore-mechanism"><span class="header-section-number">7.10.1</span> Save/Restore Mechanism</h3>
<p><strong>Save context</strong> (on system call entry):</p>
<pre class="assembly"><code>" System call trap entry (location 020)
020:
    dac uac         " Save AC
    law 020         " Return address
    dac urq         " Save return point
    lac 017         " Get MQ register
    dac umq         " Save MQ

    " Other registers saved elsewhere:
    " - PC saved by hardware in rq
    " - Link saved implicitly

    " Kernel can now freely modify AC, MQ</code></pre>
<p><strong>Restore context</strong> (on system call exit):</p>
<pre class="assembly"><code>sysexit:
    " Restore all user registers
    lac umq         " Get saved MQ
    dac 017         " Restore to MQ register

    lac urq         " Get saved return address
    dac 8           " Set up indirect jump

    lac uac         " Restore AC (contains return value)

    jmp 8 i         " Return to user mode
    " PC restored implicitly by jmp</code></pre>
<h3 data-number="7.10.2" id="register-preservation"><span class="header-section-number">7.10.2</span> Register Preservation</h3>
<p>The PDP-7 has very few registers: - <strong>AC</strong>
(accumulator): Must be saved/restored - <strong>MQ</strong>
(multiplier-quotient): Must be saved/restored - <strong>PC</strong>
(program counter): Saved implicitly by trap hardware -
<strong>Link</strong> (carry bit): Usually doesn‚Äôt need explicit
save</p>
<p><strong>Why so few?</strong> The PDP-7 architecture is extremely
simple. Most ‚Äúregisters‚Äù are actually memory locations: - Auto-increment
pointers (locations 010-017) - Temporary variables (allocated in
memory)</p>
<h3 data-number="7.10.3" id="userkernel-mode-transition"><span class="header-section-number">7.10.3</span> User/Kernel Mode
Transition</h3>
<p><strong>User mode ‚Üí Kernel mode</strong> (system call):</p>
<pre><code>1. User executes: sys open; file

2. Hardware trap:
   - PC saved in hardware rq register
   - Jump to location 020

3. Kernel entry (020):
   - Save AC to uac
   - Save MQ to umq
   - Save rq to urq
   - Set .insys flag

4. Kernel runs:
   - Dispatch to .open
   - Execute system call
   - Modify AC (return value)

5. Kernel exit (sysexit):
   - Restore MQ from umq
   - Restore AC from uac
   - Clear .insys flag
   - Jump indirect through urq

6. Hardware return:
   - PC restored
   - User continues after 'sys' instruction</code></pre>
<p><strong>Interrupt</strong> (asynchronous):</p>
<pre><code>1. User running:
   - Executing normal code
   - E.g., lac x; tad y; dac z

2. Hardware interrupt:
   - PC saved in hardware rq
   - Jump to interrupt vector

3. Interrupt handler:
   - Save AC, MQ (if needed)
   - Process interrupt (disk, clock, TTY)
   - Restore AC, MQ
   - jmp rq i (return)

4. User resumes:
   - Continues as if nothing happened
   - (unless interrupt changed process state)</code></pre>
<h3 data-number="7.10.4" id="complete-code-analysis"><span class="header-section-number">7.10.4</span> Complete Code Analysis</h3>
<p>Here‚Äôs the full context switch path:</p>
<pre class="assembly"><code>" ============================================================
" SYSTEM CALL ENTRY - Save user context
" ============================================================
020:
    " Hardware trap brings us here
    " rq register contains return address (user PC)
    " AC contains whatever user left in it
    " MQ contains whatever user left in it

    dac uac         " Save AC to userdata+0

    law 020         " Our entry address
    dac urq         " Save as return point (userdata+2)

    lac 017         " Get MQ from memory location 017
    dac umq         " Save to userdata+1

    " Check for recursive system call
    lac s.insys     " Inside-system-call flag
    sna             " Skip if non-zero
    jmp .+3         " Not recursive, OK

    " Recursive call - panic!
    error

    " Set flag
    lac d1
    dac s.insys     " Mark as inside system call

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Get system call number from user instruction
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac urq         " Return address
    dac 8
    lac 8 i         " Get instruction (system call #)
    dac syscall     " Save it

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Dispatch to handler
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac syscall
    sad maxsys      " Beyond max?
    error           " Invalid system call

    " Jump to handler via swp table
    lac syscall
    tad swp         " Add to dispatch table base
    dac 8
    jmp 8 i         " Indirect jump to handler

" ============================================================
" SYSTEM CALL EXIT - Restore user context
" ============================================================
sysexit:
    " Called by all system call handlers when done
    " AC contains return value for user

    dac uac         " Save return value

    " Clear inside-system-call flag
    dza
    dac s.insys

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Check if swapping needed
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    jms swap        " Swap scheduler
    " May swap out current process and swap in another
    " If swapped, this returns in new process context!

    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    " Restore user registers
    "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    lac umq         " Get saved MQ
    dac 017         " Restore to MQ memory location

    lac urq         " Get return address
    dac 8           " Set up for indirect jump

    lac uac         " Get return value (last thing!)

    " Return to user mode
    jmp 8 i         " Jump indirect through return address

    " Now back in user mode!
    " PC is restored by jmp
    " AC contains return value
    " MQ is restored
    " All other state unchanged

" ============================================================
" CLOCK INTERRUPT - Minimal context save
" ============================================================
clkint:
    " Hardware saved PC in rq
    " We must save/restore AC if we modify it

    dac tempa       " Save AC

    " Update quantum
    isz s.quantum   " Increment (stored negative)
    jmp clkmore     " Not expired

    " Quantum expired
    lac d1
    dac s.needswap  " Set flag for next system call

clkmore:
    " Update time-of-day clock
    isz s.time

    " Restore AC
    lac tempa

    " Return from interrupt
    jmp rq i        " Jump indirect through rq (PC restore)

" ============================================================
" PROCESS SWITCH - Complete context exchange
" ============================================================
switch:
    " Switch from current process to another
    " This is called by swap scheduler

    " Current process is already saved to disk
    " (userdata written to swap track)

    " Load new process from disk
    lac newproc     " Process number to load
    jms dskswapin   " Read from swap track

    " Now userdata contains new process's context
    " Update current process pointer
    lac newproc
    dac proc

    " Reset quantum
    law quantum
    dac s.quantum

    " Restore new process's registers
    lac umq
    dac 017         " Restore MQ

    lac urq
    dac 8           " Set up return address

    lac uac         " Restore AC (last!)

    " Jump to new process
    jmp 8 i

    " We're now running in the new process!
    " Its PC, AC, MQ, all state restored</code></pre>
<h3 data-number="7.10.5" id="context-switch-timeline"><span class="header-section-number">7.10.5</span> Context Switch Timeline</h3>
<p>Let‚Äôs trace a complete context switch with exact register values:</p>
<pre><code>Initial State (Process 42, shell):
  AC = 001234
  MQ = 005677
  PC = 003456 (about to execute 'sys fork')
  rq = (undefined)

Memory (userdata):
  uac = (stale)
  umq = (stale)
  urq = (stale)

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

T=0: Process 42 executes 'sys fork' at PC=003456

T=1: Hardware trap
  - Save PC to rq: rq = 003457 (next instruction)
  - Jump to 020

T=2: Save context (location 020)
  - uac = AC = 001234
  - urq = 020
  - umq = MQ = 005677
  - s.insys = 1

T=3: Dispatch to .fork
  - Execute fork logic
  - Create child process
  - Modify uac = 43 (child PID)

T=50: Fork swaps child to disk
  - Child process now on track 07000

T=51: Fork returns
  - jmp sysexit

T=52: sysexit
  - s.insys = 0
  - Call swap()

T=53: Swap decides to switch processes
  - Current quantum expired
  - Find process 43 (child, ready)
  - Swap out process 42

T=100: Swap process 42 to disk
  - Write memory 0-7777 to track 06000
  - Write userdata to track 06000
    - Saved uac = 43
    - Saved umq = 005677
    - Saved urq = 020

T=101: Update process 42 state
  - ulist[42,0] = 3 (on disk, ready)

T=102: Swap in process 43 from disk
  - Read track 07000 to memory 0-7777
  - Read userdata from track 07000
    - uac = 0 (child return value)
    - umq = 005677 (inherited from parent)
    - urq = 020 (same return point)

T=150: Resume process 43
  - proc = 43
  - Restore MQ = 005677
  - Restore AC = 0
  - jmp 020 (urq)

T=151: Process 43 running
  - PC = 003457 (after 'sys fork')
  - AC = 0 (child!)
  - MQ = 005677
  - Detects AC=0, runs child code

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Later: Process 43 quantum expires, swap back to 42

T=500: Swap process 43 out, process 42 in

T=550: Resume process 42
  - Read userdata from disk
  - uac = 43
  - umq = 005677
  - urq = 020
  - Restore AC = 43
  - jmp 020

T=551: Process 42 running
  - PC = 003457 (after 'sys fork')
  - AC = 43 (parent!)
  - MQ = 005677
  - Detects AC=43, runs parent code</code></pre>
<h2 data-number="7.11" id="the-complete-process-lifecycle"><span class="header-section-number">7.11</span> 8.11 The Complete Process
Lifecycle</h2>
<p>Let‚Äôs trace a process through its entire life from creation to
termination, showing exact memory and process table state at each
stage.</p>
<h3 data-number="7.11.1" id="stage-0-before-fork"><span class="header-section-number">7.11.1</span> Stage 0: Before fork</h3>
<pre><code>Process Table:
  ulist[0]: State=1, PID=1, Track=06000  (init, in memory)
  ulist[1]: State=0, PID=0, Track=0      (unused)
  ulist[2]: State=1, PID=42, Track=07000 (shell, in memory)
  ulist[3-9]: State=0 (all unused)

Memory (0-7777):
  0000-1777: Kernel code
  2000-3777: Shell code
  4000-7777: Shell data/stack

Current Process: 42 (shell)

userdata (shell):
  uac: 000000
  umq: 000000
  urq: 000000
  upid: 42
  uppid: 1
  uid: 12 (user "ken")
  ufil[3]: 14 (stdin/terminal)
  ufil[4]: 14 (stdout/terminal)
  ucdir: 41 (root directory)</code></pre>
<h3 data-number="7.11.2" id="stage-1-fork-called"><span class="header-section-number">7.11.2</span> Stage 1: Fork Called</h3>
<pre><code>T=0ms: Shell executes: sys fork

Process enters .fork system call
  - Save context to userdata
  - Find free process slot: ulist[1] available
  - Allocate PID: nproc 42 ‚Üí 43
  - Initialize ulist[1]:
    - State = 1
    - PID = 43
    - Track = 06000

Process Table:
  ulist[0]: State=1, PID=1, Track=06000  (init)
  ulist[1]: State=1, PID=43, Track=06000 (child, being created)
  ulist[2]: State=1, PID=42, Track=07000 (shell, parent)</code></pre>
<h3 data-number="7.11.3" id="stage-2-child-copied"><span class="header-section-number">7.11.3</span> Stage 2: Child Copied</h3>
<pre><code>T=1-3ms: Copy parent to child
  - Copy userdata ‚Üí childdata
  - Update childdata:
    - uac = 0
    - upid = 43
    - uppid = 42
  - Increment file reference counts

childdata (temporary buffer):
  uac: 0 (child return value)
  umq: 000000
  urq: 020 (same return point)
  upid: 43 (child PID)
  uppid: 42 (parent PID)
  uid: 12 (inherited)
  ufil[3]: 14 (shared stdin)
  ufil[4]: 14 (shared stdout)
  ucdir: 41 (inherited cwd)

File Table:
  Entry 14: refcount 1 ‚Üí 2 (both processes share it)</code></pre>
<h3 data-number="7.11.4" id="stage-3-child-swapped-out"><span class="header-section-number">7.11.4</span> Stage 3: Child Swapped
Out</h3>
<pre><code>T=50ms: Swap child to disk
  - Write memory to track 06000
  - Write childdata to track 06000
  - Update state to 3

Process Table:
  ulist[0]: State=1, PID=1, Track=06000  (init)
  ulist[1]: State=3, PID=43, Track=06000 (child, on disk, ready)
  ulist[2]: State=1, PID=42, Track=07000 (shell, in memory)

Disk Track 06000:
  Sectors 0-7: Shell memory image (8K)
  Sector 8: childdata (64 words)</code></pre>
<h3 data-number="7.11.5" id="stage-4-parent-returns"><span class="header-section-number">7.11.5</span> Stage 4: Parent Returns</h3>
<pre><code>T=52ms: Fork returns to parent
  - uac = 43 (child PID)
  - sysexit restores context
  - Parent continues execution

Memory (shell process):
  PC = 003457 (after 'sys fork')
  AC = 43
  Shell code detects AC != 0, runs parent path</code></pre>
<h3 data-number="7.11.6" id="stage-5-parent-waits"><span class="header-section-number">7.11.6</span> Stage 5: Parent Waits</h3>
<pre><code>T=100ms: Parent calls wait
  - sys wait
  - Enter .wait system call
  - Search for exited child (state 0)
  - None found
  - Block: ulist[2,0] = 2
  - Schedule another process

Process Table:
  ulist[0]: State=1, PID=1, Track=06000  (init)
  ulist[1]: State=3, PID=43, Track=06000 (child, ready)
  ulist[2]: State=2, PID=42, Track=07000 (shell, blocked)</code></pre>
<h3 data-number="7.11.7" id="stage-6-child-scheduled"><span class="header-section-number">7.11.7</span> Stage 6: Child
Scheduled</h3>
<pre><code>T=101ms: Scheduler picks child
  - lookfor finds process 43 (state 3)
  - Swap parent to disk (track 07000)
  - Swap child in (from track 06000)

T=150ms: Child begins execution
  - Memory loaded from track 06000
  - userdata restored
  - AC = 0
  - PC = 003457 (same as parent!)
  - Child code detects AC == 0, runs child path

Process Table:
  ulist[0]: State=1, PID=1, Track=06000  (init)
  ulist[1]: State=1, PID=43, Track=06000 (child, running)
  ulist[2]: State=3, PID=42, Track=07000 (shell, on disk)

Memory (child process):
  0000-1777: Kernel code (same)
  2000-3777: Shell code (same as parent)
  4000-7777: Shell data (copy from parent)

userdata (child):
  uac: 0
  upid: 43
  uppid: 42
  ufil[3]: 14 (shares file with parent)</code></pre>
<h3 data-number="7.11.8" id="stage-7-child-executes"><span class="header-section-number">7.11.8</span> Stage 7: Child Executes</h3>
<pre><code>T=151ms: Child runs
  - Executes its code
  - Maybe opens more files
  - Does computation
  - Time quantum expires

T=650ms: Child quantum expires
  - Swap out child (track 06000)
  - Swap in another process (maybe parent)

Process switches back and forth...</code></pre>
<h3 data-number="7.11.9" id="stage-8-child-exits"><span class="header-section-number">7.11.9</span> Stage 8: Child Exits</h3>
<pre><code>T=5000ms: Child calls exit
  - sys exit
  - Enter .exit system call

T=5001ms: Close files
  - ufil[3] = 14, refcount 2 ‚Üí 1 (parent still has it)
  - Don't actually close file

T=5002ms: Send exit message
  - Message to PID 42 (parent)
  - Data = 43 (child PID)
  - Enqueue in message queue

Message Queue:
  mesqueue[0,0]: 42 (recipient = parent)
  mesqueue[0,1]: 43 (data = child PID)

T=5003ms: Wake parent
  - Find process 42 in table
  - State 2 ‚Üí 1 (unblock)

T=5004ms: Free process slot
  - ulist[1,0] = 0
  - ulist[1,1] = 0
  - ulist[1,2] = 0

Process Table:
  ulist[0]: State=1, PID=1, Track=06000  (init)
  ulist[1]: State=0, PID=0, Track=0      (freed!)
  ulist[2]: State=1, PID=42, Track=07000 (shell, ready)

T=5005ms: Schedule another process
  - lookfor finds process 42
  - Never return to child (gone!)</code></pre>
<h3 data-number="7.11.10" id="stage-9-parent-wakes"><span class="header-section-number">7.11.10</span> Stage 9: Parent Wakes</h3>
<pre><code>T=5050ms: Parent swapped in
  - Was blocked in wait()
  - Message available
  - Receive message: AC = 43

T=5051ms: Wait returns
  - Parent's AC = 43 (child PID)
  - Parent knows child exited

Parent code:
  sys wait
  " Returns here with AC = 43
  " Child has exited</code></pre>
<h3 data-number="7.11.11" id="memory-diagrams-at-each-stage"><span class="header-section-number">7.11.11</span> Memory Diagrams at Each
Stage</h3>
<p><strong>Stage 1 (Before fork):</strong></p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Memory (8K)                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 0000-1777:  Kernel                 ‚îÇ
‚îÇ 2000-3777:  Shell Code             ‚îÇ
‚îÇ 4000-7777:  Shell Data             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Disk Track 06000: Empty
Disk Track 07000: Empty</code></pre>
<p><strong>Stage 3 (Child swapped out):</strong></p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Memory (8K)                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 0000-1777:  Kernel                 ‚îÇ
‚îÇ 2000-3777:  Shell Code (parent)    ‚îÇ
‚îÇ 4000-7777:  Shell Data (parent)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Disk Track 06000 (child)        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Sector 0-7:  Memory image 0-7777   ‚îÇ
‚îÇ Sector 8:    userdata (64 words)   ‚îÇ
‚îÇ              - uac = 0              ‚îÇ
‚îÇ              - upid = 43            ‚îÇ
‚îÇ              - uppid = 42           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
<p><strong>Stage 6 (Child running):</strong></p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Memory (8K)                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 0000-1777:  Kernel                 ‚îÇ
‚îÇ 2000-3777:  Shell Code (child)     ‚îÇ
‚îÇ 4000-7777:  Shell Data (child)     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Disk Track 06000 (empty)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Disk Track 07000 (parent)       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Sector 0-7:  Memory image 0-7777   ‚îÇ
‚îÇ Sector 8:    userdata              ‚îÇ
‚îÇ              - uac = 43             ‚îÇ
‚îÇ              - upid = 42            ‚îÇ
‚îÇ              - uppid = 1            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
<p><strong>Stage 8 (Child exited):</strong></p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Memory (8K)                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 0000-1777:  Kernel                 ‚îÇ
‚îÇ 2000-3777:  (transitioning)        ‚îÇ
‚îÇ 4000-7777:  (transitioning)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Process 43: GONE (state 0)

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Disk Track 07000 (parent)       ‚îÇ
‚îÇ    Ready to swap back in           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</code></pre>
<h3 data-number="7.11.12" id="process-table-state-transitions"><span class="header-section-number">7.11.12</span> Process Table State
Transitions</h3>
<pre><code>Timeline of Process Table Changes:

T=0 (before fork):
  [0]: State=1 PID=1   (init)
  [1]: State=0 PID=0   (free)
  [2]: State=1 PID=42  (shell)

T=1 (fork allocates slot):
  [0]: State=1 PID=1
  [1]: State=1 PID=43  (child allocated)
  [2]: State=1 PID=42

T=50 (child swapped out):
  [0]: State=1 PID=1
  [1]: State=3 PID=43  (on disk)
  [2]: State=1 PID=42

T=100 (parent blocks in wait):
  [0]: State=1 PID=1
  [1]: State=3 PID=43
  [2]: State=2 PID=42  (blocked)

T=150 (child swapped in):
  [0]: State=1 PID=1
  [1]: State=1 PID=43  (running)
  [2]: State=3 PID=42  (swapped out)

T=5003 (child exits, parent wakes):
  [0]: State=1 PID=1
  [1]: State=0 PID=0   (freed)
  [2]: State=1 PID=42  (ready)

T=5050 (parent resumes):
  [0]: State=1 PID=1
  [1]: State=0 PID=0
  [2]: State=1 PID=42  (running)</code></pre>
<h2 data-number="7.12" id="historical-context-1"><span class="header-section-number">7.12</span> 8.12 Historical Context</h2>
<h3 data-number="7.12.1" id="multiprogramming-in-1969"><span class="header-section-number">7.12.1</span> Multiprogramming in
1969</h3>
<p>In 1969, the computing landscape was dominated by batch processing
and early time-sharing experiments:</p>
<p><strong>IBM System/360 (batch processing):</strong> - Jobs submitted
on punched cards - Queued and run sequentially - No interaction during
execution - Job Control Language (JCL) for setup - Memory partitions
(fixed or variable) - Typical job turnaround: hours to days</p>
<p><strong>CTSS (Compatible Time-Sharing System, MIT):</strong> - First
successful time-sharing system (1961) - Multiple users on IBM 7094 -
Processes called ‚Äújobs‚Äù - Two-level scheduler (core and drum) - Complex
resource accounting - Required expensive hardware modifications</p>
<p><strong>Multics (MIT/Bell Labs/GE):</strong> - Ambitious multi-user
system - Virtual memory with paging - Segmentation and protection rings
- Very complex (millions of lines of code) - Required special GE-645
hardware - Still experimental in 1969</p>
<h3 data-number="7.12.2" id="pdp-7-unix-process-management-compared"><span class="header-section-number">7.12.2</span> PDP-7 Unix Process
Management Compared</h3>
<p><strong>Simplicity vs.¬†Multics:</strong></p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Multics</th>
<th>PDP-7 Unix</th>
</tr>
</thead>
<tbody>
<tr>
<td>Process structure</td>
<td>Complex descriptor</td>
<td>4 words</td>
</tr>
<tr>
<td>User state</td>
<td>100+ words</td>
<td>64 words</td>
</tr>
<tr>
<td>Scheduling</td>
<td>Multi-level queues</td>
<td>Round-robin</td>
</tr>
<tr>
<td>Priorities</td>
<td>Yes (dynamic)</td>
<td>No</td>
</tr>
<tr>
<td>Memory management</td>
<td>Paging + segmentation</td>
<td>Swapping</td>
</tr>
<tr>
<td>Protection</td>
<td>Rings 0-7</td>
<td>None (single user)</td>
</tr>
<tr>
<td>Lines of code</td>
<td>~1000s</td>
<td>~200</td>
</tr>
</tbody>
</table>
<p><strong>Speed vs.¬†CTSS:</strong></p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>CTSS</th>
<th>PDP-7 Unix</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fork</td>
<td>~5 seconds</td>
<td>~100ms</td>
</tr>
<tr>
<td>Context switch</td>
<td>~500ms</td>
<td>~100ms</td>
</tr>
<tr>
<td>System call</td>
<td>~10ms</td>
<td>~1ms</td>
</tr>
</tbody>
</table>
<p><strong>Philosophy:</strong></p>
<ul>
<li><strong>Batch systems</strong>: Jobs are separate, sequential</li>
<li><strong>Time-sharing systems</strong>: Jobs share CPU with complex
scheduling</li>
<li><strong>Unix</strong>: Processes are cheap, create freely</li>
</ul>
<h3 data-number="7.12.3" id="how-unix-differed"><span class="header-section-number">7.12.3</span> How Unix Differed</h3>
<p><strong>Key innovations in PDP-7 Unix:</strong></p>
<ol type="1">
<li><strong>Lightweight processes</strong>
<ul>
<li>Minimal per-process overhead (4 words)</li>
<li>Fast creation (100ms fork vs.¬†5s in CTSS)</li>
<li>Made processes disposable</li>
</ul></li>
<li><strong>Uniform abstraction</strong>
<ul>
<li>Init, shell, and user programs all use same process model</li>
<li>No distinction between system and user processes</li>
<li>All processes created via fork</li>
</ul></li>
<li><strong>Simple round-robin</strong>
<ul>
<li>No priority calculations</li>
<li>No complex queues</li>
<li>Predictable, fair</li>
</ul></li>
<li><strong>Swapping, not paging</strong>
<ul>
<li>Entire process in/out</li>
<li>No page tables or TLB</li>
<li>Simple to implement</li>
</ul></li>
<li><strong>Parent/child relationships</strong>
<ul>
<li>Process tree structure</li>
<li>Exit messages to parent</li>
<li>Foundation for job control (later)</li>
</ul></li>
</ol>
<p><strong>What Unix sacrificed:</strong></p>
<ul>
<li>No memory protection (single user anyway)</li>
<li>No priorities (not needed for 1-2 users)</li>
<li>No sophisticated scheduling (round-robin enough)</li>
<li>Limited number of processes (10 max)</li>
</ul>
<p><strong>What Unix gained:</strong></p>
<ul>
<li>Simplicity (200 lines vs.¬†1000s)</li>
<li>Speed (100ms operations vs.¬†seconds)</li>
<li>Understandability (easy to read/modify)</li>
<li>Portability (no special hardware needed)</li>
</ul>
<h3 data-number="7.12.4" id="influence-on-modern-operating-systems"><span class="header-section-number">7.12.4</span> Influence on Modern
Operating Systems</h3>
<p>The PDP-7 Unix process model influenced <strong>every subsequent Unix
variant</strong>:</p>
<p><strong>PDP-11 Unix (1971-1973):</strong> - Kept basic process
structure - Added process groups - Introduced standard file descriptors
(0, 1, 2) - Added pipes (inter-process data flow)</p>
<p><strong>Unix v6 (1975):</strong> - Refined fork/exec separation -
Added nice (priority control) - Improved scheduler - Process states
expanded</p>
<p><strong>BSD Unix (1977-1995):</strong> - Added job control
(foreground/background) - Virtual memory (demand paging) - Sophisticated
scheduler (4.4BSD) - Process groups and sessions</p>
<p><strong>System V (1983-1997):</strong> - Shared memory IPC -
Semaphores and message queues (more sophisticated than PDP-7) -
Real-time scheduling classes - Lightweight processes (threads
precursor)</p>
<p><strong>Linux (1991-present):</strong> - Retains fork/exec model -
Completely Fair Scheduler (CFS) - Namespaces and cgroups (containers) -
But still: fork creates process, exit terminates it</p>
<p><strong>Modern influence:</strong> - <strong>fork/exec</strong>:
Still the Unix process creation model - <strong>PID</strong>: Still
identifies processes - <strong>Parent/child</strong>: Still tracked
(getppid()) - <strong>exit messages</strong>: Evolved into wait() family
- <strong>Round-robin</strong>: Foundation for fair schedulers</p>
<p><strong>What changed:</strong> - <strong>Virtual memory</strong>:
Replaces swapping (copy-on-write fork) - <strong>Threads</strong>:
Multiple execution contexts per process - <strong>Priorities</strong>:
Nice values, real-time classes - <strong>Namespaces</strong>: Process
isolation for containers - <strong>Cgroups</strong>: Resource limits and
accounting</p>
<p><strong>What stayed the same:</strong> - Fork creates process - Exit
terminates process - PIDs identify processes - Parent/child
relationships matter - System calls transition to kernel mode</p>
<h3 data-number="7.12.5" id="the-genius-of-simplicity"><span class="header-section-number">7.12.5</span> The Genius of
Simplicity</h3>
<p>In 1969, Dennis Ritchie and Ken Thompson made processes <strong>so
cheap</strong> that programs could create them freely. This wasn‚Äôt
possible on contemporary systems where process creation took seconds and
consumed significant resources.</p>
<p>This single design decision enabled: - <strong>Pipes</strong> (fork,
connect stdout to stdin, exec) - <strong>Job control</strong>
(background processes) - <strong>Shell programming</strong> (pipelines
of simple tools) - <strong>The Unix philosophy</strong> (small programs,
combined freely)</p>
<p>From a simple process table with 4 words per entry and a swap area on
two disk tracks came <strong>the foundation of modern
computing</strong>. Every web server, database, and application running
on Unix-like systems today inherits this design.</p>
<p>That‚Äôs the power of simplicity.</p>
<hr/>
<h2 data-number="7.13" id="summary-2"><span class="header-section-number">7.13</span> Summary</h2>
<p>This chapter explored the process management system in PDP-7
Unix:</p>
<ol type="1">
<li><strong>Process Abstraction</strong>: The revolutionary concept of
lightweight processes in 1969</li>
<li><strong>Process Table</strong>: Just 4 words per process, supporting
up to 10 processes</li>
<li><strong>User Data</strong>: 64 words of saved state (registers,
files, directory)</li>
<li><strong>Process States</strong>: 4 states encoded in 2 bits (unused,
ready, blocked, swapped)</li>
<li><strong>fork()</strong>: Complete implementation of process creation
with memory copying</li>
<li><strong>exit()</strong>: Process termination with cleanup and parent
notification</li>
<li><strong>Swapping</strong>: Memory multiplexing via disk tracks
(100ms per swap)</li>
<li><strong>Scheduling</strong>: Simple round-robin with 30-tick
quantum</li>
<li><strong>IPC</strong>: Message-passing for parent/child
communication</li>
<li><strong>Context Switching</strong>: Register save/restore
mechanism</li>
<li><strong>Complete Lifecycle</strong>: Full trace from fork to exit
with memory diagrams</li>
<li><strong>Historical Context</strong>: How PDP-7 Unix differed from
and influenced other systems</li>
</ol>
<p>The genius of PDP-7 Unix process management was its <strong>extreme
simplicity</strong>. With just 200 lines of code, it provided
multiprogramming on a tiny machine‚Äîand established patterns still used
in operating systems today, 55 years later.</p>
<hr/>
<p><strong>Next Chapter</strong>: <a href="09-device-drivers.md">Chapter
9 - Device Drivers and I/O</a></p>
<p><strong>Previous Chapter</strong>: <a href="07-filesystem.md">Chapter
7 - File System Implementation</a></p>
<h1 data-number="8" id="chapter-10---development-tools-building-a-self-hosting-system"><span class="header-section-number">8</span> Chapter 10 - Development Tools:
Building a Self-Hosting System</h1>
<h2 data-number="8.1" id="the-self-hosting-achievement"><span class="header-section-number">8.1</span> 10.1 The Self-Hosting
Achievement</h2>
<h3 data-number="8.1.1" id="what-self-hosting-means"><span class="header-section-number">8.1.1</span> What Self-Hosting Means</h3>
<p>Self-hosting is the ability of a software development system to build
and maintain itself. For PDP-7 Unix in 1969, this meant:</p>
<ul>
<li><strong>Writing the assembler in assembly language</strong> - The
assembler could assemble itself</li>
<li><strong>Using the editor to edit its own source code</strong> - The
editor was written using itself</li>
<li><strong>Debugging tools with their own tools</strong> - The debugger
could debug itself</li>
<li><strong>Complete development cycle on one machine</strong> - No
external tools or systems required</li>
</ul>
<p>This created a ‚Äúvirtuous cycle‚Äù where improvements to the tools made
it easier to improve the tools further.</p>
<h3 data-number="8.1.2" id="why-it-was-revolutionary-in-1969"><span class="header-section-number">8.1.2</span> Why It Was Revolutionary in
1969</h3>
<p>In 1969, self-hosting was extremely rare and represented a profound
achievement:</p>
<p><strong>Industry Standard Practice:</strong> - Most development
required <strong>cross-compilation</strong> on larger machines - IBM
mainframes used JCL (Job Control Language) with batch processing - Code
was written on coding sheets, keypunched onto cards, then submitted -
Turnaround time could be <strong>hours or days</strong> for a single
compile-debug cycle - Interactive development was virtually unknown
outside research labs</p>
<p><strong>The Typical 1969 Workflow:</strong> 1. Write code on paper
coding forms 2. Send forms to keypunch operators 3. Keypunch operators
create punched cards (often introducing errors) 4. Submit card deck to
computer operator 5. Wait hours or days for batch job to run 6. Receive
printout showing compilation errors 7. Repeat from step 1</p>
<p><strong>What Unix Offered:</strong> 1. Edit code interactively with
<code>ed</code> 2. Assemble immediately with <code>as</code> 3. Test and
debug with <code>db</code> 4. Entire cycle takes
<strong>minutes</strong>, not days 5. All done by the programmer, not
operators</p>
<h3 data-number="8.1.3" id="industry-context-other-systems-in-1969"><span class="header-section-number">8.1.3</span> Industry Context: Other
Systems in 1969</h3>
<p><strong>MULTICS (MIT/Bell Labs/GE):</strong> - Running on GE-645
mainframe ($7 million, room-sized) - Required team of operators - Had
interactive editing but on expensive hardware - Inspired Unix but was
too complex</p>
<p><strong>IBM OS/360 (1964):</strong> - Batch processing only -
Required JCL (Job Control Language) - Punched card input - No
interactive development</p>
<p><strong>DEC PDP-10 Time-Sharing Systems:</strong> - TOPS-10 emerging
around 1969 - Much larger machine than PDP-7 ($120,000 vs $72,000) -
Time-sharing among many users - Had text editors but system was
complex</p>
<p><strong>Xerox PARC Alto (not until 1973):</strong> - First true
personal workstation - Had editors, compilers, debuggers - Cost
approximately $40,000 per unit - Unix predated this by 4 years</p>
<p><strong>What Made Unix Different:</strong> - <strong>Small
machine</strong> - PDP-7 was considered obsolete even in 1969 -
<strong>Single user</strong> - Full machine dedicated to one programmer
- <strong>Complete toolkit</strong> - All tools present and working
together - <strong>Written in assembly</strong> - Yet still maintainable
and elegant - <strong>Self-hosting</strong> - The system built
itself</p>
<h3 data-number="8.1.4" id="the-virtuous-cycle-better-tools-enable-better-tools"><span class="header-section-number">8.1.4</span> The Virtuous Cycle: Better
Tools Enable Better Tools</h3>
<p>The self-hosting nature of Unix created a powerful feedback loop:</p>
<pre><code>Better Assembler
    ‚Üì
Easier to write complex code
    ‚Üì
Better Editor/Debugger
    ‚Üì
Easier to improve Assembler
    ‚Üì
(cycle repeats)</code></pre>
<p><strong>Specific Examples:</strong></p>
<ol type="1">
<li><p><strong>Symbol Table Improvements</strong> - As the assembler‚Äôs
symbol table got better, it could handle more complex programs, allowing
the editor to grow more features</p></li>
<li><p><strong>Editor Macros</strong> - Better editing commands made it
faster to modify assembly code, which meant faster iteration on all
tools</p></li>
<li><p><strong>Debugger Symbolic Output</strong> - Once the debugger
could display symbols, debugging the assembler and editor became much
easier</p></li>
<li><p><strong>Expression Evaluation</strong> - Shared code between
assembler and debugger meant improvements helped both</p></li>
</ol>
<p><strong>The Numbers Tell the Story:</strong></p>
<pre><code>Tool          Lines of Code    Approximate Size
----          -------------    ----------------
Assembler     ~980 lines       4K words memory
Editor        ~760 lines       3K words memory
Debugger      ~1,220 lines     5K words memory
Loader        ~250 lines       1K words memory
--------------------------------------------
Total         ~3,210 lines     ~13K words

Entire development environment: &lt; 26KB on modern scale!</code></pre>
<p>Compare this to modern development environments: - Visual Studio
Code: ~200MB - IntelliJ IDEA: ~800MB - Eclipse: ~500MB</p>
<p>Unix‚Äôs development tools were <strong>10,000 times smaller</strong>
yet provided the essential functionality for self-hosting
development.</p>
<hr/>
<h2 data-number="8.2" id="the-assembler-as.s"><span class="header-section-number">8.2</span> 10.2 The Assembler (as.s)</h2>
<p>The assembler (<code>as</code>) is the cornerstone of the development
environment. It translates assembly language source code into executable
machine code through a sophisticated two-pass algorithm.</p>
<h3 data-number="8.2.1" id="complete-two-pass-assembly-algorithm"><span class="header-section-number">8.2.1</span> Complete Two-Pass Assembly
Algorithm</h3>
<p><strong>Why Two Passes?</strong></p>
<p>The assembler must resolve <strong>forward references</strong> -
symbols used before they‚Äôre defined:</p>
<pre class="assembly"><code>   jmp subroutine    " Forward reference - 'subroutine' not yet defined
   lac value
   dac result

subroutine: 0        " Definition comes later
   lac input
   jmp i subroutine</code></pre>
<p><strong>Pass 1: Symbol Collection</strong> - Read through entire
source file - Build symbol table with addresses - Don‚Äôt generate code
yet - Record forward references</p>
<p><strong>Pass 2: Code Generation</strong> - Read source file again -
All symbols now known - Generate actual machine code - Write to output
file</p>
<h3 data-number="8.2.2" id="main-assembly-loop"><span class="header-section-number">8.2.2</span> Main Assembly Loop</h3>
<p>The core of the assembler is the main loop that processes each
line:</p>
<pre class="assembly"><code>assm1:
   lac eofflg
   sza                  " Skip if zero (not at EOF)
   jmp assm2            " At EOF, go to next phase
   lac passno
   sza                  " Skip if pass 0
   jmp finis            " Pass 1 complete, finish
   jms init2            " Initialize pass 2

assm2:
   jms gchar            " Get next character
   sad d4               " Is it tab (delimiter)?
   jmp assm1            " Yes, start new line
   sad d5               " Is it newline?
   jmp assm1            " Yes, start new line
   lac char
   dac savchr           " Save character
   jms gpair            " Get operator-operand pair
   lac rator            " Load operator
   jms betwen; d1; d6   " Is it in range 1-6 (expression)?
   jmp assm3            " No, check for label
   jms expr             " Yes, evaluate expression
   lac passno
   sza
   jms process          " Pass 2: generate code
   isz dot+1            " Increment location counter
   nop
   lac dot+1
   and o17777           " Mask to 14 bits
   sad dot+1            " Check overflow
   jmp assm1            " OK, continue
   jms error; &gt;&gt;        " Error: address overflow
   dzm dot+1            " Reset to 0
   jmp assm1</code></pre>
<p><strong>Key Variables:</strong> - <code>passno</code> - Current pass
(0 or 1) - <code>dot</code> - Current location counter (like
<code>.</code> in modern assemblers) - <code>eofflg</code> - End of file
flag - <code>rator</code> - Current operator being processed -
<code>char</code> - Current character being read</p>
<h3 data-number="8.2.3" id="symbol-table-implementation"><span class="header-section-number">8.2.3</span> Symbol Table
Implementation</h3>
<p>The symbol table is the heart of the assembler. It stores symbol
names and their values:</p>
<pre class="assembly"><code>lookup: 0
   dzm tlookup           " Clear temporary lookup flag
1:
   -1
   tad namlstp           " Get pointer to name list
   dac 8                 " Store in auto-index register 8
   lac namsiz            " Get current size of name table
   dac namc              " Use as counter

lu1:
   lac i 8               " Load word from name table
   sad name              " Does it match first word of symbol?
   jmp 1f                " Yes, check rest of symbol
   lac d5                " No, skip to next entry
lu2:
   tad 8
   dac 8                 " Advance pointer by 5 words
   isz namc              " Increment counter
   jmp lu1               " Continue searching</code></pre>
<p><strong>Symbol Table Entry Format</strong> (5 words per symbol):</p>
<pre><code>Word 0: First 2 characters (9 bits each)
Word 1: Second 2 characters
Word 2: Third 2 characters
Word 3: Fourth 2 characters
Word 4: Symbol value/address</code></pre>
<p><strong>Example:</strong> The symbol ‚Äúbuffer‚Äù would be stored as:</p>
<pre><code>Word 0: 'b' 'u'  (0142 0165)
Word 1: 'f' 'f'  (0146 0146)
Word 2: 'e' 'r'  (0145 0162)
Word 3: ' ' ' '  (0040 0040)  [padded with spaces]
Word 4: 001234   [address where buffer is defined]</code></pre>
<h3 data-number="8.2.4" id="character-packing-getsc-and-putsc"><span class="header-section-number">8.2.4</span> Character Packing: getsc and
putsc</h3>
<p>Efficient character storage was critical with limited memory. The
assembler packs two 9-bit characters per 18-bit word:</p>
<pre class="assembly"><code>getsc: 0
   lac i getsc           " Get pointer argument
   dac sctalp            " Save it
   isz getsc             " Advance return address
   lac i sctalp          " Load pointer value
   dac sctal             " Save actual pointer
   add o400000           " Set bit 0 (high bit)
   dac i sctalp          " Store back (marks as used)
   ral                   " Rotate accumulator left
   lac i sctal           " Load word containing characters
   szl                   " Skip if link is zero
   lrss 9                " Right shift 9 bits (get second char)
   and o177              " Mask to 7 bits
   jmp i getsc           " Return with character

putsc: 0
   and o177              " Mask character to 7 bits
   lmq                   " Load into MQ register
   lac i putsc           " Get pointer argument
   dac sctalp
   isz putsc
   lac i sctalp          " Load pointer value
   dac sctal
   add o400000           " Set high bit
   dac i sctalp
   sma cla               " Skip if minus (second char)
   jmp 1f                " First character
   llss 27               " Left shift 27 bits (move to high position)
   dac i sctal           " Store
   lrss 9                " Shift back
   jmp i putsc

1:                       " Second character
   lac i sctal           " Load existing word
   omq                   " OR with new character
   dac i sctal           " Store back
   lacq
   jmp i putsc</code></pre>
<p><strong>How It Works:</strong></p>
<p>Characters are stored two per word using bit 0 of the pointer as a
toggle: - Bit 0 = 0: Next character goes in high position (bits 1-9) -
Bit 0 = 1: Next character goes in low position (bits 10-18)</p>
<p>Example:</p>
<pre><code>Storing "ab":
Word initially:  000000 000000 000000
After 'a' (141): 000 141000 000000  [character in high position]
After 'b' (142): 000 141000 142000  [character in low position]</code></pre>
<h3 data-number="8.2.5" id="expression-evaluation-1"><span class="header-section-number">8.2.5</span> Expression Evaluation</h3>
<p>The assembler supports arithmetic expressions with operators:</p>
<pre class="assembly"><code>expr: 0
   jms grand             " Get rand (operand)
   -1
   dac srand             " Save on "stack"
exp5:
   lac rand
   dac r                 " Save result
   lac rand+1
   dac r+1
exp1:
   lac rator             " Load operator
   jms betwen; d1; d5    " Is it arithmetic operator?
   jmp exp3              " No, done with expression
   dac orator            " Save operator
   jms gpair             " Get next operator-operand pair
   jms grand             " Get next operand
   lac orator
   sad d4                " Is it comma (grouping)?
   jmp exp2              " Yes, handle specially
   jms oper; rand        " No, apply operator
   jmp exp1              " Continue

exp3:
   sad d5                " Is it newline (end)?
   jmp exp4              " Yes, finish
   jms error; x&gt;         " No, syntax error
   jmp skip

exp4:
   jms pickup            " Get result from stack
   jmp i expr</code></pre>
<p><strong>Supported Operators:</strong></p>
<ul>
<li><code>+</code> (plus) - Addition</li>
<li><code>-</code> (minus) - Subtraction</li>
<li><code>|</code> (vertical bar) - Bitwise OR</li>
<li><code>,</code> (comma) - Grouping/pairing</li>
</ul>
<p><strong>Example Expression:</strong></p>
<pre class="assembly"><code>   lac base+offset|0400000</code></pre>
<p>This evaluates as: 1. Load symbol <code>base</code> 2. Add symbol
<code>offset</code> 3. OR with octal constant 0400000</p>
<p>The expression evaluator handles operator precedence and can manage
complex expressions needed for PDP-7 addressing modes.</p>
<h3 data-number="8.2.6" id="forward-and-backward-references-1"><span class="header-section-number">8.2.6</span> Forward and Backward
References</h3>
<p>One of the assembler‚Äôs most sophisticated features is handling labels
used before they‚Äôre defined:</p>
<pre class="assembly"><code>assm3:
   lac rand
   sad d2                " Is operand type = 2 (label)?
   jmp assm4
   sza                   " Is it zero?
   jmp assm6             " No, error
   lac rator
   sza                   " Empty operator?
   jmp assm6
   lac rand+1            " Get operand value
   jms betwen; dm1; d10  " Is it 1-9 (forward/backward ref)?
   jmp assm6             " No
   dac name              " Yes, store as name
   tad fbxp              " Add forward/backward table pointer
   dac lvrand            " Use as index
   lac i lvrand          " Load current value
   dac name+1            " Store
   isz i lvrand          " Increment usage count
   lac o146              " 'f' character
   dac name+2            " Mark as forward ref
   dzm name+3
   jms tlookup           " Temporary lookup
   -1
   dac fbflg             " Set forward/backward flag</code></pre>
<p><strong>Forward/Backward Reference System:</strong></p>
<p>Labels can be defined as numeric (1-9) with ‚Äòf‚Äô or ‚Äòb‚Äô suffix:</p>
<pre class="assembly"><code>1:                    " Define label "1"
   lac value
   jmp 2f             " Jump forward to label "2"
   dac result
2:                    " Define label "2"
   sys exit

elsewhere:
   jmp 1b             " Jump backward to label "1"</code></pre>
<p>The assembler maintains a table <code>fbx</code> with 10 entries
(0-9), each tracking: - Current address of that numeric label - How many
times it‚Äôs been redefined</p>
<h3 data-number="8.2.7" id="object-file-format"><span class="header-section-number">8.2.7</span> Object File Format</h3>
<p>The assembler writes output to a temporary binary file in two
stages:</p>
<p><strong>Pass 1:</strong> No output (just building symbol table)</p>
<p><strong>Pass 2:</strong> Generate code into memory buffer:</p>
<pre class="assembly"><code>process: 0
   lac dot+1             " Load location counter
   dac lvrand            " Save as address
   lac dot               " Load section (text vs data)
   sad d3                " Is it section 3 (unused)?
   jmp proc4             " Yes, error
   sza                   " Is it section 0 (text)?
   jmp proc1             " No, section 1 or 2
   -1
   tad cmflx+1           " Yes, adjust for common block
   cma
   tad lvrand
   dac lvrand

proc1:
   lac lvrand
   spa                   " Is address positive?
   jmp proc4             " No, error
   and o17700            " Get page number (high 7 bits)
   sad bufadd            " Same page as buffer?
   jmp proc2             " Yes, just store
   jms bufwr             " No, write buffer and read new page
   jms copyz; buf; 64    " Clear buffer
   lac lvrand
   and o17700            " Get page number
   dac bufadd            " Remember which page
   dac 1f
   lac bfi               " Buffered file input
   sys seek; 1: 0; 0     " Seek to page
   spa
   jmp proc2
   lac bfi
   sys read; buf; 64     " Read existing page

proc2:
   lac lvrand
   and o77               " Get offset within page (low 6 bits)
   jms betwen; dm1; maxsto
   dac maxsto            " Track maximum offset
   tad bufp              " Add buffer pointer
   dac lvrand            " Now points to word in buffer
   lac r
   sna                   " Is value non-zero?
   jmp proc3             " Zero, special case
   sad d3                " Is it section 3?
   jmp proc5             " Yes, undefined symbol error
   lac cmflx+1
   tad r+1               " Add common block offset
   dac r+1

proc3:
   lac r+1               " Load value
   dac i lvrand          " Store at location
   jmp i process</code></pre>
<p><strong>Buffer Management:</strong> - 64-word pages cached in memory
- Modified pages written back to temp file - Seeks to different pages as
needed - Final file written at end of pass 2</p>
<h3 data-number="8.2.8" id="historical-context-why-write-an-assembler-in-assembly"><span class="header-section-number">8.2.8</span> Historical Context: Why Write
an Assembler in Assembly?</h3>
<p><strong>The Bootstrapping Problem:</strong></p>
<p>In 1969, to create a self-hosting system, you had to start somewhere.
The choices were:</p>
<ol type="1">
<li><strong>Write assembler in machine code</strong> (octal/binary) -
Extremely tedious</li>
<li><strong>Use existing assembler</strong> - PDP-7 had DEC‚Äôs assembler,
but:
<ul>
<li>DEC assembler was batch-oriented (paper tape input/output)</li>
<li>Designed for different workflow</li>
<li>Not integrated with Unix file system</li>
<li>Not customizable</li>
</ul></li>
<li><strong>Write in higher-level language</strong> - But no compiler
existed yet!</li>
</ol>
<p><strong>The Solution:</strong></p>
<ol type="1">
<li>Use DEC‚Äôs assembler to assemble first version of Unix assembler</li>
<li>Unix assembler can then assemble itself</li>
<li>Now self-hosting - no longer need DEC tools</li>
</ol>
<p><strong>This was revolutionary because:</strong> - Most systems kept
requiring manufacturer‚Äôs tools forever - Unix tools were specifically
designed to work together - Self-hosting enabled rapid iteration and
improvement</p>
<h3 data-number="8.2.9" id="comparison-to-other-1969-assemblers"><span class="header-section-number">8.2.9</span> Comparison to Other 1969
Assemblers</h3>
<p><strong>IBM System/360 Assembler:</strong> - Batch processing only -
JCL (Job Control Language) required - Input: punched cards - Output:
object deck on cards or tape - Typical assembly: 30 minutes to several
hours - Required operator intervention</p>
<p><strong>DEC PDP-7 PAL-7 Assembler:</strong> - Input: paper tape -
Output: paper tape - Single pass (no forward references except numeric
labels) - Limited expressions - No nested includes - Assembly time:
minutes for small programs</p>
<p><strong>Unix ‚Äòas‚Äô Assembler:</strong> - Input: disk files - Output:
disk files - Two pass (full forward reference support) - Rich expression
syntax - Symbol table written for debugger - Assembly time: seconds -
Integrated with shell and file system</p>
<p><strong>Code Size Comparison:</strong></p>
<pre><code>System/360 Assembler: ~50,000 lines (estimated¬µ)
DEC PAL-7:           ~5,000 lines (estimated)
Unix 'as':           ~980 lines

Unix assembler was ~5x smaller yet more capable in some ways!</code></pre>
<h3 data-number="8.2.10" id="complete-example-assembling-a-simple-program"><span class="header-section-number">8.2.10</span> Complete Example: Assembling
a Simple Program</h3>
<p><strong>Input Source (example.s):</strong></p>
<pre class="assembly"><code>" Simple program to add two numbers

start:
   lac num1        " Load first number
   tad num2        " Add second number
   dac result      " Store result
   sys exit        " Terminate

num1: 42           " First number (octal)
num2: 37           " Second number (octal)
result: 0          " Result storage</code></pre>
<p><strong>Pass 1 Processing:</strong></p>
<pre><code>Line 1: Comment - skip
Line 2: Empty - skip
Line 3: Label "start" defined, dot=0
        Instruction: lac num1
        Forward reference to "num1" recorded
Line 4: Instruction: tad num2
        Forward reference to "num2" recorded
Line 5: Instruction: dac result
        Forward reference to "result" recorded
Line 6: Instruction: sys exit
        "sys" is system call, "exit" is system call number
Line 7: Empty - skip
Line 8: Label "num1" defined, dot=4, value=42
Line 9: Label "num2" defined, dot=5, value=37
Line 10: Label "result" defined, dot=6, value=0

Symbol table after pass 1:
start  = 000000
num1   = 000004
num2   = 000005
result = 000006</code></pre>
<p><strong>Pass 2 Processing:</strong></p>
<pre><code>Address  Machine Code   Source
-------  ------------   ------
000000   066404         lac num1      (opcode 066, address 004)
000001   040405         tad num2      (opcode 040, address 005)
000002   026406         dac result    (opcode 026, address 006)
000003   020006         sys exit      (opcode 020, syscall 6)
000004   000042         num1: 42
000005   000037         num2: 37
000006   000000         result: 0</code></pre>
<p>The assembler has: 1. Resolved all forward references 2. Generated
correct machine code 3. Created symbol table for debugger 4. Written
output file ‚Äúa.out‚Äù</p>
<hr/>
<h2 data-number="8.3" id="the-editor-ed1.s-ed2.s"><span class="header-section-number">8.3</span> 10.3 The Editor (ed1.s +
ed2.s)</h2>
<p>The editor <code>ed</code> was the primary text editing tool in Unix.
It‚Äôs a <strong>line-oriented editor</strong>, meaning it operates on
whole lines rather than individual characters on screen.</p>
<h3 data-number="8.3.1" id="why-line-based-editing-in-1969"><span class="header-section-number">8.3.1</span> Why Line-Based Editing in
1969?</h3>
<p><strong>Technology Constraints:</strong></p>
<p>The PDP-7 Unix system used a <strong>Teletype Model 33 ASR</strong>:
- <strong>Printing terminal</strong> (like a typewriter) - <strong>No
screen</strong> - output is printed on paper - <strong>10 characters per
second</strong> (110 baud) - <strong>No cursor positioning</strong> -
you can‚Äôt move back up the page!</p>
<p><strong>Implications:</strong> - Screen-based editing was impossible
- the paper doesn‚Äôt scroll backward - Each command must complete before
next prompt - Minimize output - paper and ribbon cost money - Commands
must be terse - typing is slow</p>
<p><strong>Why Not Visual Editing?</strong></p>
<p>Visual editors like <code>vi</code> (1976) and <code>emacs</code>
(1976) required: - <strong>Video terminals</strong> with cursor
positioning (VT52, VT100) - <strong>Higher bandwidth</strong> (at least
1200 baud, preferably 9600) - <strong>Cursor control escape
sequences</strong> - <strong>More memory</strong> for screen buffer</p>
<p>None of these existed in 1969 for the PDP-7.</p>
<h3 data-number="8.3.2" id="command-set-and-implementation"><span class="header-section-number">8.3.2</span> Command Set and
Implementation</h3>
<p>The editor supports these commands:</p>
<pre><code>a  - Append text after current line
c  - Change (replace) lines
d  - Delete lines
p  - Print lines
q  - Quit
r  - Read file into buffer
w  - Write buffer to file
s  - Substitute (search and replace)
/  - Search forward
?  - Search backward
=  - Print current line number</code></pre>
<p><strong>Main Command Loop:</strong></p>
<pre class="assembly"><code>advanc:
   jms rline              " Read a command line
   lac linep
   dac tal                " Set up text pointer
   dzm adrflg             " Clear address flag
   jms addres             " Parse address (if any)
   jmp comand             " No address, go to command
   -1
   dac adrflg             " Mark address present
   lac addr
   dac addr1              " Store first address
   dac addr2              " Store second address (same initially)
1:
   lac char               " Check next character
   sad o54                " Is it comma?
   jmp 2f                 " Yes, address range
   sad o73                " Is it semicolon?
   skp
   jmp chkwrp             " No, done with address
   lac addr
   dac dot                " Semicolon updates current line
2:
   jms addres             " Parse second address
   jmp error              " Invalid address
   lac addr2
   dac addr1              " Shift addresses
   lac addr
   dac addr2              " Store new second address
   jmp 1b                 " Loop for more addresses

chkwrp:
   -1
   tad addr1
   jms betwen; d1; addr2  " Check addr1 &lt;= addr2
   jmp error              " Invalid range

comand:
   lac char               " Get command character
   sad o141               " 'a' - append?
   jmp ca
   sad o143               " 'c' - change?
   jmp cc
   sad o144               " 'd' - delete?
   jmp cd
   sad o160               " 'p' - print?
   jmp cp
   sad o161               " 'q' - quit?
   jmp cq
   sad o162               " 'r' - read?
   jmp cr
   sad o163               " 's' - substitute?
   jmp cs
   sad o167               " 'w' - write?
   jmp cw
   sad o12                " newline?
   jmp cnl                " Print next line
   sad o75                " '=' - line number?
   jmp ceq
   jmp error              " Unknown command</code></pre>
<h3 data-number="8.3.3" id="the-append-command-adding-text"><span class="header-section-number">8.3.3</span> The Append Command: Adding
Text</h3>
<p>The <code>a</code> command adds text after the current line:</p>
<pre class="assembly"><code>ca:
   jms newline            " Verify command line ends with newline
   jms setfl              " Set addr1=1, addr2=EOF if no address
   lac addr2
   dac dot                " Set current line
ca1:
   jms rline              " Read a line of input
   lac line
   sad o56012             " Is it ".\n" (period-newline)?
   jmp advanc             " Yes, done appending
   jms append             " No, append this line
   jmp ca1                " Read next line</code></pre>
<p><strong>How Append Works:</strong></p>
<ol type="1">
<li>User types <code>a</code> command</li>
<li>Editor enters ‚Äúappend mode‚Äù</li>
<li>Each line typed is added to buffer</li>
<li>User types <code>.</code> (period alone) to exit append mode</li>
<li>Returns to command mode</li>
</ol>
<p><strong>Example Session:</strong></p>
<pre><code>*a                        &lt;-- User types 'a' command
This is line 1            &lt;-- User types content
This is line 2
This is line 3
.                         &lt;-- User types '.' to end
*                         &lt;-- Back to command mode</code></pre>
<p><strong>The Append Implementation:</strong></p>
<pre class="assembly"><code>append: 0
   -1
   tad eofp               " Get EOF pointer
   dac 8                  " Use as destination pointer
   cma
   tad dot                " Calculate number of lines to move
   dac apt1               " Store as counter
1:
   lac i 8                " Load line pointer
   dac i 8                " Store one position later (shift down)
   -3
   tad 8                  " Move back one entry
   dac 8
   isz apt1               " Count down
   jmp 1b                 " Continue shifting
   isz eofp               " Increment EOF (one more line)
   dzm i eofp             " Mark new EOF
   isz dot                " Increment current line
   jms addline            " Add the new line content
   jmp i append</code></pre>
<p>This shifts all lines after <code>dot</code> down by one position to
make room for the new line.</p>
<h3 data-number="8.3.4" id="temporary-file-usage-the-disk-buffer"><span class="header-section-number">8.3.4</span> Temporary File Usage: The
Disk Buffer</h3>
<p>The editor doesn‚Äôt keep all file content in memory. Instead, it uses
a clever disk buffering scheme:</p>
<pre class="assembly"><code>" Editor data structure:
"
" lnodes (in memory):    Array of pointers to lines
"                        Each entry points to disk location
"
" dskbuf (in memory):    1024-word buffer for disk blocks
"
" /tmp/etmp (on disk):   Actual line content

" Line node structure (per line):
lnodes: .=.+1000         " 1000 line pointers (max)

" Each line pointer contains:
"   Disk block address + offset where line text starts</code></pre>
<p><strong>Reading a Line:</strong></p>
<pre class="assembly"><code>gline: 0
   dac glint1             " Save line number
   jms getdsk             " Ensure disk block is in buffer
   lac glint1
   and o1777              " Get offset within block
   tad dskbfp             " Add buffer pointer
   dac ital               " Input text pointer
   lac linep
   dac otal               " Output text pointer
1:
   lac ital
   sad edskbfp            " End of disk buffer?
   skp
   jmp 2f
   lac diskin             " Yes, get next disk block
   tad d1024
   jms getdsk
   lac dskbfp
   dac ital
2:
   jms getsc; ital        " Get character from disk buffer
   jms putsc; otal        " Put character to output line
   sad o12                " Newline?
   skp
   jmp 1b                 " No, continue
   lac otal
   sma                    " Did we write anything?
   jmp 1f
   cla
   jms putsc; otal        " Ensure word is complete
1:
   lac linpm1
   cma
   tad otal               " Calculate line size
   jmp i gline            " Return line size</code></pre>
<p><strong>Why This Design?</strong></p>
<ul>
<li><strong>Memory was tiny</strong> - Only ~8K words available for all
of ed</li>
<li><strong>Files could be large</strong> - Relative to memory</li>
<li><strong>Disk access was slow</strong> - Minimize reads/writes</li>
</ul>
<p>The solution: - Keep line <strong>pointers</strong> in memory (2
words per line = 2000 words for 1000 lines) - Keep line
<strong>content</strong> on disk in temporary file - Buffer frequently
accessed disk blocks</p>
<h3 data-number="8.3.5" id="search-and-substitution-algorithms"><span class="header-section-number">8.3.5</span> Search and Substitution
Algorithms</h3>
<p>The <code>s</code> (substitute) command is implemented in
<code>ed2.s</code>:</p>
<pre class="assembly"><code>cs:
   jms getsc; tal         " Get first character after 's'
   sad o40                " Space?
   jmp cs                 " Skip spaces
   sad o12                " Newline?
   jmp error              " Need delimiter
   dac delim              " Save delimiter character
   jms compile            " Compile search pattern
   lac tbufp
   dac tal1               " Set up for replacement text
1:
   jms getsc; tal         " Get replacement text
   sad delim              " Delimiter again?
   jmp 1f                 " Yes, done with replacement
   sad o12                " Newline?
   jmp error              " Can't have newline in replacement
   jms putsc; tal1        " Store replacement character
   jmp 1b
1:
   lac o12
   jms putsc; tal1        " Terminate replacement with newline
   jms newline            " Verify command ends properly
   jms setdd              " Set default addresses (current line)
   lac addr1
   sad zerop              " Line 0?
   jmp error              " Can't substitute in line 0
1:
   dac addr1              " Process this line
   lac i addr1            " Get line pointer
   jms execute            " Execute pattern match
   jmp 2f                 " No match

   " Match found - construct new line
   lac addr1
   dac dot                " Update current line
   law line-1
   dac 8                  " Source pointer
   law nlist-1
   dac 9                  " Destination pointer
   -64
   dac c1
3:
   lac i 8                " Copy line to working buffer
   dac i 9
   isz c1
   jmp 3b

   " Build new line with replacement
   -1
   tad fchrno             " First character of match
   dac linsiz             " Size so far
   rcr
   szl
   xor o400000
   tad linep
   dac tal1               " Pointer to copy up to match
   lac tbufp
   dac tal                " Pointer to replacement text
3:
   jms getsc; tal         " Get replacement character
   sad o12                " End?
   jmp 3f
   jms putsc; tal1        " Put to new line
   isz linsiz
   jmp 3b
3:
   -1
   tad lchrno             " Last character of match
   rcr
   szl
   xor o400000
   tad nlistp
   dac tal                " Pointer to rest of original line
3:
   jms getsc; tal         " Copy rest of line
   jms putsc; tal1
   isz linsiz
   sad o12                " Newline?
   skp
   jmp 3b
   jms addline            " Add modified line
2:
   lac addr1
   sad addr2              " Done with all lines?
   jmp advanc             " Yes
   tad d1
   jmp 1b                 " No, process next line</code></pre>
<p><strong>How Substitution Works:</strong></p>
<ol type="1">
<li>Parse command: <code>s/pattern/replacement/</code></li>
<li>Compile pattern into internal form</li>
<li>For each line in range:
<ul>
<li>Execute pattern match</li>
<li>If match found:
<ul>
<li>Copy line up to match</li>
<li>Insert replacement text</li>
<li>Copy rest of line after match</li>
<li>Add as new line</li>
</ul></li>
</ul></li>
<li>Return to command mode</li>
</ol>
<p><strong>Example:</strong></p>
<pre><code>*1,$s/Unix/UNIX/         " Substitute Unix with UNIX on all lines
*1,$s/the/THE/          " Substitute first 'the' with 'THE' on each line</code></pre>
<h3 data-number="8.3.6" id="pattern-compilation"><span class="header-section-number">8.3.6</span> Pattern Compilation</h3>
<p>The editor compiles search patterns into an internal bytecode:</p>
<pre class="assembly"><code>compile: 0
   law compbuf-1          " Compiled pattern buffer
   dac 8
   dzm prev               " No previous element
   dzm compflg            " Not compiling yet

cadvanc:
   jms getsc; tal         " Get next pattern character
   sad delim              " Delimiter?
   jmp cdone              " Yes, done
   dac compflg            " Mark we're compiling
   dzm lastre             " Clear last RE flag
   sad o12                " Newline?
   jmp error              " Can't have newline in pattern
   sad o136               " '^' (beginning of line)?
   jmp beglin
   sad o44                " '$' (end of line)?
   jmp endlin
   dac 1f                 " Regular character
   jmp comp               " Compile character match
   1; jms matchar; 1: 0; 0

beglin:
   jms comp               " Compile beginning-of-line match
   1; jms matbol; 0
   dzm prev
   jmp cadvanc

endlin:
   jms comp               " Compile end-of-line match
   1; jms mateol; 0
   dzm prev
   jmp cadvanc

comp: 0                   " Append instruction to compiled pattern
   -1
   tad comp
   dac 9
   lac 8
   dac prev               " Save as previous element
1:
   lac i 9                " Copy instruction words
   sna
   jmp i 9                " Zero terminates, return
   dac i 8                " Store in compiled buffer
   jmp 1b</code></pre>
<p><strong>Compiled Pattern Format:</strong></p>
<p>Each pattern element compiles to instructions like:</p>
<pre><code>jms matchar; 'c'; 0     " Match character 'c'
jms matbol; 0           " Match beginning of line
jms mateol; 0           " Match end of line
jms found; 0            " Pattern matched successfully</code></pre>
<p>This is essentially a tiny interpreter!</p>
<h3 data-number="8.3.7" id="historical-context-what-editors-existed-in-1969"><span class="header-section-number">8.3.7</span> Historical Context: What
Editors Existed in 1969?</h3>
<p><strong>TECO (Text Editor and COrrector)</strong> - 1962 - DEC PDP-1
and later systems - Command language with edit buffer - Very powerful
but cryptic - Used character-at-a-time commands - Richard Stallman later
wrote Emacs in TECO</p>
<p><strong>SOS (Son of Stopgap)</strong> - 1965 - DEC PDP-6 and PDP-10 -
Line-oriented editor - Used line numbers - Commands like ‚Äún:m PRINT‚Äù to
print lines n through m</p>
<p><strong>EDIT</strong> - IBM System/360 - Batch editor (edit control
cards in card deck) - Submit deck with source + edit commands - Get back
modified deck - Turnaround time: hours</p>
<p><strong>QED</strong> - 1965-1966 - Berkeley Timesharing System -
Strong influence on Unix <code>ed</code> - Regular expressions - Ken
Thompson knew QED well</p>
<p><strong>What Made Unix <code>ed</code> Different:</strong></p>
<ol type="1">
<li><strong>Integrated with Unix</strong> - Used file system, not paper
tape</li>
<li><strong>Regular expressions</strong> - Powerful pattern
matching</li>
<li><strong>Simple command set</strong> - Easy to learn basics</li>
<li><strong>Fast</strong> - Disk buffer made it responsive</li>
<li><strong>Self-editing</strong> - Ed was written and debugged using
ed</li>
</ol>
<p><strong>Ed‚Äôs Influence:</strong></p>
<pre><code>ed (1969)
   ‚Üì
ex (1976) - Extended ed with more features
   ‚Üì
vi (1976) - Visual mode of ex
   ‚Üì
vim (1991) - Vi IMproved
   ‚Üì
neovim (2014) - Modern fork of vim

ed also influenced:
- sed (Stream EDitor) - 1973
- awk (pattern scanning) - 1977
- grep (Get Regular ExPression) - 1973
- All regex libraries</code></pre>
<p>Modern programmers use ed descendants every day without knowing
it!</p>
<h3 data-number="8.3.8" id="the-ed-legacy-modern-tools-descended-from-ed"><span class="header-section-number">8.3.8</span> The Ed Legacy: Modern Tools
Descended from Ed</h3>
<p><strong>sed - Stream Editor</strong></p>
<div class="sourceCode" id="cb614"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb614-1"><a aria-hidden="true" href="#cb614-1" tabindex="-1"></a><span class="fu">sed</span> <span class="st">'s/Unix/UNIX/g'</span> file.txt</span></code></pre></div>
<p>This is exactly ed‚Äôs substitute command applied to a stream! The
syntax is identical.</p>
<p><strong>grep - Get Regular ExPression and Print</strong></p>
<div class="sourceCode" id="cb615"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb615-1"><a aria-hidden="true" href="#cb615-1" tabindex="-1"></a><span class="fu">grep</span> <span class="st">'pattern'</span> file.txt</span></code></pre></div>
<p>This automates ed‚Äôs search command: <code>g/pattern/p</code> -
<code>g</code> = global (all lines) - <code>/pattern/</code> = search
pattern - <code>p</code> = print</p>
<p>The name ‚Äúgrep‚Äù literally comes from this ed command!</p>
<p><strong>vi - Visual Editor</strong></p>
<p>Vi‚Äôs command mode is ed: - <code>:1,10d</code> - Delete lines 1-10
(ed syntax) - <code>:%s/foo/bar/g</code> - Substitute on all lines (ed
syntax) - <code>:w</code> - Write file (ed command) - <code>:q</code> -
Quit (ed command)</p>
<p><strong>Regular Expressions</strong></p>
<p>Ed‚Äôs pattern matching became the foundation for: - Perl regular
expressions - JavaScript RegExp - Python re module - Java Pattern class
- Every regex implementation</p>
<p>The syntax <code>^beginning.*middle.*end$</code> comes from ed!</p>
<hr/>
<h2 data-number="8.4" id="the-debugger-db.s"><span class="header-section-number">8.4</span> 10.4 The Debugger (db.s)</h2>
<p>The debugger <code>db</code> provides symbolic debugging and core
dump analysis - revolutionary capabilities for 1969.</p>
<h3 data-number="8.4.1" id="symbolic-debugging-concepts"><span class="header-section-number">8.4.1</span> Symbolic Debugging
Concepts</h3>
<p>Most debuggers in 1969 worked with octal or hexadecimal addresses and
raw machine code. Unix <code>db</code> could display:</p>
<ul>
<li><strong>Symbol names</strong> instead of addresses</li>
<li><strong>Assembly mnemonics</strong> instead of octal instruction
codes</li>
<li><strong>Symbol+offset</strong> for partially matched addresses</li>
<li><strong>Relative or absolute</strong> addresses</li>
</ul>
<p><strong>Example Debug Session:</strong></p>
<pre><code>$ db core a.out           # Debug core dump with symbol table
52                        # Shows '$' register (PC) value
address $                 # Show address symbolically
start</code></pre>
<p>Instead of seeing:</p>
<pre><code>000042 = 000042          # Octal everywhere</code></pre>
<p>You see:</p>
<pre><code>start = 000042           # Meaningful symbol name</code></pre>
<h3 data-number="8.4.2" id="core-dump-analysis"><span class="header-section-number">8.4.2</span> Core Dump Analysis</h3>
<p>When a program crashes, Unix writes a <code>core</code> file
containing: - All process memory - Register values - Program counter
(PC)</p>
<p>The debugger can analyze this:</p>
<pre class="assembly"><code>start:
   lac nlbufp
   cma
   tad o17777             " Calculate buffer size
   cll
   idiv; 6                " Divide by 6
   cll
   lacq
   mul; 6                 " Multiply back (round down)
   lacq
   dac namesize           " Save symbol table size

   sys open; nlnamep: nlname; 0
   dac symindex           " Open symbol table file (n.out)
   sma                    " Success?
   jmp 1f                 " Yes, read symbols
2:
   dzm nlcnt              " No symbol table
   lac nlbufp
   dac nlsize
   jmp 3f
1:
   sys read; nlbuff; namesize:0  " Read symbol table
   spa                    " Success?
   jmp 2b                 " No
   dac nlcnt              " Save number read
   tad nlbufp
   dac nlsize             " Calculate end of buffer
3:
   lac symindex
   sys close              " Close symbol table

   sys open
wcorep: corename; 1       " Open core file for writing (if needed)
   dac wcore
   sys open; rcorep: corename; 0  " Open core file for reading
   dac rcore
   spa                    " Success?
   jmp error              " No, error</code></pre>
<p><strong>Symbol Table Format (n.out file):</strong></p>
<pre><code>Each entry is 6 words:
Word 0-3: Symbol name (8 characters, packed)
Word 4:   Relocation flag (0=absolute, 1=relocatable)
Word 5:   Value (address)</code></pre>
<h3 data-number="8.4.3" id="memory-examination-modes"><span class="header-section-number">8.4.3</span> Memory Examination Modes</h3>
<p>The debugger supports multiple display modes:</p>
<pre class="assembly"><code>symbol:
   law prsym               " Symbol mode printer
   dac type
   jmp print

octal:
   law proct               " Octal mode printer
   dac type
   jmp print

ascii:
   law prasc               " ASCII mode printer
   dac type
   jmp print

decimal:
   law prdec               " Decimal mode printer
   dac type
   jmp print</code></pre>
<p><strong>Command Examples:</strong></p>
<pre><code>$ db core a.out
52
buffer/                    # Examine 'buffer' symbolically
buffer: jms getword
buffer+1/                  # Next location
getword+2
buffer,10?                 # Examine 10 locations in octal
000123 000456 000777 ...
buffer,10:                 # Examine in decimal
83 302 511 ...
buffer,10"                 # Examine as ASCII
abc...</code></pre>
<h3 data-number="8.4.4" id="expression-evaluation-2"><span class="header-section-number">8.4.4</span> Expression Evaluation</h3>
<p>The debugger has a sophisticated expression evaluator:</p>
<pre class="assembly"><code>getexp:0
   dzm errf               " Clear error flag
   lac o40
   dac rator              " Initial operator = space (none)
   dzm curval             " Clear current value
   dzm curreloc           " Clear relocation
   dzm reloc
   dzm value
   dzm opfound            " Clear operand found flag

xloop:
   jms rch                " Read character
   lmq                    " Save in MQ
   sad o44                " Is it comma (indirect)?
   skp
   jmp 1f
   jms getspec            " Yes, get special register
   jms oprand             " Process as operand
   jmp xloop
1:
   tad om60               " Subtract '0' (check if digit)
   spa                    " Positive (is digit)?
   jmp 1f                 " No
   tad om10               " Subtract 10 (check if &lt; 10)
   sma                    " Negative (is 0-9)?
   jmp 1f                 " No
   lacq                   " Yes, get character back
   jms getnum             " Parse number
   jms oprand             " Process as operand
   jmp xloop
1:
   lacq                   " Get character
   sad o56                " Is it '.' (current address)?
   jmp 1f                 " Yes
   tad om141              " Is it 'a'-'z'?
   spa
   jmp 2f                 " No
   tad om32               " Check range
   sma
   jmp 2f
1:
   lacq
   jms getsym             " Parse symbol
   jms oprand             " Process as operand
   jmp xloop
2:
   lacq                   " Check operators
   sad o74                " Is it '&lt;' (ASCII literal)?
   skp
   jmp 1f
   jms rch                " Get next character
   alss 9                 " Shift to high byte
   dac value              " Save as value
   dzm reloc              " Not relocatable
   jms oprand
   jmp xloop
1:
   sad o40                " Space?
   jmp xloop              " Skip it
   sad o55                " Minus?
   skp
   jmp 1f
2:
   lac o40
   sad rator              " Already have operator?
   skp
   jmp error              " Yes, error
   lacq
   dac rator              " Save as operator
   jmp xloop
1:
   sad o53                " Plus?
   jmp 2b
   lac curreloc           " Check relocation consistency
   sna
   jmp 1f
   sad d1
   skp
   dac errf               " Relocation error
1:
   lac o40
   sad rator              " No operator (end of expression)?
   jmp i getexp           " Yes, done
   dac errf               " Operator expected
   jmp i getexp</code></pre>
<p><strong>Supported Expression Syntax:</strong></p>
<pre><code>Symbols:        buffer, start, loop
Numbers:        42, 177, 1234
Operators:      +, -, |
Special:        ,a (AC), ,q (MQ), ,i (IC), ,0-,7 (auto-index)
ASCII:          &lt;c (character constant)
Current:        . (current address)
Indirect:       @addr or addr@ (follow pointer)</code></pre>
<p><strong>Examples:</strong></p>
<pre><code>start+10                   # Symbol plus offset
buffer|020000              # Symbol OR constant
,a                         # Accumulator register
,5                         # Auto-index register 5
.                          # Current location</code></pre>
<h3 data-number="8.4.5" id="complete-code-walkthrough-print-symbol"><span class="header-section-number">8.4.5</span> Complete Code Walkthrough:
Print Symbol</h3>
<p>One of the most complex functions is symbolic printing:</p>
<pre class="assembly"><code>prsym:0
   dac word                " Save word to print
   dzm relflg              " Clear relative flag
   dzm relocflg            " Clear relocation flag
   dzm nsearch             " No specific search yet
   and o760000             " Check high bits for instruction type
   sad o760000             " Is it 'law' (load address word)?
   jmp plaw
   sad o20000              " Is it system call?
   jmp pcal
   and o740000             " Check for EAE (Extended Arithmetic)
   sad o640000             " EAE Group 1?
   jmp peae
   sad o740000             " Operate instructions?
   jmp popr
   sad o700000             " IOT (Input/Output Transfer)?
   jmp piot
   sna                     " Zero (memory reference)?
   jmp poct                " Print as octal
   jms nlsearch            " Try to find symbol
   jmp poct                " Not found, print octal
   jms wrname              " Found, print symbol name
   lac o40
   jms wchar               " Print space
   lac word
   and o20000              " Check indirect bit
   sna
   jmp 1f
   lac o151040             " Print "i "
   jms wchar
   lac word
   xor o20000              " Clear indirect bit
   dac word
1:
symadr:
   lac d1
   dac relflg              " Mark as relative
   dac relocflg            " Mark as relocatable
   lac word
   and o17777              " Extract address field
   tad mrelocv             " Adjust by relocation value
   sma                     " Check if in relocatable range
   jmp 1f
   tad relocval
   dzm relocflg            " Not relocatable
1:
pradr:
   dac addr                " Save address
   jms nlsearch            " Look up address in symbol table
   jmp octala              " Not found, print octal
pr1:
   dzm relflg
   jms wrname              " Print symbol name
   lac value
   sad addr                " Exact match?
   jmp i prsym             " Yes, done
   cma
   tad d1
   tad addr                " Calculate offset
   sma                     " Is offset positive?
   jmp 1f                  " Yes
   cma                     " No, negate
   tad d1
   dac addr
   lac o55                 " Print '-'
   jms wchar
   jmp 2f
1:
   dac addr                " Save offset
   lac o53                 " Print '+'
   jms wchar
2:
   lac addr                " Print offset value
   jms octw; 1
   jmp i prsym</code></pre>
<p><strong>What This Does:</strong></p>
<p>Given a machine word like <code>026377</code>, it:</p>
<ol type="1">
<li>Checks instruction type (memory reference, operate, IOT, etc.)</li>
<li>If memory reference:
<ul>
<li>Extracts opcode (026 = <code>dac</code>)</li>
<li>Extracts address (377)</li>
<li>Looks up address in symbol table</li>
<li>Prints: <code>dac buffer+3</code> instead of
<code>026377</code></li>
</ul></li>
<li>If operate instruction:
<ul>
<li>Looks up entire instruction</li>
<li>Prints mnemonic: <code>cla</code> instead of
<code>740000</code></li>
</ul></li>
</ol>
<p><strong>Symbol Table Search:</strong></p>
<pre class="assembly"><code>nlsearch:0
   dac match               " Save value to match
   lac brack               " Bracket for approximate match
   dac best                " Best match so far
   dzm minp                " No match yet
1:
   lac nlbufp              " Start of symbol buffer
   tad dm6                 " Back up 6 words
   dac cnlp                " Current symbol pointer

nloop:
   lac cnlp
   tad d6                  " Advance to next symbol
   dac cnlp
   lmq                     " Save in MQ
   cma
   tad nlsize              " Compare to end
   spa                     " Past end?
   jmp nlend               " Yes, done
   lac nsearch             " Specific search?
   sza
   jmp testn               " Yes, name match
   lacq                    " No, value match
   tad d3                  " Skip to value field (word 3)
   dac np
   lac i np                " Get symbol type
   sna                     " Skip if non-zero
   jmp nloop               " Zero = empty, skip
   isz np
   lac i np                " Get relocation flag
   dac treloc
   sad relocflg            " Match relocation?
   skp
   jmp nloop               " No, skip
   isz np
   lac i np                " Get value
   dac tvalue
   sad match               " Exact match?
   jmp nlok                " Yes, found!
   lac relocflg            " Relocatable?
   sna
   jmp nloop               " No, must be exact
   lac relflg              " Relative match OK?
   sna
   jmp nloop               " No
   -1
   tad tvalue              " Calculate distance
   cma
   tad match
   spa                     " Positive?
   jmp nloop               " No, skip
   dac 2f                  " Save distance
   tad mbrack              " Within bracket?
   sma
   jmp nloop               " No, too far
   lac best                " Better than best so far?
   cma
   tad d1
   tad 2f
   sma
   jmp nloop               " No
   lac 2f                  " Yes, new best match
   dac best
   lac tvalue
   dac value               " Save value
   lac treloc
   dac reloc               " Save relocation
   lac cnlp
   dac minp                " Save pointer
   jmp nloop               " Continue search</code></pre>
<p><strong>Approximate Matching:</strong></p>
<p>If exact symbol not found, finds closest symbol within ‚Äúbracket‚Äù (30
words):</p>
<pre><code>Address 000157:
  - Symbol 'start' at 000100
  - Symbol 'loop' at 000150
  - Symbol 'done' at 000200

Prints: loop+7  (150 + 7 = 157, within bracket of 30)</code></pre>
<p>This makes debugging much easier than raw octal!</p>
<h3 data-number="8.4.6" id="why-debugging-was-so-hard-in-1969"><span class="header-section-number">8.4.6</span> Why Debugging Was So Hard in
1969</h3>
<p><strong>Before Symbolic Debuggers:</strong></p>
<ol type="1">
<li><strong>Core dumps were octal</strong> - pages of numbers</li>
<li><strong>No symbol tables</strong> - had to manually look up
addresses in listings</li>
<li><strong>Register values in octal</strong> - hard to interpret</li>
<li><strong>No expressions</strong> - couldn‚Äôt do address
arithmetic</li>
<li><strong>No breakpoints</strong> - couldn‚Äôt stop program at specific
points (on PDP-7)</li>
</ol>
<p><strong>Typical 1969 Debugging Session (Without db):</strong></p>
<pre><code>Program crashes, produces core dump

Core dump (partial):
000000: 066143
000001: 040157
000002: 026144
000003: 020006
...

Programmer must:
1. Look at listing to find what's at address 000000
2. Decode 066143 = lac 143 (load from address 143)
3. Find what symbol is at 143 in listing
4. Manually trace through program
5. Calculate addresses by hand</code></pre>
<p><strong>With Unix db:</strong></p>
<pre><code>$ db core a.out
52
$=                       # What is $? (PC register)
start+4
start/                   # What's at start?
start: lac buffer
start+1/                 # Next instruction
tad count
start+2/
dac result
start+3/
sys exit</code></pre>
<p>Much easier!</p>
<h3 data-number="8.4.7" id="modern-debugging-tools-descended-from-db"><span class="header-section-number">8.4.7</span> Modern Debugging Tools
Descended from db</h3>
<p><strong>gdb (GNU Debugger)</strong> - 1986 - Direct descendant of
Unix <code>db</code> - Added: - Breakpoints - Single-stepping -
Source-level debugging - Watchpoints - Kept symbolic address
resolution</p>
<p><strong>adb (Assembly DeBugger)</strong> - 1978 - Evolution of
<code>db</code> for UNIX v7 - Added formatting commands - Better
expression syntax - Still used for kernel debugging</p>
<p><strong>lldb (LLVM Debugger)</strong> - 2010 - Modern debugger -
Still has core dump analysis - Still has symbolic debugging - Still
shows assembly with symbols</p>
<p><strong>The Inheritance:</strong></p>
<pre><code>db (1969)
   ‚Üì
adb (1978) - Advanced features
   ‚Üì
dbx (1980s) - Source-level debugging
   ‚Üì
gdb (1986) - GNU version
   ‚Üì
lldb (2010) - Modern LLVM debugger</code></pre>
<p>Every time you use <code>gdb</code> or <code>lldb</code> and see:</p>
<pre><code>(gdb) print buffer
$1 = 0x12340</code></pre>
<p>You‚Äôre using concepts invented for PDP-7 Unix in 1969!</p>
<hr/>
<h2 data-number="8.5" id="the-loader-ald.s"><span class="header-section-number">8.5</span> 10.5 The Loader (ald.s)</h2>
<p>The loader <code>ald</code> (Absolute LoaDer) reads programs from
punched cards and loads them into executable files.</p>
<h3 data-number="8.5.1" id="card-reader-input-format"><span class="header-section-number">8.5.1</span> Card Reader Input Format</h3>
<p>The PDP-7 had a card reader attachment that could read standard
<strong>IBM 80-column punched cards</strong>.</p>
<p><strong>Physical Card Format:</strong> - 80 columns wide - 12 rows
per column - Each column encodes one character - Hollerith code
encoding</p>
<p><strong>Binary Card Format for PDP-7:</strong></p>
<pre><code>Columns 1-2:    Mode and flags (binary)
Columns 3-4:    Sequence number (binary)
Columns 5-6:    Word count (binary)
Columns 7-79:   Data words (binary)
Column 80:      Checksum (binary)</code></pre>
<p><strong>Card Reader Interface:</strong></p>
<pre class="assembly"><code>rawcard: 0
   lac systime i          " Get current time
   tad wtime              " Add wait time (300 = 5 seconds)
   dac tmtime             " Set timeout time
   -80                    " 80 columns per card
   dac c
   law tbuf-1             " Text buffer pointer
   dac 8
   crsb                   " Card Reader Start Binary
1:
   dzm crread i           " Clear read flag
2:
   lac systime i          " Check time
   cma
   tad tmtime             " Past timeout?
   spa
   jmp timeout            " Yes, timeout error
   lac crread i           " Has card reader read a character?
   sna
   jmp 2b                 " No, wait
   lac crchar i           " Yes, get character
   dac 8 i                " Store in buffer
   isz c                  " Count down columns
   jmp 1b                 " Continue until all 80 read
   law                    " Short delay
   dac 1f
   isz 1f
   jmp .-1
   jmp rawcard i          " Return
1: 0</code></pre>
<p><strong>Card Reader Hardware Interface:</strong></p>
<p>The PDP-7 accessed the card reader through special system locations:
- <code>crread</code> (location 17) - Non-zero when character ready -
<code>crchar</code> (location 18) - Character value</p>
<p>The instruction <code>crsb</code> (Card Reader Start Binary)
initiated card reading.</p>
<h3 data-number="8.5.2" id="binary-format-parsing"><span class="header-section-number">8.5.2</span> Binary Format Parsing</h3>
<p>Once a card is read, it‚Äôs converted from 6-bit codes to 18-bit
words:</p>
<pre class="assembly"><code>bincard: 0
   jms rawcard            " Read 80 columns into tbuf
   -24                    " 24 words fit on one card
   dac c
   law tbuf-1             " Source (6-bit codes)
   dac 8
   law buf-1              " Destination (18-bit words)
   dac 9
1:
   lac 8 i                " Get first 6-bit code
   alss 6                 " Shift left 6 bits
   dac 1f                 " Save
   lac 8 i                " Get second 6-bit code
   dac 1f+1               " Save
   lac 8 i                " Get third 6-bit code
   dac 1f+2               " Save

   " Assemble into two 18-bit words:
   " Word 1: bits 0-5 from code 1, bits 6-17 from code 2
   " Word 2: bits 0-11 from code 2, bits 12-17 from code 3

   lac 1f+1               " Get second code
   lrss 6                 " Right shift 6 bits
   xor 1f                 " Combine with first code
   dac 9 i                " Store first word

   lac 1f+1               " Get second code
   alss 12                " Left shift 12 bits
   xor 1f+2               " Combine with third code
   dac 9 i                " Store second word

   isz c                  " Count down
   jmp 1b                 " Continue
   jmp bincard i          " Return
1: 0;0;0</code></pre>
<p><strong>Card Encoding:</strong></p>
<p>Three 6-bit codes ‚Üí Two 18-bit words:</p>
<pre><code>6-bit codes:   |aaaaaa|bbbbbb|cccccc|
                  ‚Üì       ‚Üì       ‚Üì
18-bit words:  |aaaaaabbbbbb|bbbbbbcccccc|
                   Word 1       Word 2</code></pre>
<h3 data-number="8.5.3" id="checksum-verification"><span class="header-section-number">8.5.3</span> Checksum Verification</h3>
<p>Each card includes a checksum to detect read errors:</p>
<pre class="assembly"><code>cloop:
   jms bincard            " Read and convert card
   lac buf                " Get mode/flags
   and o700               " Mask to mode bits
   sad o500               " Is it binary mode (500)?
   skp
   jmp notbin             " No, error

   -48                    " 48 words to checksum
   dac c1
   lac buf+3              " Get stored checksum
   dac sum                " Save it
   dzm buf+3              " Clear for calculation
   law buf-1              " Start of buffer
   dac 10
   cla                    " Clear accumulator
1:
   add 10 i               " Add each word
   isz c1                 " Count down
   jmp 1b                 " Continue
   sad sum                " Match stored checksum?
   skp
   jmp badcksum           " No, error</code></pre>
<p><strong>Checksum Algorithm:</strong></p>
<ol type="1">
<li>Sum all words in card (except checksum field itself)</li>
<li>Compare to stored checksum</li>
<li>If mismatch, report error and re-read card</li>
</ol>
<p>This catches errors from: - Dust on card - Bent or torn card - Card
reader mechanical problems - Electrical noise</p>
<h3 data-number="8.5.4" id="complete-implementation-analysis"><span class="header-section-number">8.5.4</span> Complete Implementation
Analysis</h3>
<p>The full loading process:</p>
<pre class="assembly"><code>loop:
   jms holcard            " Read hollerith (text) card
   lac o12                " Newline
   dac buf+4              " Add to buffer
   lac d1
   sys write; buf; 5      " Print card header (filename)
   law 017                " Mode 17 (read/write)
   sys creat; buf         " Create output file
   spa                    " Success?
   jmp ferror             " No, error
   dac fo                 " Save file descriptor
   dzm noc                " Clear word count
   law obuf               " Output buffer
   dac opt                " Output pointer
   dzm seq                " Clear sequence number

cloop:
   jms bincard            " Read binary card
   lac buf                " Get mode
   and o700
   sad o500               " Binary?
   skp
   jmp notbin

   " Verify checksum (shown above)

   lac buf+1              " Get sequence number
   sad seq                " Match expected?
   skp
   jmp badseq             " No, error

   -1
   tad buf+2              " Get word count
   cma
   dac c1                 " Use as counter
   law buf+3              " Point to data
   dac 10
1:
   lac 10 i               " Get data word
   jms putword            " Write to output
   isz c1                 " Count down
   jmp 1b                 " Continue

   isz seq                " Increment sequence number
   lac buf                " Get mode
   sma                    " High bit set (last card)?
   jmp cloop              " No, continue

   " Last card - finish up
   lac noc                " Get word count
   sna                    " Any data to write?
   jmp 1f                 " No
   dac 0f                 " Yes, set count
   lac fo                 " File descriptor
   sys write; obuf; 0;..  " Write final buffer
1:
   lac fo
   sys close              " Close file
   sys exit               " Exit

putword: 0
   dac opt i              " Store word in output buffer
   isz opt                " Advance pointer
   isz noc                " Count word
   lac noc
   sad d2048              " Buffer full? (2048 words)
   skp
   jmp putword i          " No, return
   lac fo                 " Yes, write buffer
   sys write; obuf; 2048
   dzm noc                " Reset count
   law obuf               " Reset pointer
   dac opt
   jmp putword i          " Return</code></pre>
<h3 data-number="8.5.5" id="physical-punched-cards-in-1969"><span class="header-section-number">8.5.5</span> Physical Punched Cards in
1969</h3>
<p><strong>What Cards Looked Like:</strong></p>
<pre><code> ___________________________________________________________________________
|  :::  :::  :::  :::  :::  :::  :::  :::  :::  :::  :::  :::  :::  :::  |
| :::  :::  :::  :::  :::  :::  :::  :::  :::  :::  :::  :::  :::  :::   |
|  :::  :::  :::  :::  :::  :::  :::  :::  :::  :::  :::  :::  :::  :::  |
| :::  :::  :::  :::  :::  :::  :::  :::  :::  :::  :::  :::  :::  :::   |
|  ___  ___  ___  ___  ___  ___  ___  ___  ___  ___  ___  ___  ___  ___  |
| |   ||   ||   ||   ||   ||   ||   ||   ||   ||   ||   ||   ||   ||   | |
|0123456789012345678901234567890123456789012345678901234567890123456789012|
|___________________________________________________________________________|

7.375 inches wide √ó 3.25 inches tall</code></pre>
<p><strong>Hollerith Code:</strong></p>
<p>Each column had 12 positions (rows):</p>
<pre><code>Position:  12 11  0  1  2  3  4  5  6  7  8  9
           -- --  -  -  -  -  -  -  -  -  -  -
Character   Y  X        Numbers  ‚Üí
   'A'      ‚óè     ‚óè  ‚óè
   'B'      ‚óè     ‚óè     ‚óè
   'C'      ‚óè     ‚óè        ‚óè
   '0'                                        ‚óè
   '1'                          ‚óè
   '9'                                     ‚óè</code></pre>
<p><strong>Card Deck Organization:</strong></p>
<p>A program might be 50-500 cards in a deck:</p>
<pre><code>Card 1:   Header card (program name, date)
Card 2:   Binary data - Sequence 000
Card 3:   Binary data - Sequence 001
Card 4:   Binary data - Sequence 002
...
Card N:   Binary data - Sequence XXX (last card flag set)</code></pre>
<p><strong>Common Problems:</strong></p>
<ol type="1">
<li><strong>Dropped deck</strong> - Cards out of order (sequence numbers
help)</li>
<li><strong>Bent cards</strong> - Won‚Äôt feed through reader</li>
<li><strong>Torn cards</strong> - Misread (checksum catches)</li>
<li><strong>Static electricity</strong> - Cards stick together</li>
<li><strong>Coffee spills</strong> - Cards unreadable</li>
</ol>
<p><strong>Why ald Checks Everything:</strong></p>
<ul>
<li>Sequence numbers: Detect out-of-order cards</li>
<li>Checksums: Detect read errors</li>
<li>Timeouts: Detect jammed cards</li>
<li>Mode checks: Detect wrong card type</li>
</ul>
<p><strong>The Transition:</strong></p>
<p>By 1971-1972, Unix moved to DECTape and later disk-only: - Faster
(disk &gt;&gt; tape &gt;&gt; cards) - More reliable - Easier to edit -
Lower cost (no cards to buy)</p>
<p>But in 1969, card reader support was necessary for initial system
bootstrap and sharing programs between sites.</p>
<hr/>
<h2 data-number="8.6" id="the-development-workflow"><span class="header-section-number">8.6</span> 10.6 The Development
Workflow</h2>
<h3 data-number="8.6.1" id="write-code-in-ed"><span class="header-section-number">8.6.1</span> Write Code in ed</h3>
<p><strong>Typical Editing Session:</strong></p>
<pre><code>$ ed
?                       " File doesn't exist yet
a                       " Append mode
" hello.s - print hello world

   lac d1              " File descriptor 1 (stdout)
   sys write; 1f; 2f-1f
   sys exit
1:
   &lt;he&gt;;&lt;ll&gt;;&lt;o 040; &lt;wo&gt;;&lt;rl&gt;;&lt;d 012
2:
.                       " End append mode
w hello.s               " Write to file
123                     " 123 characters written
q                       " Quit
$</code></pre>
<p>The programmer: 1. Creates file with <code>ed</code> 2. Types code
line by line 3. Uses <code>.</code> to exit insert mode 4. Writes file
with <code>w filename</code> 5. Quits with <code>q</code></p>
<h3 data-number="8.6.2" id="assemble-with-as"><span class="header-section-number">8.6.2</span> Assemble with as</h3>
<pre><code>$ as hello.s
1
$</code></pre>
<p>Output: - <code>a.out</code> - Executable file - <code>n.out</code> -
Symbol table for debugger</p>
<p>If errors:</p>
<pre><code>$ as hello.s
x&gt;24                    " Syntax error on line 24
r&gt;15                    " Relocation error on line 15
$</code></pre>
<p>Error codes: - <code>x&gt;</code> - Syntax error - <code>r&gt;</code>
- Relocation error - <code>&gt;&gt;</code> - Address overflow -
<code>u&gt;</code> - Undefined symbol - <code>g&gt;</code> - Garbage
character</p>
<h3 data-number="8.6.3" id="test-and-debug"><span class="header-section-number">8.6.3</span> Test and Debug</h3>
<p><strong>If it works:</strong></p>
<pre><code>$ a.out
hello world
$</code></pre>
<p><strong>If it crashes:</strong></p>
<pre><code>$ a.out
(crash - core dumped)
$ db core a.out
52                      " Error at location 52 (octal)
$=                      " What symbol?
start+4
start,10/               " Examine code
start: lac buffer
start+1: tad count
start+2: dac result
start+3: sys exit
start+4: illegal_instruction
...</code></pre>
<p>The programmer: 1. Runs program 2. If crash, examines core dump 3.
Finds error with symbolic debugging 4. Returns to editor to fix 5.
Reassembles 6. Tests again</p>
<h3 data-number="8.6.4" id="complete-example-workflow"><span class="header-section-number">8.6.4</span> Complete Example
Workflow</h3>
<p><strong>Goal:</strong> Write a program to count characters in a
file</p>
<p><strong>Step 1: Create with ed</strong></p>
<pre><code>$ ed
?
a
" count.s - count characters

   sys open; 1f; 0      " Open file
   spa                  " Success?
   sys exit             " No, exit
   dac fd               " Save file descriptor
   dzm count            " Clear counter

loop:
   lac fd               " Load file descriptor
   sys read; buf; 64    " Read 64 words
   sna                  " Anything read?
   jmp done             " No, done
   dac nwords           " Save count
   law buf-1            " Buffer pointer
   dac 8
   lac nwords           " Load count
   cma                  " Negate
   dac c                " Use as counter
1:
   lac i 8              " Get word
   dac word             " Save
   jms getsc; talp      " Get first character
   sna                  " Non-zero?
   jmp 2f               " No, skip
   isz count            " Yes, count it
2:
   jms getsc; talp      " Get second character
   sna
   jmp 3f
   isz count
3:
   isz c                " Done with words?
   jmp 1b               " No, continue
   jmp loop             " Yes, read more

done:
   lac count            " Get count
   jms prnum            " Print number
   sys exit

" Print number subroutine
prnum: 0
   (code to print number)
   jmp i prnum

fd: .=.+1
count: .=.+1
nwords: .=.+1
c: .=.+1
word: .=.+1
talp: tal
tal: .=.+1
buf: .=.+64
1:
   &lt;fi&gt;;&lt;le&gt;;&lt;na&gt;;&lt;me&gt;;040040;040040
.
w count.s
456
q
$</code></pre>
<p><strong>Step 2: Assemble</strong></p>
<pre><code>$ as count.s
1
$</code></pre>
<p><strong>Step 3: Test</strong></p>
<pre><code>$ count.s
(program doesn't have execute permission yet - in early Unix)
$ a.out
324                     " Character count
$</code></pre>
<p><strong>Step 4: Fix Bug (if any)</strong></p>
<p>Suppose it crashes:</p>
<pre><code>$ a.out
(crash)
$ db core a.out
52
loop+5/                 " Examine where it crashed
loop+5: lac i 8
,8=                     " What's in register 8?
177777                  " -1 in octal - bad pointer!
$</code></pre>
<p>Programmer realizes: forgot to initialize auto-index register!</p>
<pre><code>$ ed count.s
456
/law buf-1/             " Find the line
law buf-1
i                       " Insert before
   cla                 " Clear accumulator first!
.
w
478                     " File now 478 bytes
q
$ as count.s
1
$ a.out
324                     " Works now!
$</code></pre>
<h3 data-number="8.6.5" id="comparison-to-modern-ides"><span class="header-section-number">8.6.5</span> Comparison to Modern
IDEs</h3>
<p><strong>Modern IDE (Visual Studio Code, 2024):</strong></p>
<pre><code>Install size:  ~200 MB
Memory usage:  ~500 MB RAM
Features:      Syntax highlighting
               Code completion
               Debugger integration
               Git integration
               Extensions
               Multiple windows
               Mouse support
               Graphics

Latency:       &lt;100ms for most operations</code></pre>
<p><strong>Unix Development Environment (1969):</strong></p>
<pre><code>Install size:  ~26 KB (assembler + editor + debugger)
Memory usage:  ~8 KB RAM (one tool at a time)
Features:      Text editing (ed)
               Assembly
               Symbolic debugging
               File system integration

Latency:       &lt;1 second for most operations
               (on a 0.1 MIPS machine!)</code></pre>
<p><strong>What‚Äôs Similar:</strong></p>
<ol type="1">
<li><strong>Edit-compile-debug cycle</strong> - Same workflow</li>
<li><strong>Symbolic debugging</strong> - Modern debuggers use same
concepts</li>
<li><strong>File-based projects</strong> - Code stored in files</li>
<li><strong>Command-line interface</strong> - Programmers still use
terminals</li>
<li><strong>Version control</strong> - Unix had early source
control</li>
</ol>
<p><strong>What‚Äôs Different:</strong></p>
<ol type="1">
<li><strong>Size</strong> - 7,700x smaller (26KB vs 200MB)</li>
<li><strong>Graphics</strong> - Unix used Teletype (paper), IDE uses
GUI</li>
<li><strong>Speed</strong> - PDP-7 0.1 MIPS, modern CPU 100,000+ MIPS
(1,000,000x faster)</li>
<li><strong>Assistance</strong> - No auto-complete, syntax highlighting,
etc.</li>
<li><strong>Integration</strong> - Modern IDEs integrate everything</li>
</ol>
<p><strong>Productivity:</strong></p>
<p>Surprisingly, expert programmers were very productive with these
tools:</p>
<ul>
<li>Ken Thompson wrote file system in ~1 month</li>
<li>Dennis Ritchie added pipes in ~1 night</li>
<li>Shell and utilities: weeks each</li>
</ul>
<p>Modern programmers with IDEs aren‚Äôt 1000x more productive, despite
1000x better tools. Why?</p>
<ol type="1">
<li><strong>Problems are harder</strong> - More complex systems</li>
<li><strong>Compatibility</strong> - Must work with legacy code</li>
<li><strong>Scale</strong> - Millions of lines instead of thousands</li>
<li><strong>Quality demands</strong> - More testing, documentation,
security</li>
</ol>
<p>But also: 1. <strong>Tool complexity</strong> - Time spent learning
IDE 2. <strong>Distractions</strong> - Email, web, etc. 3.
<strong>Meeting overhead</strong> - More coordination</p>
<p>The simple tools forced focus on the code itself.</p>
<h3 data-number="8.6.6" id="what-made-this-revolutionary"><span class="header-section-number">8.6.6</span> What Made This
Revolutionary</h3>
<p><strong>The Integrated Vision:</strong></p>
<p>All tools designed to work together: - Editor saves files assembler
reads - Assembler writes symbol table debugger reads - Debugger examines
core dumps from crashed programs - All use same file system - All run on
same machine - All accessible to single programmer</p>
<p><strong>The Speed:</strong></p>
<p>From idea to running code: <strong>minutes</strong></p>
<p>Industry standard in 1969: <strong>hours to days</strong></p>
<p>This enabled: - Rapid prototyping - Experimentation - Iterative
refinement - Learning by doing</p>
<p><strong>The Accessibility:</strong></p>
<p>One programmer, one machine, full development environment.</p>
<p>Before: Shared mainframe, batch processing, punch cards,
operators.</p>
<p>This democratized programming.</p>
<p><strong>The Self-Hosting Loop:</strong></p>
<p>Better tools ‚Üí Better programs ‚Üí Better tools ‚Üí ‚Ä¶</p>
<p>This created Unix‚Äôs rapid evolution: - 1969: First edition - 1970:
Second edition (pipes added) - 1971: Third edition (major improvements)
- 1972: Fourth edition (rewritten in C!) - 1973: Fifth edition (first
widely distributed)</p>
<p><strong>The Legacy:</strong></p>
<p>Modern development still follows the Unix model: - Text-based source
files - Command-line tools - Symbolic debuggers - Edit-compile-debug
cycle - Version control</p>
<p>The Unix development environment, written in ~3,210 lines of assembly
code in 1969, created the template for all modern software
development.</p>
<hr/>
<h2 data-number="8.7" id="conclusion-celebrating-the-achievement"><span class="header-section-number">8.7</span> Conclusion: Celebrating the
Achievement</h2>
<p>The PDP-7 Unix development tools represent one of computing‚Äôs great
achievements:</p>
<p><strong>The Numbers:</strong> - ~3,210 lines of assembly code - ~26
KB total size - Written in ~3 months (mid-1969) - Enabled decades of
innovation</p>
<p><strong>The Innovation:</strong> - Self-hosting system on small
computer - Symbolic debugging - Regular expressions - Integrated file
system - Complete development environment</p>
<p><strong>The Influence:</strong> - Every Unix and Linux system - Every
modern debugger - Every text editor with regex - Every IDE‚Äôs
edit-compile-debug cycle - Every command-line tool</p>
<p><strong>The Philosophy:</strong> - Small, sharp tools - Tools that
work together - Text-based interfaces - Programmer empowerment -
Simplicity and clarity</p>
<p>In 1969, two programmers (Ken Thompson and Dennis Ritchie) created a
complete, self-hosting development environment in assembly language on
an obsolete computer. This environment was so well-designed that its
descendants are still in use 55+ years later.</p>
<p>That is the true achievement: not just building tools, but building
<strong>the right tools</strong> - tools so fundamental that they
transcended their hardware and became timeless concepts in software
development.</p>
<p>The PDP-7 Unix development tools prove that great software isn‚Äôt
about having the latest hardware or the most features. It‚Äôs about clear
thinking, elegant design, and tools that work together harmoniously.</p>
<p>This is the Unix philosophy distilled: do one thing well, make tools
composable, use simple interfaces, and enable programmers to build
better tools.</p>
<p>The virtuous cycle they created in 1969 is still spinning today.</p>
<h1 data-number="9" id="chapter-11---user-utilities-the-unix-philosophy-emerges"><span class="header-section-number">9</span> Chapter 11 - User Utilities: The
Unix Philosophy Emerges</h1>
<h2 data-number="9.1" id="the-unix-philosophy-in-code"><span class="header-section-number">9.1</span> 11.1 The Unix Philosophy in
Code</h2>
<p>The Unix philosophy‚Äî‚ÄúWrite programs that do one thing and do it
well‚Äù‚Äîis often cited as a design principle deliberately chosen by the
system‚Äôs creators. But examining the PDP-7 Unix utilities reveals a
different story: this philosophy emerged organically from the severe
hardware constraints of 1969, not from abstract design goals.</p>
<h3 data-number="9.1.1" id="the-constraints-that-shaped-philosophy"><span class="header-section-number">9.1.1</span> The Constraints That Shaped
Philosophy</h3>
<p>The PDP-7 provided only 8K words (16KB) of core memory. Each utility
had to: - Fit in minimal memory alongside the kernel - Execute quickly
on a slow processor (1.75 Œºs cycle time) - Minimize disk I/O (DECtape
operated at 350 bytes/second) - Be simple enough to debug with primitive
tools</p>
<p>These constraints made it impossible to write monolithic,
feature-rich programs. The result was a collection of small, focused
tools‚Äînot because Thompson and Ritchie read about modularity in a
textbook, but because there was literally no room for anything else.</p>
<h3 data-number="9.1.2" id="contrast-with-1969-computing-culture"><span class="header-section-number">9.1.2</span> Contrast with 1969 Computing
Culture</h3>
<p>To appreciate how revolutionary these utilities were, consider the
dominant computing paradigms of 1969:</p>
<p><strong>Batch Processing Systems:</strong> - Jobs submitted via
punched cards - Hours between submission and results - Programs were
large, monolithic routines - No interactive utilities at all</p>
<p><strong>Mainframe Time-Sharing (CTSS, Multics):</strong> - Complex
command interpreters with built-in functionality - Commands were part of
the supervisor, not separate programs - Heavy, feature-laden interfaces
- Commands had dozens of options and modes</p>
<p><strong>Minicomputer Monitors:</strong> - Paper-tape based systems -
Simple file operations in the monitor itself - No concept of composable
tools - Everything was a built-in command</p>
<h3 data-number="9.1.3" id="the-unix-difference"><span class="header-section-number">9.1.3</span> The Unix Difference</h3>
<p>PDP-7 Unix introduced something genuinely new:</p>
<ol type="1">
<li><strong>External Commands:</strong> Utilities weren‚Äôt built into the
shell‚Äîthey were separate executable files</li>
<li><strong>Uniform Interface:</strong> All commands read from standard
input and wrote to standard output</li>
<li><strong>Composability:</strong> The simple I/O model meant tools
could be chained (though pipes didn‚Äôt exist yet on PDP-7)</li>
<li><strong>Minimal Feature Sets:</strong> Each tool did exactly one
thing</li>
</ol>
<p>This wasn‚Äôt planned. It was discovered.</p>
<h3 data-number="9.1.4" id="the-cultural-impact"><span class="header-section-number">9.1.4</span> The Cultural Impact</h3>
<p>What began as necessity became doctrine. When Unix moved to the
PDP-11 with more memory, the small-tool philosophy persisted‚Äînot because
of hardware limits, but because developers had learned its benefits:</p>
<ul>
<li><strong>Debuggability:</strong> Small programs had fewer bugs</li>
<li><strong>Reusability:</strong> Simple tools combined in unexpected
ways</li>
<li><strong>Maintainability:</strong> Each program was easy to
understand</li>
<li><strong>Testability:</strong> Limited functionality meant complete
testing was possible</li>
</ul>
<p>The PDP-7 constraints had accidentally invented a better way to build
systems.</p>
<h2 data-number="9.2" id="file-viewing-and-manipulation"><span class="header-section-number">9.2</span> 11.2 File Viewing and
Manipulation</h2>
<h3 data-number="9.2.1" id="cat.s---concatenate-files"><span class="header-section-number">9.2.1</span> cat.s - Concatenate
Files</h3>
<p><strong>Purpose:</strong> Display or concatenate file contents to
standard output</p>
<p><strong>Lines of Code:</strong> 146 (including I/O library)</p>
<p><strong>Why cat Matters:</strong> This is arguably the simplest
useful program in Unix. It demonstrates the complete pattern of Unix
file I/O: open, read, process, write, close. Every Unix programmer
learns by studying cat.</p>
<h4 data-number="9.2.1.1" id="complete-source-code-with-analysis"><span class="header-section-number">9.2.1.1</span> Complete Source Code with
Analysis</h4>
<div class="sourceCode" id="cb654"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb654-1"><a aria-hidden="true" href="#cb654-1" tabindex="-1"></a>" cat</span>
<span id="cb654-2"><a aria-hidden="true" href="#cb654-2" tabindex="-1"></a></span>
<span id="cb654-3"><a aria-hidden="true" href="#cb654-3" tabindex="-1"></a>   lac <span class="dv">017777</span> i          <span class="st">" Load argument count</span></span>
<span id="cb654-4"><a aria-hidden="true" href="#cb654-4" tabindex="-1"></a>   sad d4                <span class="st">" Skip if argument count differs from 4</span></span>
<span id="cb654-5"><a aria-hidden="true" href="#cb654-5" tabindex="-1"></a>   <span class="cf">jmp</span> nofiles           <span class="st">" No files specified</span></span>
<span id="cb654-6"><a aria-hidden="true" href="#cb654-6" tabindex="-1"></a>   lac <span class="dv">017777</span>            <span class="st">" Get argument vector base</span></span>
<span id="cb654-7"><a aria-hidden="true" href="#cb654-7" tabindex="-1"></a>   tad d1                <span class="st">" Add 1</span></span>
<span id="cb654-8"><a aria-hidden="true" href="#cb654-8" tabindex="-1"></a>   tad d4                <span class="st">" Add 4 (skip past argv[0])</span></span>
<span id="cb654-9"><a aria-hidden="true" href="#cb654-9" tabindex="-1"></a>   dac name              <span class="st">" Store as current filename pointer</span></span>
<span id="cb654-10"><a aria-hidden="true" href="#cb654-10" tabindex="-1"></a></span>
<span id="cb654-11"><a aria-hidden="true" href="#cb654-11" tabindex="-1"></a><span class="fu">loop:</span></span>
<span id="cb654-12"><a aria-hidden="true" href="#cb654-12" tabindex="-1"></a>   sys open<span class="co">; name: 0; 0  " Open file for reading</span></span>
<span id="cb654-13"><a aria-hidden="true" href="#cb654-13" tabindex="-1"></a>   spa                   <span class="st">" Skip on positive AC (success)</span></span>
<span id="cb654-14"><a aria-hidden="true" href="#cb654-14" tabindex="-1"></a>   <span class="cf">jmp</span> badfile           <span class="st">" Handle open failure</span></span>
<span id="cb654-15"><a aria-hidden="true" href="#cb654-15" tabindex="-1"></a>   dac fi                <span class="st">" Save file descriptor</span></span>
<span id="cb654-16"><a aria-hidden="true" href="#cb654-16" tabindex="-1"></a></span>
<span id="cb654-17"><a aria-hidden="true" href="#cb654-17" tabindex="-1"></a>1:</span>
<span id="cb654-18"><a aria-hidden="true" href="#cb654-18" tabindex="-1"></a>   jms getc              <span class="st">" Get a character from input</span></span>
<span id="cb654-19"><a aria-hidden="true" href="#cb654-19" tabindex="-1"></a>   sad o4                <span class="st">" Skip if different from EOF (4)</span></span>
<span id="cb654-20"><a aria-hidden="true" href="#cb654-20" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">1</span><span class="bn">f</span>                <span class="st">" End of file reached</span></span>
<span id="cb654-21"><a aria-hidden="true" href="#cb654-21" tabindex="-1"></a>   jms putc              <span class="st">" Write character to output</span></span>
<span id="cb654-22"><a aria-hidden="true" href="#cb654-22" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span>                <span class="st">" Continue reading</span></span>
<span id="cb654-23"><a aria-hidden="true" href="#cb654-23" tabindex="-1"></a></span>
<span id="cb654-24"><a aria-hidden="true" href="#cb654-24" tabindex="-1"></a>1:</span>
<span id="cb654-25"><a aria-hidden="true" href="#cb654-25" tabindex="-1"></a>   lac fi                <span class="st">" Load file descriptor</span></span>
<span id="cb654-26"><a aria-hidden="true" href="#cb654-26" tabindex="-1"></a>   sys close             <span class="st">" Close the input file</span></span>
<span id="cb654-27"><a aria-hidden="true" href="#cb654-27" tabindex="-1"></a></span>
<span id="cb654-28"><a aria-hidden="true" href="#cb654-28" tabindex="-1"></a><span class="fu">loop1:</span></span>
<span id="cb654-29"><a aria-hidden="true" href="#cb654-29" tabindex="-1"></a>   -4                    " Decrement argument count by <span class="dv">4</span></span>
<span id="cb654-30"><a aria-hidden="true" href="#cb654-30" tabindex="-1"></a>   tad <span class="dv">017777</span> i</span>
<span id="cb654-31"><a aria-hidden="true" href="#cb654-31" tabindex="-1"></a>   dac <span class="dv">017777</span> i</span>
<span id="cb654-32"><a aria-hidden="true" href="#cb654-32" tabindex="-1"></a>   sad d4                <span class="st">" Skip if more arguments remain</span></span>
<span id="cb654-33"><a aria-hidden="true" href="#cb654-33" tabindex="-1"></a>   <span class="cf">jmp</span> done              <span class="st">" All files processed</span></span>
<span id="cb654-34"><a aria-hidden="true" href="#cb654-34" tabindex="-1"></a>   lac name              <span class="st">" Advance to next filename</span></span>
<span id="cb654-35"><a aria-hidden="true" href="#cb654-35" tabindex="-1"></a>   tad d4</span>
<span id="cb654-36"><a aria-hidden="true" href="#cb654-36" tabindex="-1"></a>   dac name</span>
<span id="cb654-37"><a aria-hidden="true" href="#cb654-37" tabindex="-1"></a>   <span class="cf">jmp</span> loop              <span class="st">" Process next file</span></span>
<span id="cb654-38"><a aria-hidden="true" href="#cb654-38" tabindex="-1"></a></span>
<span id="cb654-39"><a aria-hidden="true" href="#cb654-39" tabindex="-1"></a><span class="fu">badfile:</span></span>
<span id="cb654-40"><a aria-hidden="true" href="#cb654-40" tabindex="-1"></a>   lac name              <span class="st">" Load filename pointer</span></span>
<span id="cb654-41"><a aria-hidden="true" href="#cb654-41" tabindex="-1"></a>   dac <span class="fl">1</span><span class="bn">f</span></span>
<span id="cb654-42"><a aria-hidden="true" href="#cb654-42" tabindex="-1"></a>   lac d8                <span class="st">" File descriptor 8 (stderr? no, stdout=1)</span></span>
<span id="cb654-43"><a aria-hidden="true" href="#cb654-43" tabindex="-1"></a>   sys write<span class="co">; 1:0; 4     " Write "? " error prefix</span></span>
<span id="cb654-44"><a aria-hidden="true" href="#cb654-44" tabindex="-1"></a>   lac d8</span>
<span id="cb654-45"><a aria-hidden="true" href="#cb654-45" tabindex="-1"></a>   sys write<span class="co">; 1f; 2      " Write error message</span></span>
<span id="cb654-46"><a aria-hidden="true" href="#cb654-46" tabindex="-1"></a>   <span class="cf">jmp</span> loop1             <span class="st">" Continue with next file</span></span>
<span id="cb654-47"><a aria-hidden="true" href="#cb654-47" tabindex="-1"></a></span>
<span id="cb654-48"><a aria-hidden="true" href="#cb654-48" tabindex="-1"></a>1: 040<span class="co">;077012            " "? \n" error message</span></span></code></pre></div>
<h4 data-number="9.2.1.2" id="the-character-buffering-system"><span class="header-section-number">9.2.1.2</span> The Character Buffering
System</h4>
<p>The genius of cat is in its buffering. Rather than making a system
call for every character, it uses 64-word buffers:</p>
<div class="sourceCode" id="cb655"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb655-1"><a aria-hidden="true" href="#cb655-1" tabindex="-1"></a><span class="fu">getc:</span> 0</span>
<span id="cb655-2"><a aria-hidden="true" href="#cb655-2" tabindex="-1"></a>   lac ipt               <span class="st">" Load input pointer</span></span>
<span id="cb655-3"><a aria-hidden="true" href="#cb655-3" tabindex="-1"></a>   sad eipt              <span class="st">" Skip if different from end pointer</span></span>
<span id="cb655-4"><a aria-hidden="true" href="#cb655-4" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">1</span><span class="bn">f</span>                <span class="st">" Buffer empty, refill it</span></span>
<span id="cb655-5"><a aria-hidden="true" href="#cb655-5" tabindex="-1"></a>   dac <span class="fl">2</span><span class="bn">f</span>                <span class="st">" Save current pointer</span></span>
<span id="cb655-6"><a aria-hidden="true" href="#cb655-6" tabindex="-1"></a>   <span class="bu">add</span> o400000           <span class="st">" Increment pointer</span></span>
<span id="cb655-7"><a aria-hidden="true" href="#cb655-7" tabindex="-1"></a>   dac ipt</span>
<span id="cb655-8"><a aria-hidden="true" href="#cb655-8" tabindex="-1"></a>   ral                   <span class="st">" Rotate to check odd/even</span></span>
<span id="cb655-9"><a aria-hidden="true" href="#cb655-9" tabindex="-1"></a>   lac <span class="fl">2</span><span class="bn">f</span> i              <span class="st">" Load word from buffer</span></span>
<span id="cb655-10"><a aria-hidden="true" href="#cb655-10" tabindex="-1"></a>   szl                   <span class="st">" Skip if link was zero (even char)</span></span>
<span id="cb655-11"><a aria-hidden="true" href="#cb655-11" tabindex="-1"></a>   lrss <span class="dv">9</span>                <span class="st">" Right shift 9 bits (get high char)</span></span>
<span id="cb655-12"><a aria-hidden="true" href="#cb655-12" tabindex="-1"></a>   <span class="bu">and</span> o177              <span class="st">" Mask to 7 bits</span></span>
<span id="cb655-13"><a aria-hidden="true" href="#cb655-13" tabindex="-1"></a>   sna                   <span class="st">" Skip if non-zero</span></span>
<span id="cb655-14"><a aria-hidden="true" href="#cb655-14" tabindex="-1"></a>   <span class="cf">jmp</span> getc<span class="op">+</span><span class="dv">1</span>            <span class="st">" Zero character, get next</span></span>
<span id="cb655-15"><a aria-hidden="true" href="#cb655-15" tabindex="-1"></a>   <span class="cf">jmp</span> getc i            <span class="st">" Return with character</span></span>
<span id="cb655-16"><a aria-hidden="true" href="#cb655-16" tabindex="-1"></a></span>
<span id="cb655-17"><a aria-hidden="true" href="#cb655-17" tabindex="-1"></a>1:</span>
<span id="cb655-18"><a aria-hidden="true" href="#cb655-18" tabindex="-1"></a>   lac fi                <span class="st">" Buffer empty - refill</span></span>
<span id="cb655-19"><a aria-hidden="true" href="#cb655-19" tabindex="-1"></a>   sys read<span class="co">; iipt+1; 64  " Read 64 words from file</span></span>
<span id="cb655-20"><a aria-hidden="true" href="#cb655-20" tabindex="-1"></a>   sna                   <span class="st">" Skip if non-zero (got data)</span></span>
<span id="cb655-21"><a aria-hidden="true" href="#cb655-21" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">1</span><span class="bn">f</span>                <span class="st">" EOF reached</span></span>
<span id="cb655-22"><a aria-hidden="true" href="#cb655-22" tabindex="-1"></a>   tad iipt              <span class="st">" Calculate new end pointer</span></span>
<span id="cb655-23"><a aria-hidden="true" href="#cb655-23" tabindex="-1"></a>   dac eipt</span>
<span id="cb655-24"><a aria-hidden="true" href="#cb655-24" tabindex="-1"></a>   lac iipt              <span class="st">" Reset input pointer to buffer start</span></span>
<span id="cb655-25"><a aria-hidden="true" href="#cb655-25" tabindex="-1"></a>   dac ipt</span>
<span id="cb655-26"><a aria-hidden="true" href="#cb655-26" tabindex="-1"></a>   <span class="cf">jmp</span> getc<span class="op">+</span><span class="dv">1</span>            <span class="st">" Try again</span></span>
<span id="cb655-27"><a aria-hidden="true" href="#cb655-27" tabindex="-1"></a></span>
<span id="cb655-28"><a aria-hidden="true" href="#cb655-28" tabindex="-1"></a>1:</span>
<span id="cb655-29"><a aria-hidden="true" href="#cb655-29" tabindex="-1"></a>   lac o4                <span class="st">" Return EOF (4)</span></span>
<span id="cb655-30"><a aria-hidden="true" href="#cb655-30" tabindex="-1"></a>   <span class="cf">jmp</span> getc i</span>
<span id="cb655-31"><a aria-hidden="true" href="#cb655-31" tabindex="-1"></a></span>
<span id="cb655-32"><a aria-hidden="true" href="#cb655-32" tabindex="-1"></a><span class="fu">putc:</span> 0</span>
<span id="cb655-33"><a aria-hidden="true" href="#cb655-33" tabindex="-1"></a>   <span class="bu">and</span> o177              <span class="st">" Mask character to 7 bits</span></span>
<span id="cb655-34"><a aria-hidden="true" href="#cb655-34" tabindex="-1"></a>   dac <span class="fl">2</span><span class="bn">f</span><span class="op">+</span><span class="dv">1</span>              <span class="st">" Save character</span></span>
<span id="cb655-35"><a aria-hidden="true" href="#cb655-35" tabindex="-1"></a>   lac opt               <span class="st">" Load output pointer</span></span>
<span id="cb655-36"><a aria-hidden="true" href="#cb655-36" tabindex="-1"></a>   dac <span class="fl">2</span><span class="bn">f</span></span>
<span id="cb655-37"><a aria-hidden="true" href="#cb655-37" tabindex="-1"></a>   <span class="bu">add</span> o400000           <span class="st">" Increment pointer</span></span>
<span id="cb655-38"><a aria-hidden="true" href="#cb655-38" tabindex="-1"></a>   dac opt</span>
<span id="cb655-39"><a aria-hidden="true" href="#cb655-39" tabindex="-1"></a>   spa                   <span class="st">" Skip on positive (even character)</span></span>
<span id="cb655-40"><a aria-hidden="true" href="#cb655-40" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">1</span><span class="bn">f</span>                <span class="st">" Odd character</span></span>
<span id="cb655-41"><a aria-hidden="true" href="#cb655-41" tabindex="-1"></a>   lac <span class="fl">2</span><span class="bn">f</span> i              <span class="st">" Even: load existing word</span></span>
<span id="cb655-42"><a aria-hidden="true" href="#cb655-42" tabindex="-1"></a>   <span class="bu">xor</span> <span class="fl">2</span><span class="bn">f</span><span class="op">+</span><span class="dv">1</span>              <span class="st">" OR in new character</span></span>
<span id="cb655-43"><a aria-hidden="true" href="#cb655-43" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">3</span><span class="bn">f</span></span>
<span id="cb655-44"><a aria-hidden="true" href="#cb655-44" tabindex="-1"></a>1:</span>
<span id="cb655-45"><a aria-hidden="true" href="#cb655-45" tabindex="-1"></a>   lac <span class="fl">2</span><span class="bn">f</span><span class="op">+</span><span class="dv">1</span>              <span class="st">" Odd: shift left 9 bits</span></span>
<span id="cb655-46"><a aria-hidden="true" href="#cb655-46" tabindex="-1"></a>   alss <span class="dv">9</span></span>
<span id="cb655-47"><a aria-hidden="true" href="#cb655-47" tabindex="-1"></a>3:</span>
<span id="cb655-48"><a aria-hidden="true" href="#cb655-48" tabindex="-1"></a>   dac <span class="fl">2</span><span class="bn">f</span> i              <span class="st">" Store back to buffer</span></span>
<span id="cb655-49"><a aria-hidden="true" href="#cb655-49" tabindex="-1"></a>   isz noc               <span class="st">" Increment character count</span></span>
<span id="cb655-50"><a aria-hidden="true" href="#cb655-50" tabindex="-1"></a>   lac noc</span>
<span id="cb655-51"><a aria-hidden="true" href="#cb655-51" tabindex="-1"></a>   sad d128              <span class="st">" Skip if different from 128</span></span>
<span id="cb655-52"><a aria-hidden="true" href="#cb655-52" tabindex="-1"></a>   skp</span>
<span id="cb655-53"><a aria-hidden="true" href="#cb655-53" tabindex="-1"></a>   <span class="cf">jmp</span> putc i            <span class="st">" Not full yet, return</span></span>
<span id="cb655-54"><a aria-hidden="true" href="#cb655-54" tabindex="-1"></a>   lac fo                <span class="st">" Buffer full - flush it</span></span>
<span id="cb655-55"><a aria-hidden="true" href="#cb655-55" tabindex="-1"></a>   sys write<span class="co">; iopt+1; 64 " Write 64 words</span></span>
<span id="cb655-56"><a aria-hidden="true" href="#cb655-56" tabindex="-1"></a>   lac iopt              <span class="st">" Reset output pointer</span></span>
<span id="cb655-57"><a aria-hidden="true" href="#cb655-57" tabindex="-1"></a>   dac opt</span>
<span id="cb655-58"><a aria-hidden="true" href="#cb655-58" tabindex="-1"></a>   dzm noc               <span class="st">" Clear character count</span></span>
<span id="cb655-59"><a aria-hidden="true" href="#cb655-59" tabindex="-1"></a>   <span class="cf">jmp</span> putc i</span>
<span id="cb655-60"><a aria-hidden="true" href="#cb655-60" tabindex="-1"></a>2: 0<span class="co">;0</span></span>
<span id="cb655-61"><a aria-hidden="true" href="#cb655-61" tabindex="-1"></a></span>
<span id="cb655-62"><a aria-hidden="true" href="#cb655-62" tabindex="-1"></a><span class="fu">ipt:</span> 0                   " Input pointer</span>
<span id="cb655-63"><a aria-hidden="true" href="#cb655-63" tabindex="-1"></a><span class="fu">eipt:</span> 0                  " <span class="pp">End</span> of input buffer pointer</span>
<span id="cb655-64"><a aria-hidden="true" href="#cb655-64" tabindex="-1"></a><span class="fu">iipt:</span> .+1<span class="co">; .=.+64        " Input buffer (64 words)</span></span>
<span id="cb655-65"><a aria-hidden="true" href="#cb655-65" tabindex="-1"></a><span class="fu">fi:</span> 0                    " <span class="dt">File</span> descriptor</span>
<span id="cb655-66"><a aria-hidden="true" href="#cb655-66" tabindex="-1"></a><span class="fu">opt:</span> .+2                 " Output pointer</span>
<span id="cb655-67"><a aria-hidden="true" href="#cb655-67" tabindex="-1"></a><span class="fu">iopt:</span> .+1<span class="co">; .=.+64        " Output buffer (64 words)</span></span>
<span id="cb655-68"><a aria-hidden="true" href="#cb655-68" tabindex="-1"></a><span class="fu">noc:</span> 0                   " Number of output characters</span>
<span id="cb655-69"><a aria-hidden="true" href="#cb655-69" tabindex="-1"></a><span class="fu">fo:</span> 1                    " <span class="dt">File</span> descriptor for stdout</span>
<span id="cb655-70"><a aria-hidden="true" href="#cb655-70" tabindex="-1"></a></span>
<span id="cb655-71"><a aria-hidden="true" href="#cb655-71" tabindex="-1"></a><span class="fu">d1:</span> 1</span>
<span id="cb655-72"><a aria-hidden="true" href="#cb655-72" tabindex="-1"></a><span class="fu">o4:</span>d4<span class="op">:</span> <span class="dv">4</span></span>
<span id="cb655-73"><a aria-hidden="true" href="#cb655-73" tabindex="-1"></a><span class="fu">d8:</span> 8</span>
<span id="cb655-74"><a aria-hidden="true" href="#cb655-74" tabindex="-1"></a><span class="fu">o400000:</span> 0400000</span>
<span id="cb655-75"><a aria-hidden="true" href="#cb655-75" tabindex="-1"></a><span class="fu">o177:</span> 0177</span>
<span id="cb655-76"><a aria-hidden="true" href="#cb655-76" tabindex="-1"></a><span class="fu">d128:</span> 128</span></code></pre></div>
<h4 data-number="9.2.1.3" id="character-packing-deep-dive"><span class="header-section-number">9.2.1.3</span> Character Packing Deep
Dive</h4>
<p>The PDP-7 stored two 9-bit characters per 18-bit word. This code
brilliantly handles the packing:</p>
<p><strong>Getting a character (even position):</strong> 1. Load word:
<code>01234567 001234567</code> (two 9-bit chars) 2. Mask low 9 bits:
<code>000000000 001234567</code> 3. Result: right character</p>
<p><strong>Getting a character (odd position):</strong> 1. Load word:
<code>01234567 001234567</code> 2. Right shift 9:
<code>000000000 001234567</code> (discard low bits) 3. Result: left
character</p>
<p><strong>Putting a character (even position):</strong> 1. Character to
write: <code>001234567</code> 2. Shift left 9:
<code>01234567 000000000</code> 3. OR with existing: combines both
characters</p>
<p><strong>Putting a character (odd position):</strong> 1. Character
already in low 9 bits 2. XOR with existing word (sets high bits)</p>
<p>This is optimal PDP-7 assembly code‚Äîno wasted instructions.</p>
<h4 data-number="9.2.1.4" id="historical-note-cat-as-the-example-program"><span class="header-section-number">9.2.1.4</span> Historical Note: cat as the
Example Program</h4>
<p>In Dennis Ritchie‚Äôs Unix papers, cat is always the first program
shown. It‚Äôs the ‚ÄúHello World‚Äù of systems programming:</p>
<ul>
<li>Simple enough to understand in minutes</li>
<li>Complex enough to show real I/O patterns</li>
<li>Actually useful in daily work</li>
<li>Demonstrates Unix design principles</li>
</ul>
<p>The PDP-7 cat is 146 lines. Modern GNU cat is over 800 lines with
features like showing tabs, line numbers, and non-printing characters.
The PDP-7 version does one thing: copy files to output. Nothing
more.</p>
<h3 data-number="9.2.2" id="cp.s---copy-files"><span class="header-section-number">9.2.2</span> cp.s - Copy Files</h3>
<p><strong>Purpose:</strong> Copy one file to another</p>
<p><strong>Lines of Code:</strong> 97</p>
<p><strong>Why Copying Was Non-Trivial in 1969:</strong></p>
<p>Modern programmers take file copying for granted. In 1969, it was
challenging:</p>
<ul>
<li>No standard library functions</li>
<li>Must handle partial reads</li>
<li>Must create destination file with correct permissions</li>
<li>Limited memory means careful buffering</li>
<li>Errors must be reported but shouldn‚Äôt crash the system</li>
</ul>
<h4 data-number="9.2.2.1" id="complete-source-code-with-analysis-1"><span class="header-section-number">9.2.2.1</span> Complete Source Code with
Analysis</h4>
<div class="sourceCode" id="cb656"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb656-1"><a aria-hidden="true" href="#cb656-1" tabindex="-1"></a>" cp</span>
<span id="cb656-2"><a aria-hidden="true" href="#cb656-2" tabindex="-1"></a></span>
<span id="cb656-3"><a aria-hidden="true" href="#cb656-3" tabindex="-1"></a>   lac <span class="dv">017777</span>            <span class="st">" Get argument vector base</span></span>
<span id="cb656-4"><a aria-hidden="true" href="#cb656-4" tabindex="-1"></a>   tad d1</span>
<span id="cb656-5"><a aria-hidden="true" href="#cb656-5" tabindex="-1"></a>   dac name2             <span class="st">" Point to second filename</span></span>
<span id="cb656-6"><a aria-hidden="true" href="#cb656-6" tabindex="-1"></a><span class="fu">loop:</span></span>
<span id="cb656-7"><a aria-hidden="true" href="#cb656-7" tabindex="-1"></a>   lac <span class="dv">017777</span> i          <span class="st">" Get argument count</span></span>
<span id="cb656-8"><a aria-hidden="true" href="#cb656-8" tabindex="-1"></a>   sad d4                <span class="st">" Skip if exactly 4 (no args left)</span></span>
<span id="cb656-9"><a aria-hidden="true" href="#cb656-9" tabindex="-1"></a>   sys exit              <span class="st">" Done - exit cleanly</span></span>
<span id="cb656-10"><a aria-hidden="true" href="#cb656-10" tabindex="-1"></a>   sad d8                <span class="st">" Skip if different from 8</span></span>
<span id="cb656-11"><a aria-hidden="true" href="#cb656-11" tabindex="-1"></a>   <span class="cf">jmp</span> unbal             <span class="st">" Unbalanced arguments</span></span>
<span id="cb656-12"><a aria-hidden="true" href="#cb656-12" tabindex="-1"></a>   tad dm8               <span class="st">" Subtract 8 (two filenames)</span></span>
<span id="cb656-13"><a aria-hidden="true" href="#cb656-13" tabindex="-1"></a>   dac <span class="dv">017777</span> i</span>
<span id="cb656-14"><a aria-hidden="true" href="#cb656-14" tabindex="-1"></a>   lac name2             <span class="st">" Get filename pointer</span></span>
<span id="cb656-15"><a aria-hidden="true" href="#cb656-15" tabindex="-1"></a>   tad d4                <span class="st">" Advance past first name</span></span>
<span id="cb656-16"><a aria-hidden="true" href="#cb656-16" tabindex="-1"></a>   dac name1             <span class="st">" Source filename</span></span>
<span id="cb656-17"><a aria-hidden="true" href="#cb656-17" tabindex="-1"></a>   tad d4                <span class="st">" Advance to next pair</span></span>
<span id="cb656-18"><a aria-hidden="true" href="#cb656-18" tabindex="-1"></a>   dac name2             <span class="st">" Destination filename</span></span>
<span id="cb656-19"><a aria-hidden="true" href="#cb656-19" tabindex="-1"></a>   sys open<span class="co">; name1: 0; 0 " Open source file</span></span>
<span id="cb656-20"><a aria-hidden="true" href="#cb656-20" tabindex="-1"></a>   spa                   <span class="st">" Skip on positive (success)</span></span>
<span id="cb656-21"><a aria-hidden="true" href="#cb656-21" tabindex="-1"></a>   <span class="cf">jmp</span> error             <span class="st">" Can't open source</span></span>
<span id="cb656-22"><a aria-hidden="true" href="#cb656-22" tabindex="-1"></a>   lac o17               <span class="st">" Mode 017 (rw-rw-rw-)</span></span>
<span id="cb656-23"><a aria-hidden="true" href="#cb656-23" tabindex="-1"></a>   sys creat<span class="co">; name2: 0   " Create destination file</span></span>
<span id="cb656-24"><a aria-hidden="true" href="#cb656-24" tabindex="-1"></a>   spa                   <span class="st">" Skip on positive (success)</span></span>
<span id="cb656-25"><a aria-hidden="true" href="#cb656-25" tabindex="-1"></a>   <span class="cf">jmp</span> error             <span class="st">" Can't create destination</span></span>
<span id="cb656-26"><a aria-hidden="true" href="#cb656-26" tabindex="-1"></a>   dzm nin               <span class="st">" Clear bytes-read counter</span></span>
<span id="cb656-27"><a aria-hidden="true" href="#cb656-27" tabindex="-1"></a></span>
<span id="cb656-28"><a aria-hidden="true" href="#cb656-28" tabindex="-1"></a>1:</span>
<span id="cb656-29"><a aria-hidden="true" href="#cb656-29" tabindex="-1"></a>   lac bufp              <span class="st">" Get buffer address</span></span>
<span id="cb656-30"><a aria-hidden="true" href="#cb656-30" tabindex="-1"></a>   tad nin               <span class="st">" Add current position</span></span>
<span id="cb656-31"><a aria-hidden="true" href="#cb656-31" tabindex="-1"></a>   dac <span class="fl">0</span><span class="bn">f</span>                <span class="st">" Store as read address</span></span>
<span id="cb656-32"><a aria-hidden="true" href="#cb656-32" tabindex="-1"></a>   -1</span>
<span id="cb656-33"><a aria-hidden="true" href="#cb656-33" tabindex="-1"></a>   tad nin</span>
<span id="cb656-34"><a aria-hidden="true" href="#cb656-34" tabindex="-1"></a>   cma</span>
<span id="cb656-35"><a aria-hidden="true" href="#cb656-35" tabindex="-1"></a>   tad d1024             <span class="st">" Calculate remaining space</span></span>
<span id="cb656-36"><a aria-hidden="true" href="#cb656-36" tabindex="-1"></a>   dac <span class="fl">0</span><span class="bn">f</span><span class="op">+</span><span class="dv">1</span>              <span class="st">" Store as read count</span></span>
<span id="cb656-37"><a aria-hidden="true" href="#cb656-37" tabindex="-1"></a>   lac d2                <span class="st">" File descriptor 2 (source)</span></span>
<span id="cb656-38"><a aria-hidden="true" href="#cb656-38" tabindex="-1"></a>   sys read<span class="co">; 0:..;..     " Read up to 1024 words</span></span>
<span id="cb656-39"><a aria-hidden="true" href="#cb656-39" tabindex="-1"></a>   sna                   <span class="st">" Skip if non-zero (got data)</span></span>
<span id="cb656-40"><a aria-hidden="true" href="#cb656-40" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">2</span><span class="bn">f</span>                <span class="st">" EOF or error</span></span>
<span id="cb656-41"><a aria-hidden="true" href="#cb656-41" tabindex="-1"></a>   tad nin               <span class="st">" Add to total bytes read</span></span>
<span id="cb656-42"><a aria-hidden="true" href="#cb656-42" tabindex="-1"></a>   dac nin</span>
<span id="cb656-43"><a aria-hidden="true" href="#cb656-43" tabindex="-1"></a>   sad d1024             <span class="st">" Skip if didn't read full buffer</span></span>
<span id="cb656-44"><a aria-hidden="true" href="#cb656-44" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">2</span><span class="bn">f</span>                <span class="st">" Got less, must be EOF</span></span>
<span id="cb656-45"><a aria-hidden="true" href="#cb656-45" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span>                <span class="st">" Continue reading</span></span>
<span id="cb656-46"><a aria-hidden="true" href="#cb656-46" tabindex="-1"></a></span>
<span id="cb656-47"><a aria-hidden="true" href="#cb656-47" tabindex="-1"></a>2:</span>
<span id="cb656-48"><a aria-hidden="true" href="#cb656-48" tabindex="-1"></a>   lac nin               <span class="st">" Get total bytes read</span></span>
<span id="cb656-49"><a aria-hidden="true" href="#cb656-49" tabindex="-1"></a>   dac <span class="fl">2</span><span class="bn">f</span>                <span class="st">" Store as write count</span></span>
<span id="cb656-50"><a aria-hidden="true" href="#cb656-50" tabindex="-1"></a>   lac d3                <span class="st">" File descriptor 3 (destination)</span></span>
<span id="cb656-51"><a aria-hidden="true" href="#cb656-51" tabindex="-1"></a>   sys write<span class="co">; buf; 2: 0  " Write entire buffer</span></span>
<span id="cb656-52"><a aria-hidden="true" href="#cb656-52" tabindex="-1"></a>   dzm nin               <span class="st">" Reset counter</span></span>
<span id="cb656-53"><a aria-hidden="true" href="#cb656-53" tabindex="-1"></a>   lac <span class="dv">2</span><span class="er">b</span>                <span class="st">" Check if last read was partial</span></span>
<span id="cb656-54"><a aria-hidden="true" href="#cb656-54" tabindex="-1"></a>   sad d1024</span>
<span id="cb656-55"><a aria-hidden="true" href="#cb656-55" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span>                <span class="st">" Full read, get more data</span></span>
<span id="cb656-56"><a aria-hidden="true" href="#cb656-56" tabindex="-1"></a>   lac d2                <span class="st">" Partial read, done</span></span>
<span id="cb656-57"><a aria-hidden="true" href="#cb656-57" tabindex="-1"></a>   sys close             <span class="st">" Close source</span></span>
<span id="cb656-58"><a aria-hidden="true" href="#cb656-58" tabindex="-1"></a>   lac d3</span>
<span id="cb656-59"><a aria-hidden="true" href="#cb656-59" tabindex="-1"></a>   sys close             <span class="st">" Close destination</span></span>
<span id="cb656-60"><a aria-hidden="true" href="#cb656-60" tabindex="-1"></a>   <span class="cf">jmp</span> loop              <span class="st">" Process next file pair</span></span>
<span id="cb656-61"><a aria-hidden="true" href="#cb656-61" tabindex="-1"></a></span>
<span id="cb656-62"><a aria-hidden="true" href="#cb656-62" tabindex="-1"></a><span class="fu">error:</span></span>
<span id="cb656-63"><a aria-hidden="true" href="#cb656-63" tabindex="-1"></a>   lac name1             <span class="st">" Get source filename</span></span>
<span id="cb656-64"><a aria-hidden="true" href="#cb656-64" tabindex="-1"></a>   dac <span class="fl">1</span><span class="bn">f</span></span>
<span id="cb656-65"><a aria-hidden="true" href="#cb656-65" tabindex="-1"></a>   lac d1                <span class="st">" FD 1 (stdout)</span></span>
<span id="cb656-66"><a aria-hidden="true" href="#cb656-66" tabindex="-1"></a>   sys write<span class="co">; 1: 0; 4    " Write filename</span></span>
<span id="cb656-67"><a aria-hidden="true" href="#cb656-67" tabindex="-1"></a>   lac d1</span>
<span id="cb656-68"><a aria-hidden="true" href="#cb656-68" tabindex="-1"></a>   sys write<span class="co">; mes; 1     " Write error message "? \n"</span></span>
<span id="cb656-69"><a aria-hidden="true" href="#cb656-69" tabindex="-1"></a>   lac name2             <span class="st">" Get destination filename</span></span>
<span id="cb656-70"><a aria-hidden="true" href="#cb656-70" tabindex="-1"></a>   dac <span class="fl">1</span><span class="bn">f</span></span>
<span id="cb656-71"><a aria-hidden="true" href="#cb656-71" tabindex="-1"></a>   lac d1</span>
<span id="cb656-72"><a aria-hidden="true" href="#cb656-72" tabindex="-1"></a>   sys write<span class="co">; 1: 0; 4    " Write filename</span></span>
<span id="cb656-73"><a aria-hidden="true" href="#cb656-73" tabindex="-1"></a>   lac d1</span>
<span id="cb656-74"><a aria-hidden="true" href="#cb656-74" tabindex="-1"></a>   sys write<span class="co">; mes; 2     " Write error message</span></span>
<span id="cb656-75"><a aria-hidden="true" href="#cb656-75" tabindex="-1"></a>   <span class="cf">jmp</span> loop              <span class="st">" Continue with next pair</span></span>
<span id="cb656-76"><a aria-hidden="true" href="#cb656-76" tabindex="-1"></a></span>
<span id="cb656-77"><a aria-hidden="true" href="#cb656-77" tabindex="-1"></a><span class="fu">mes:</span></span>
<span id="cb656-78"><a aria-hidden="true" href="#cb656-78" tabindex="-1"></a>   040000<span class="co">;077012         " "? \n"</span></span>
<span id="cb656-79"><a aria-hidden="true" href="#cb656-79" tabindex="-1"></a></span>
<span id="cb656-80"><a aria-hidden="true" href="#cb656-80" tabindex="-1"></a><span class="fu">unbal:</span></span>
<span id="cb656-81"><a aria-hidden="true" href="#cb656-81" tabindex="-1"></a>   lac name2             <span class="st">" Unbalanced arguments error</span></span>
<span id="cb656-82"><a aria-hidden="true" href="#cb656-82" tabindex="-1"></a>   tad d4</span>
<span id="cb656-83"><a aria-hidden="true" href="#cb656-83" tabindex="-1"></a>   dac <span class="fl">1</span><span class="bn">f</span></span>
<span id="cb656-84"><a aria-hidden="true" href="#cb656-84" tabindex="-1"></a>   lac d1</span>
<span id="cb656-85"><a aria-hidden="true" href="#cb656-85" tabindex="-1"></a>   sys write<span class="co">; 1: 0; 4</span></span>
<span id="cb656-86"><a aria-hidden="true" href="#cb656-86" tabindex="-1"></a>   lac d1</span>
<span id="cb656-87"><a aria-hidden="true" href="#cb656-87" tabindex="-1"></a>   sys write<span class="co">; mes; 2</span></span>
<span id="cb656-88"><a aria-hidden="true" href="#cb656-88" tabindex="-1"></a>   sys exit</span>
<span id="cb656-89"><a aria-hidden="true" href="#cb656-89" tabindex="-1"></a></span>
<span id="cb656-90"><a aria-hidden="true" href="#cb656-90" tabindex="-1"></a><span class="fu">d1:</span> 1</span>
<span id="cb656-91"><a aria-hidden="true" href="#cb656-91" tabindex="-1"></a><span class="fu">d4:</span> 4</span>
<span id="cb656-92"><a aria-hidden="true" href="#cb656-92" tabindex="-1"></a><span class="fu">d8:</span> 8</span>
<span id="cb656-93"><a aria-hidden="true" href="#cb656-93" tabindex="-1"></a><span class="fu">o17:</span> 017</span>
<span id="cb656-94"><a aria-hidden="true" href="#cb656-94" tabindex="-1"></a><span class="fu">dm8:</span> -8</span>
<span id="cb656-95"><a aria-hidden="true" href="#cb656-95" tabindex="-1"></a><span class="fu">d3:</span> 3</span>
<span id="cb656-96"><a aria-hidden="true" href="#cb656-96" tabindex="-1"></a><span class="fu">d1024:</span> 1024</span>
<span id="cb656-97"><a aria-hidden="true" href="#cb656-97" tabindex="-1"></a><span class="fu">nin:</span> 0                   " Number of words read</span>
<span id="cb656-98"><a aria-hidden="true" href="#cb656-98" tabindex="-1"></a><span class="fu">bufp:</span> buf</span>
<span id="cb656-99"><a aria-hidden="true" href="#cb656-99" tabindex="-1"></a><span class="fu">d2:</span> 2</span>
<span id="cb656-100"><a aria-hidden="true" href="#cb656-100" tabindex="-1"></a></span>
<span id="cb656-101"><a aria-hidden="true" href="#cb656-101" tabindex="-1"></a><span class="fu">buf:</span>                     " Buffer allocated at end</span></code></pre></div>
<h4 data-number="9.2.2.2" id="the-buffering-strategy"><span class="header-section-number">9.2.2.2</span> The Buffering Strategy</h4>
<p>cp uses a 1024-word buffer (2048 bytes). This is massive by PDP-7
standards‚Äîroughly 25% of available memory! Why so large?</p>
<p><strong>Performance Calculation:</strong> - DECtape: 350 bytes/second
transfer rate - System call overhead: ~50 instructions - Small buffers:
system call overhead dominates - Large buffer: one call copies 2KB in 6
seconds</p>
<p>The math is brutal. With a 64-byte buffer, you‚Äôd make 32 system calls
per 2KB, wasting most of your time in kernel mode. The 2KB buffer
reduces this to one call, making copying 32√ó more efficient in syscall
overhead alone.</p>
<p><strong>Memory Usage:</strong> - Code: ~97 words - Buffer: 1024 words
- Total: ~1121 words (~2.2 KB)</p>
<p>This left ~6KB for the kernel and stack‚Äîtight but workable.</p>
<h4 data-number="9.2.2.3" id="error-handling-philosophy"><span class="header-section-number">9.2.2.3</span> Error Handling
Philosophy</h4>
<p>Notice the error handling: 1. Report the error (write filename and
‚Äú?‚Äù) 2. Continue processing remaining files 3. Never crash</p>
<p>This is quintessentially Unix: be robust, report problems, keep
going. A single bad file shouldn‚Äôt kill the entire copy operation.</p>
<h4 data-number="9.2.2.4" id="whats-missing-vs.-modern-cp"><span class="header-section-number">9.2.2.4</span> What‚Äôs Missing vs.¬†Modern
cp</h4>
<p>Modern GNU cp has: - Recursive directory copying (-r) - Preserve
permissions/timestamps (-p) - Interactive prompting (-i) - Symbolic link
handling (-s) - Progress reporting - Sparse file optimization - Reflink
support (COW filesystems)</p>
<p>PDP-7 cp has none of this. It copies one file to another. That‚Äôs all.
And that was enough.</p>
<h3 data-number="9.2.3" id="chmod.s---change-file-mode"><span class="header-section-number">9.2.3</span> chmod.s - Change File
Mode</h3>
<p><strong>Purpose:</strong> Change file permissions</p>
<p><strong>Lines of Code:</strong> 77</p>
<p><strong>The Birth of Unix File Permissions:</strong></p>
<p>The chmod utility embodies one of Unix‚Äôs most influential
innovations: the permission mode bits. In 1969, most systems had crude
access control‚Äîfiles were public or private. Unix introduced a
three-level permission model (owner, group, other) with three permission
types (read, write, execute) that would become universal.</p>
<h4 data-number="9.2.3.1" id="complete-source-code-with-analysis-2"><span class="header-section-number">9.2.3.1</span> Complete Source Code with
Analysis</h4>
<div class="sourceCode" id="cb657"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb657-1"><a aria-hidden="true" href="#cb657-1" tabindex="-1"></a>" chmode</span>
<span id="cb657-2"><a aria-hidden="true" href="#cb657-2" tabindex="-1"></a></span>
<span id="cb657-3"><a aria-hidden="true" href="#cb657-3" tabindex="-1"></a>   lac <span class="dv">017777</span> i          <span class="st">" Get argument count</span></span>
<span id="cb657-4"><a aria-hidden="true" href="#cb657-4" tabindex="-1"></a>   sad d4                <span class="st">" Skip if exactly 4 (no args)</span></span>
<span id="cb657-5"><a aria-hidden="true" href="#cb657-5" tabindex="-1"></a>   <span class="cf">jmp</span> error             <span class="st">" Need at least mode and one file</span></span>
<span id="cb657-6"><a aria-hidden="true" href="#cb657-6" tabindex="-1"></a></span>
<span id="cb657-7"><a aria-hidden="true" href="#cb657-7" tabindex="-1"></a>   lac <span class="dv">017777</span>            <span class="st">" Get argv base</span></span>
<span id="cb657-8"><a aria-hidden="true" href="#cb657-8" tabindex="-1"></a>   tad d4                <span class="st">" Point to argv[1] (mode string)</span></span>
<span id="cb657-9"><a aria-hidden="true" href="#cb657-9" tabindex="-1"></a>   dac <span class="dv">8</span></span>
<span id="cb657-10"><a aria-hidden="true" href="#cb657-10" tabindex="-1"></a>   tad d1                <span class="st">" Point to argv[2] (first filename)</span></span>
<span id="cb657-11"><a aria-hidden="true" href="#cb657-11" tabindex="-1"></a>   dac name</span>
<span id="cb657-12"><a aria-hidden="true" href="#cb657-12" tabindex="-1"></a>   dzm octal             <span class="st">" Clear octal accumulator</span></span>
<span id="cb657-13"><a aria-hidden="true" href="#cb657-13" tabindex="-1"></a>   dzm nchar             <span class="st">" Clear character buffer</span></span>
<span id="cb657-14"><a aria-hidden="true" href="#cb657-14" tabindex="-1"></a>   -8                    " Process up to <span class="dv">8</span> octal digits</span>
<span id="cb657-15"><a aria-hidden="true" href="#cb657-15" tabindex="-1"></a>   dac c1</span>
<span id="cb657-16"><a aria-hidden="true" href="#cb657-16" tabindex="-1"></a></span>
<span id="cb657-17"><a aria-hidden="true" href="#cb657-17" tabindex="-1"></a>1:</span>
<span id="cb657-18"><a aria-hidden="true" href="#cb657-18" tabindex="-1"></a>   lac nchar             <span class="st">" Load character buffer</span></span>
<span id="cb657-19"><a aria-hidden="true" href="#cb657-19" tabindex="-1"></a>   dzm nchar             <span class="st">" Clear it</span></span>
<span id="cb657-20"><a aria-hidden="true" href="#cb657-20" tabindex="-1"></a>   sza                   <span class="st">" Skip if was zero</span></span>
<span id="cb657-21"><a aria-hidden="true" href="#cb657-21" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">2</span><span class="bn">f</span>                <span class="st">" Use buffered character</span></span>
<span id="cb657-22"><a aria-hidden="true" href="#cb657-22" tabindex="-1"></a>   lac <span class="dv">8</span> i               <span class="st">" Load word from mode string</span></span>
<span id="cb657-23"><a aria-hidden="true" href="#cb657-23" tabindex="-1"></a>   lmq                   <span class="st">" Save to MQ</span></span>
<span id="cb657-24"><a aria-hidden="true" href="#cb657-24" tabindex="-1"></a>   <span class="bu">and</span> o177              <span class="st">" Get low 9 bits (one character)</span></span>
<span id="cb657-25"><a aria-hidden="true" href="#cb657-25" tabindex="-1"></a>   dac nchar             <span class="st">" Save character</span></span>
<span id="cb657-26"><a aria-hidden="true" href="#cb657-26" tabindex="-1"></a>   lacq                  <span class="st">" Restore word</span></span>
<span id="cb657-27"><a aria-hidden="true" href="#cb657-27" tabindex="-1"></a>   lrss <span class="dv">9</span>                <span class="st">" Shift right to get high character</span></span>
<span id="cb657-28"><a aria-hidden="true" href="#cb657-28" tabindex="-1"></a></span>
<span id="cb657-29"><a aria-hidden="true" href="#cb657-29" tabindex="-1"></a>2:</span>
<span id="cb657-30"><a aria-hidden="true" href="#cb657-30" tabindex="-1"></a>   sad o40               <span class="st">" Skip if different from space (040)</span></span>
<span id="cb657-31"><a aria-hidden="true" href="#cb657-31" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">3</span><span class="bn">f</span>                <span class="st">" Space - ignore it</span></span>
<span id="cb657-32"><a aria-hidden="true" href="#cb657-32" tabindex="-1"></a>   tad om60              <span class="st">" Subtract '0' (060 octal)</span></span>
<span id="cb657-33"><a aria-hidden="true" href="#cb657-33" tabindex="-1"></a>   lmq                   <span class="st">" Save digit in MQ</span></span>
<span id="cb657-34"><a aria-hidden="true" href="#cb657-34" tabindex="-1"></a>   lac octal             <span class="st">" Get current value</span></span>
<span id="cb657-35"><a aria-hidden="true" href="#cb657-35" tabindex="-1"></a>   cll<span class="co">; als 3            " Shift left 3 bits (multiply by 8)</span></span>
<span id="cb657-36"><a aria-hidden="true" href="#cb657-36" tabindex="-1"></a>   omq                   <span class="st">" OR in new digit</span></span>
<span id="cb657-37"><a aria-hidden="true" href="#cb657-37" tabindex="-1"></a>   dac octal             <span class="st">" Save result</span></span>
<span id="cb657-38"><a aria-hidden="true" href="#cb657-38" tabindex="-1"></a></span>
<span id="cb657-39"><a aria-hidden="true" href="#cb657-39" tabindex="-1"></a>3:</span>
<span id="cb657-40"><a aria-hidden="true" href="#cb657-40" tabindex="-1"></a>   isz c1                <span class="st">" Count characters processed</span></span>
<span id="cb657-41"><a aria-hidden="true" href="#cb657-41" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span>                <span class="st">" Continue parsing</span></span>
<span id="cb657-42"><a aria-hidden="true" href="#cb657-42" tabindex="-1"></a></span>
<span id="cb657-43"><a aria-hidden="true" href="#cb657-43" tabindex="-1"></a><span class="fu">loop:</span></span>
<span id="cb657-44"><a aria-hidden="true" href="#cb657-44" tabindex="-1"></a>   lac <span class="dv">017777</span> i          <span class="st">" Get argument count</span></span>
<span id="cb657-45"><a aria-hidden="true" href="#cb657-45" tabindex="-1"></a>   sad d8                <span class="st">" Skip if exactly 8 (no more files)</span></span>
<span id="cb657-46"><a aria-hidden="true" href="#cb657-46" tabindex="-1"></a>   sys exit              <span class="st">" Done</span></span>
<span id="cb657-47"><a aria-hidden="true" href="#cb657-47" tabindex="-1"></a>   tad dm4               <span class="st">" Subtract 4 (one filename)</span></span>
<span id="cb657-48"><a aria-hidden="true" href="#cb657-48" tabindex="-1"></a>   dac <span class="dv">017777</span> i</span>
<span id="cb657-49"><a aria-hidden="true" href="#cb657-49" tabindex="-1"></a>   lac name              <span class="st">" Advance to next filename</span></span>
<span id="cb657-50"><a aria-hidden="true" href="#cb657-50" tabindex="-1"></a>   tad d4</span>
<span id="cb657-51"><a aria-hidden="true" href="#cb657-51" tabindex="-1"></a>   dac name</span>
<span id="cb657-52"><a aria-hidden="true" href="#cb657-52" tabindex="-1"></a>   lac octal             <span class="st">" Get parsed mode</span></span>
<span id="cb657-53"><a aria-hidden="true" href="#cb657-53" tabindex="-1"></a>   sys chmode<span class="co">; name:0    " Change file mode</span></span>
<span id="cb657-54"><a aria-hidden="true" href="#cb657-54" tabindex="-1"></a>   sma                   <span class="st">" Skip if minus (error)</span></span>
<span id="cb657-55"><a aria-hidden="true" href="#cb657-55" tabindex="-1"></a>   <span class="cf">jmp</span> loop              <span class="st">" Success, continue</span></span>
<span id="cb657-56"><a aria-hidden="true" href="#cb657-56" tabindex="-1"></a>   lac name              <span class="st">" Error - print filename</span></span>
<span id="cb657-57"><a aria-hidden="true" href="#cb657-57" tabindex="-1"></a>   dac <span class="fl">1</span><span class="bn">f</span></span>
<span id="cb657-58"><a aria-hidden="true" href="#cb657-58" tabindex="-1"></a>   lac d1</span>
<span id="cb657-59"><a aria-hidden="true" href="#cb657-59" tabindex="-1"></a>   sys write<span class="co">; 1:0; 4</span></span>
<span id="cb657-60"><a aria-hidden="true" href="#cb657-60" tabindex="-1"></a>   lac d1</span>
<span id="cb657-61"><a aria-hidden="true" href="#cb657-61" tabindex="-1"></a>   sys write<span class="co">; 1f; 2      " Print "? \n"</span></span>
<span id="cb657-62"><a aria-hidden="true" href="#cb657-62" tabindex="-1"></a>   <span class="cf">jmp</span> loop</span>
<span id="cb657-63"><a aria-hidden="true" href="#cb657-63" tabindex="-1"></a></span>
<span id="cb657-64"><a aria-hidden="true" href="#cb657-64" tabindex="-1"></a>1:</span>
<span id="cb657-65"><a aria-hidden="true" href="#cb657-65" tabindex="-1"></a>   040<span class="co">;077012            " "? \n"</span></span>
<span id="cb657-66"><a aria-hidden="true" href="#cb657-66" tabindex="-1"></a></span>
<span id="cb657-67"><a aria-hidden="true" href="#cb657-67" tabindex="-1"></a><span class="fu">error:</span></span>
<span id="cb657-68"><a aria-hidden="true" href="#cb657-68" tabindex="-1"></a>   lac d1</span>
<span id="cb657-69"><a aria-hidden="true" href="#cb657-69" tabindex="-1"></a>   sys write<span class="co">; 1b+1; 1    " Print error and exit</span></span>
<span id="cb657-70"><a aria-hidden="true" href="#cb657-70" tabindex="-1"></a>   sys exit</span>
<span id="cb657-71"><a aria-hidden="true" href="#cb657-71" tabindex="-1"></a></span>
<span id="cb657-72"><a aria-hidden="true" href="#cb657-72" tabindex="-1"></a><span class="fu">om60:</span> -060               " -'0'</span>
<span id="cb657-73"><a aria-hidden="true" href="#cb657-73" tabindex="-1"></a><span class="fu">o40:</span> 040                 " Space</span>
<span id="cb657-74"><a aria-hidden="true" href="#cb657-74" tabindex="-1"></a><span class="fu">d1:</span> 1</span>
<span id="cb657-75"><a aria-hidden="true" href="#cb657-75" tabindex="-1"></a><span class="fu">d8:</span> 8</span>
<span id="cb657-76"><a aria-hidden="true" href="#cb657-76" tabindex="-1"></a><span class="fu">dm4:</span> -4</span>
<span id="cb657-77"><a aria-hidden="true" href="#cb657-77" tabindex="-1"></a><span class="fu">d4:</span> 4</span>
<span id="cb657-78"><a aria-hidden="true" href="#cb657-78" tabindex="-1"></a><span class="fu">o177:</span> 0177</span>
<span id="cb657-79"><a aria-hidden="true" href="#cb657-79" tabindex="-1"></a></span>
<span id="cb657-80"><a aria-hidden="true" href="#cb657-80" tabindex="-1"></a><span class="fu">nchar:</span> .=.+1             " Character buffer</span>
<span id="cb657-81"><a aria-hidden="true" href="#cb657-81" tabindex="-1"></a><span class="fu">c1:</span> .=.+1                " Counter</span>
<span id="cb657-82"><a aria-hidden="true" href="#cb657-82" tabindex="-1"></a><span class="fu">octal:</span> .=.+1             " Octal accumulator</span></code></pre></div>
<h4 data-number="9.2.3.2" id="octal-parsing-algorithm"><span class="header-section-number">9.2.3.2</span> Octal Parsing
Algorithm</h4>
<p>The octal parsing is elegant in its simplicity:</p>
<pre><code>Input: "755"
Step 1: Parse '7'
  - Subtract '0': 7
  - Shift accumulator left 3 bits: 0 ‚Üí 0
  - OR in 7: 0 | 7 = 7 (binary: 111)

Step 2: Parse '5'
  - Subtract '0': 5
  - Shift accumulator left 3 bits: 7 ‚Üí 56 (binary: 111000)
  - OR in 5: 56 | 5 = 61 (binary: 111101)

Step 3: Parse '5'
  - Subtract '0': 5
  - Shift accumulator left 3 bits: 61 ‚Üí 488 (binary: 111101000)
  - OR in 5: 488 | 5 = 493 (binary: 111101101)

Result: 0755 octal = 493 decimal = 111101101 binary
         rwxr-xr-x</code></pre>
<p>Each octal digit represents exactly 3 permission bits: - 7 (111):
read + write + execute - 5 (101): read + execute - 4 (100): read
only</p>
<h4 data-number="9.2.3.3" id="permission-bit-layout-1"><span class="header-section-number">9.2.3.3</span> Permission Bit Layout</h4>
<p>On PDP-7 Unix, the mode bits were:</p>
<pre><code>Bit 0-2: Other permissions (---rwx)
Bit 3-5: Group permissions (rwx---)
Bit 6-8: Owner permissions (rwx---)
Bit 9:   Set-UID bit
Bit 10:  Large file bit
Bit 11:  Directory bit</code></pre>
<p>So mode 0755:</p>
<pre><code>Binary: 111 101 101
        rwx r-x r-x
        Owner can read, write, execute
        Group can read and execute
        Other can read and execute</code></pre>
<h4 data-number="9.2.3.4" id="historical-context-revolutionary-access-control"><span class="header-section-number">9.2.3.4</span> Historical Context:
Revolutionary Access Control</h4>
<p>Before Unix, access control was typically: - <strong>CTSS:</strong>
Owner vs.¬†non-owner - <strong>Multics:</strong> Complex ACLs (Access
Control Lists) - <strong>Batch systems:</strong> No file protection at
all</p>
<p>Unix struck a balance: - Simple enough to understand instantly -
Powerful enough for real security needs - Fast to check (just bit
masking) - Compact (fits in a few bits)</p>
<p>This model was so successful that it spread to: - Every Unix variant
- Linux - macOS - Android - Embedded systems</p>
<p>Billions of devices now use the permission model that was born in
these 77 lines of PDP-7 assembly.</p>
<h3 data-number="9.2.4" id="chown.s---change-owner"><span class="header-section-number">9.2.4</span> chown.s - Change Owner</h3>
<p><strong>Purpose:</strong> Change file ownership</p>
<p><strong>Lines of Code:</strong> 78</p>
<p><strong>Multi-User System Concepts:</strong></p>
<p>chown is nearly identical to chmod in implementation, but
conceptually it represents something profound: Unix was designed from
day one as a multi-user system. On a machine that was basically a
personal workstation for two people (Thompson and Ritchie), they built
infrastructure for user IDs, ownership, and access control.</p>
<h4 data-number="9.2.4.1" id="complete-source-code"><span class="header-section-number">9.2.4.1</span> Complete Source Code</h4>
<div class="sourceCode" id="cb661"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb661-1"><a aria-hidden="true" href="#cb661-1" tabindex="-1"></a>" chowner</span>
<span id="cb661-2"><a aria-hidden="true" href="#cb661-2" tabindex="-1"></a></span>
<span id="cb661-3"><a aria-hidden="true" href="#cb661-3" tabindex="-1"></a>   lac <span class="dv">017777</span> i          <span class="st">" Get argument count</span></span>
<span id="cb661-4"><a aria-hidden="true" href="#cb661-4" tabindex="-1"></a>   sad d4                <span class="st">" Skip if exactly 4</span></span>
<span id="cb661-5"><a aria-hidden="true" href="#cb661-5" tabindex="-1"></a>   <span class="cf">jmp</span> error             <span class="st">" Need at least UID and one file</span></span>
<span id="cb661-6"><a aria-hidden="true" href="#cb661-6" tabindex="-1"></a></span>
<span id="cb661-7"><a aria-hidden="true" href="#cb661-7" tabindex="-1"></a>   lac <span class="dv">017777</span>            <span class="st">" Get argv base</span></span>
<span id="cb661-8"><a aria-hidden="true" href="#cb661-8" tabindex="-1"></a>   tad d4                <span class="st">" Point to argv[1] (UID string)</span></span>
<span id="cb661-9"><a aria-hidden="true" href="#cb661-9" tabindex="-1"></a>   dac <span class="dv">8</span></span>
<span id="cb661-10"><a aria-hidden="true" href="#cb661-10" tabindex="-1"></a>   tad d1                <span class="st">" Point to argv[2] (first filename)</span></span>
<span id="cb661-11"><a aria-hidden="true" href="#cb661-11" tabindex="-1"></a>   dac name</span>
<span id="cb661-12"><a aria-hidden="true" href="#cb661-12" tabindex="-1"></a>   dzm octal             <span class="st">" Clear octal accumulator</span></span>
<span id="cb661-13"><a aria-hidden="true" href="#cb661-13" tabindex="-1"></a>   dzm nchar             <span class="st">" Clear character buffer</span></span>
<span id="cb661-14"><a aria-hidden="true" href="#cb661-14" tabindex="-1"></a>   -8                    " Process up to <span class="dv">8</span> octal digits</span>
<span id="cb661-15"><a aria-hidden="true" href="#cb661-15" tabindex="-1"></a>   dac c1</span>
<span id="cb661-16"><a aria-hidden="true" href="#cb661-16" tabindex="-1"></a></span>
<span id="cb661-17"><a aria-hidden="true" href="#cb661-17" tabindex="-1"></a>1:</span>
<span id="cb661-18"><a aria-hidden="true" href="#cb661-18" tabindex="-1"></a>   lac nchar             <span class="st">" Same parsing logic as chmod</span></span>
<span id="cb661-19"><a aria-hidden="true" href="#cb661-19" tabindex="-1"></a>   dzm nchar</span>
<span id="cb661-20"><a aria-hidden="true" href="#cb661-20" tabindex="-1"></a>   sza</span>
<span id="cb661-21"><a aria-hidden="true" href="#cb661-21" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">2</span><span class="bn">f</span></span>
<span id="cb661-22"><a aria-hidden="true" href="#cb661-22" tabindex="-1"></a>   lac <span class="dv">8</span> i</span>
<span id="cb661-23"><a aria-hidden="true" href="#cb661-23" tabindex="-1"></a>   lmq</span>
<span id="cb661-24"><a aria-hidden="true" href="#cb661-24" tabindex="-1"></a>   <span class="bu">and</span> o177</span>
<span id="cb661-25"><a aria-hidden="true" href="#cb661-25" tabindex="-1"></a>   dac nchar</span>
<span id="cb661-26"><a aria-hidden="true" href="#cb661-26" tabindex="-1"></a>   lacq</span>
<span id="cb661-27"><a aria-hidden="true" href="#cb661-27" tabindex="-1"></a>   lrss <span class="dv">9</span></span>
<span id="cb661-28"><a aria-hidden="true" href="#cb661-28" tabindex="-1"></a></span>
<span id="cb661-29"><a aria-hidden="true" href="#cb661-29" tabindex="-1"></a>2:</span>
<span id="cb661-30"><a aria-hidden="true" href="#cb661-30" tabindex="-1"></a>   sad o40               <span class="st">" Skip spaces</span></span>
<span id="cb661-31"><a aria-hidden="true" href="#cb661-31" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">3</span><span class="bn">f</span></span>
<span id="cb661-32"><a aria-hidden="true" href="#cb661-32" tabindex="-1"></a>   tad om60              <span class="st">" Convert ASCII to octal</span></span>
<span id="cb661-33"><a aria-hidden="true" href="#cb661-33" tabindex="-1"></a>   lmq</span>
<span id="cb661-34"><a aria-hidden="true" href="#cb661-34" tabindex="-1"></a>   lac octal</span>
<span id="cb661-35"><a aria-hidden="true" href="#cb661-35" tabindex="-1"></a>   cll<span class="co">; als 3            " Shift left 3 (multiply by 8)</span></span>
<span id="cb661-36"><a aria-hidden="true" href="#cb661-36" tabindex="-1"></a>   omq                   <span class="st">" OR in digit</span></span>
<span id="cb661-37"><a aria-hidden="true" href="#cb661-37" tabindex="-1"></a>   dac octal</span>
<span id="cb661-38"><a aria-hidden="true" href="#cb661-38" tabindex="-1"></a></span>
<span id="cb661-39"><a aria-hidden="true" href="#cb661-39" tabindex="-1"></a>3:</span>
<span id="cb661-40"><a aria-hidden="true" href="#cb661-40" tabindex="-1"></a>   isz c1</span>
<span id="cb661-41"><a aria-hidden="true" href="#cb661-41" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span></span>
<span id="cb661-42"><a aria-hidden="true" href="#cb661-42" tabindex="-1"></a></span>
<span id="cb661-43"><a aria-hidden="true" href="#cb661-43" tabindex="-1"></a><span class="fu">loop:</span></span>
<span id="cb661-44"><a aria-hidden="true" href="#cb661-44" tabindex="-1"></a>   lac <span class="dv">017777</span> i          <span class="st">" Get argument count</span></span>
<span id="cb661-45"><a aria-hidden="true" href="#cb661-45" tabindex="-1"></a>   sad d8                <span class="st">" Skip if no more files</span></span>
<span id="cb661-46"><a aria-hidden="true" href="#cb661-46" tabindex="-1"></a>   sys exit</span>
<span id="cb661-47"><a aria-hidden="true" href="#cb661-47" tabindex="-1"></a>   tad dm4               <span class="st">" Subtract 4</span></span>
<span id="cb661-48"><a aria-hidden="true" href="#cb661-48" tabindex="-1"></a>   dac <span class="dv">017777</span> i</span>
<span id="cb661-49"><a aria-hidden="true" href="#cb661-49" tabindex="-1"></a>   lac name              <span class="st">" Advance to next filename</span></span>
<span id="cb661-50"><a aria-hidden="true" href="#cb661-50" tabindex="-1"></a>   tad d4</span>
<span id="cb661-51"><a aria-hidden="true" href="#cb661-51" tabindex="-1"></a>   dac name</span>
<span id="cb661-52"><a aria-hidden="true" href="#cb661-52" tabindex="-1"></a>   lac octal             <span class="st">" Get parsed UID</span></span>
<span id="cb661-53"><a aria-hidden="true" href="#cb661-53" tabindex="-1"></a>   sys chowner<span class="co">; name:0   " Change file owner</span></span>
<span id="cb661-54"><a aria-hidden="true" href="#cb661-54" tabindex="-1"></a>   sma                   <span class="st">" Skip on minus (error)</span></span>
<span id="cb661-55"><a aria-hidden="true" href="#cb661-55" tabindex="-1"></a>   <span class="cf">jmp</span> loop</span>
<span id="cb661-56"><a aria-hidden="true" href="#cb661-56" tabindex="-1"></a>   lac name              <span class="st">" Error handling</span></span>
<span id="cb661-57"><a aria-hidden="true" href="#cb661-57" tabindex="-1"></a>   dac <span class="fl">1</span><span class="bn">f</span></span>
<span id="cb661-58"><a aria-hidden="true" href="#cb661-58" tabindex="-1"></a>   lac d1</span>
<span id="cb661-59"><a aria-hidden="true" href="#cb661-59" tabindex="-1"></a>   sys write<span class="co">; 1:0; 4</span></span>
<span id="cb661-60"><a aria-hidden="true" href="#cb661-60" tabindex="-1"></a>   lac d1</span>
<span id="cb661-61"><a aria-hidden="true" href="#cb661-61" tabindex="-1"></a>   sys write<span class="co">; 1f; 2</span></span>
<span id="cb661-62"><a aria-hidden="true" href="#cb661-62" tabindex="-1"></a>   <span class="cf">jmp</span> loop</span>
<span id="cb661-63"><a aria-hidden="true" href="#cb661-63" tabindex="-1"></a></span>
<span id="cb661-64"><a aria-hidden="true" href="#cb661-64" tabindex="-1"></a>1:</span>
<span id="cb661-65"><a aria-hidden="true" href="#cb661-65" tabindex="-1"></a>   040<span class="co">;077012</span></span>
<span id="cb661-66"><a aria-hidden="true" href="#cb661-66" tabindex="-1"></a></span>
<span id="cb661-67"><a aria-hidden="true" href="#cb661-67" tabindex="-1"></a><span class="fu">error:</span></span>
<span id="cb661-68"><a aria-hidden="true" href="#cb661-68" tabindex="-1"></a>   lac d1</span>
<span id="cb661-69"><a aria-hidden="true" href="#cb661-69" tabindex="-1"></a>   sys write<span class="co">; 1b+1; 1</span></span>
<span id="cb661-70"><a aria-hidden="true" href="#cb661-70" tabindex="-1"></a>   sys exit</span>
<span id="cb661-71"><a aria-hidden="true" href="#cb661-71" tabindex="-1"></a></span>
<span id="cb661-72"><a aria-hidden="true" href="#cb661-72" tabindex="-1"></a><span class="fu">om60:</span> -060</span>
<span id="cb661-73"><a aria-hidden="true" href="#cb661-73" tabindex="-1"></a><span class="fu">o40:</span> 040</span>
<span id="cb661-74"><a aria-hidden="true" href="#cb661-74" tabindex="-1"></a><span class="fu">d1:</span> 1</span>
<span id="cb661-75"><a aria-hidden="true" href="#cb661-75" tabindex="-1"></a><span class="fu">d8:</span> 8</span>
<span id="cb661-76"><a aria-hidden="true" href="#cb661-76" tabindex="-1"></a><span class="fu">dm4:</span> -4</span>
<span id="cb661-77"><a aria-hidden="true" href="#cb661-77" tabindex="-1"></a><span class="fu">d4:</span> 4</span>
<span id="cb661-78"><a aria-hidden="true" href="#cb661-78" tabindex="-1"></a><span class="fu">o177:</span> 0177</span>
<span id="cb661-79"><a aria-hidden="true" href="#cb661-79" tabindex="-1"></a></span>
<span id="cb661-80"><a aria-hidden="true" href="#cb661-80" tabindex="-1"></a><span class="fu">nchar:</span> .=.+1</span>
<span id="cb661-81"><a aria-hidden="true" href="#cb661-81" tabindex="-1"></a><span class="fu">c1:</span> .=.+1</span>
<span id="cb661-82"><a aria-hidden="true" href="#cb661-82" tabindex="-1"></a><span class="fu">octal:</span> .=.+1</span></code></pre></div>
<h4 data-number="9.2.4.2" id="code-reuse-through-copying"><span class="header-section-number">9.2.4.2</span> Code Reuse Through
Copying</h4>
<p>Notice that chmod.s and chown.s are nearly identical‚Äîonly the system
call differs (chmode vs.¬†chowner). Modern programmers might write a
shared library or template. In 1969:</p>
<ul>
<li>No linker sophisticated enough for shared libraries</li>
<li>No macro system for code reuse</li>
<li>No C language yet (this is assembly)</li>
<li>Solution: Copy and modify</li>
</ul>
<p>This was pragmatic. The duplication cost: - 77 lines for chmod - 78
lines for chown - Total: 155 lines</p>
<p>A shared parsing library might have been: - 50 lines of parsing code
- 30 lines for chmod - 30 lines for chown - 20 lines of calling
convention - Total: 130 lines</p>
<p>The ‚Äúsavings‚Äù of 25 lines wasn‚Äôt worth the complexity of linking and
calling conventions. Just copy it.</p>
<h4 data-number="9.2.4.3" id="user-id-system"><span class="header-section-number">9.2.4.3</span> User ID System</h4>
<p>The user ID (UID) was stored in the inode:</p>
<pre><code>Inode structure (12 words):
Word 0:  Flags and type
Word 1:  Number of links
Word 2:  User ID (8 bits used)
Word 3:  Size (high byte)
Word 4:  Size (low word)
Word 5-11: Block addresses</code></pre>
<p>User IDs were 8-bit values (0-255), though only a handful were used:
- 0: Root (super-user) - 1: dmr (Dennis M. Ritchie) - 2: ken (Ken
Thompson) - 3-255: Available for future users</p>
<p>The super-user (UID 0) could change any file‚Äôs owner. Regular users
could not. This root/user distinction has persisted in Unix for 55+
years.</p>
<h3 data-number="9.2.5" id="chrm.s---changeremove-utility"><span class="header-section-number">9.2.5</span> chrm.s - Change/Remove
Utility</h3>
<p><strong>Purpose:</strong> Change directory and remove files</p>
<p><strong>Lines of Code:</strong> 41</p>
<p><strong>The Simplest Utility:</strong></p>
<p>chrm is the shortest utility in PDP-7 Unix. It demonstrates the Unix
philosophy in its purest form: do one thing, do it simply.</p>
<h4 data-number="9.2.5.1" id="complete-source-code-with-analysis-3"><span class="header-section-number">9.2.5.1</span> Complete Source Code with
Analysis</h4>
<div class="sourceCode" id="cb663"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb663-1"><a aria-hidden="true" href="#cb663-1" tabindex="-1"></a>" chrm</span>
<span id="cb663-2"><a aria-hidden="true" href="#cb663-2" tabindex="-1"></a></span>
<span id="cb663-3"><a aria-hidden="true" href="#cb663-3" tabindex="-1"></a>   lac <span class="dv">017777</span>            <span class="st">" Get argv base</span></span>
<span id="cb663-4"><a aria-hidden="true" href="#cb663-4" tabindex="-1"></a>   tad d5                <span class="st">" Skip past argv[0] and argv[1]</span></span>
<span id="cb663-5"><a aria-hidden="true" href="#cb663-5" tabindex="-1"></a>   dac <span class="fl">1</span><span class="bn">f</span>                <span class="st">" Save as directory name pointer</span></span>
<span id="cb663-6"><a aria-hidden="true" href="#cb663-6" tabindex="-1"></a>   dac <span class="fl">2</span><span class="bn">f</span>                <span class="st">" Save as filename pointer</span></span>
<span id="cb663-7"><a aria-hidden="true" href="#cb663-7" tabindex="-1"></a>   lac <span class="dv">017777</span> i          <span class="st">" Get argument count</span></span>
<span id="cb663-8"><a aria-hidden="true" href="#cb663-8" tabindex="-1"></a>   sad d4                <span class="st">" Skip if exactly 4 (no args)</span></span>
<span id="cb663-9"><a aria-hidden="true" href="#cb663-9" tabindex="-1"></a>   sys exit              <span class="st">" Need at least directory</span></span>
<span id="cb663-10"><a aria-hidden="true" href="#cb663-10" tabindex="-1"></a>   tad dm4               <span class="st">" Subtract 4 (directory name)</span></span>
<span id="cb663-11"><a aria-hidden="true" href="#cb663-11" tabindex="-1"></a>   dac <span class="dv">017777</span> i</span>
<span id="cb663-12"><a aria-hidden="true" href="#cb663-12" tabindex="-1"></a>   sys chdir<span class="co">; dd         " Change to root directory first</span></span>
<span id="cb663-13"><a aria-hidden="true" href="#cb663-13" tabindex="-1"></a>   sys chdir<span class="co">; 1;0        " Then change to specified directory</span></span>
<span id="cb663-14"><a aria-hidden="true" href="#cb663-14" tabindex="-1"></a></span>
<span id="cb663-15"><a aria-hidden="true" href="#cb663-15" tabindex="-1"></a>1:</span>
<span id="cb663-16"><a aria-hidden="true" href="#cb663-16" tabindex="-1"></a>   lac <span class="dv">017777</span> i          <span class="st">" Get remaining argument count</span></span>
<span id="cb663-17"><a aria-hidden="true" href="#cb663-17" tabindex="-1"></a>   sad d4                <span class="st">" Skip if no more files</span></span>
<span id="cb663-18"><a aria-hidden="true" href="#cb663-18" tabindex="-1"></a>   sys exit</span>
<span id="cb663-19"><a aria-hidden="true" href="#cb663-19" tabindex="-1"></a>   tad dm4               <span class="st">" Subtract 4 (one filename)</span></span>
<span id="cb663-20"><a aria-hidden="true" href="#cb663-20" tabindex="-1"></a>   dac <span class="dv">017777</span> i</span>
<span id="cb663-21"><a aria-hidden="true" href="#cb663-21" tabindex="-1"></a>   lac <span class="fl">2</span><span class="bn">f</span>                <span class="st">" Get filename pointer</span></span>
<span id="cb663-22"><a aria-hidden="true" href="#cb663-22" tabindex="-1"></a>   tad d4                <span class="st">" Advance it</span></span>
<span id="cb663-23"><a aria-hidden="true" href="#cb663-23" tabindex="-1"></a>   dac <span class="fl">2</span><span class="bn">f</span></span>
<span id="cb663-24"><a aria-hidden="true" href="#cb663-24" tabindex="-1"></a>   sys unlink<span class="co">; 2:0       " Unlink (delete) the file</span></span>
<span id="cb663-25"><a aria-hidden="true" href="#cb663-25" tabindex="-1"></a>   sma                   <span class="st">" Skip if minus (error)</span></span>
<span id="cb663-26"><a aria-hidden="true" href="#cb663-26" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span>                <span class="st">" Success, continue</span></span>
<span id="cb663-27"><a aria-hidden="true" href="#cb663-27" tabindex="-1"></a>   lac <span class="dv">2</span><span class="er">b</span>                <span class="st">" Error - print filename</span></span>
<span id="cb663-28"><a aria-hidden="true" href="#cb663-28" tabindex="-1"></a>   dac <span class="fl">2</span><span class="bn">f</span></span>
<span id="cb663-29"><a aria-hidden="true" href="#cb663-29" tabindex="-1"></a>   lac d1</span>
<span id="cb663-30"><a aria-hidden="true" href="#cb663-30" tabindex="-1"></a>   sys write<span class="co">; 2:0; 4</span></span>
<span id="cb663-31"><a aria-hidden="true" href="#cb663-31" tabindex="-1"></a>   lac d1</span>
<span id="cb663-32"><a aria-hidden="true" href="#cb663-32" tabindex="-1"></a>   sys write<span class="co">; 1f; 2      " Print error message</span></span>
<span id="cb663-33"><a aria-hidden="true" href="#cb663-33" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span>                <span class="st">" Continue</span></span>
<span id="cb663-34"><a aria-hidden="true" href="#cb663-34" tabindex="-1"></a></span>
<span id="cb663-35"><a aria-hidden="true" href="#cb663-35" tabindex="-1"></a>1:</span>
<span id="cb663-36"><a aria-hidden="true" href="#cb663-36" tabindex="-1"></a>   040077<span class="co">;012000         " Error message "? \n"</span></span>
<span id="cb663-37"><a aria-hidden="true" href="#cb663-37" tabindex="-1"></a></span>
<span id="cb663-38"><a aria-hidden="true" href="#cb663-38" tabindex="-1"></a><span class="fu">dd:</span></span>
<span id="cb663-39"><a aria-hidden="true" href="#cb663-39" tabindex="-1"></a>   &lt;<span class="dt">dd</span><span class="op">&gt;</span><span class="co">;040040;040040;040040  " Root directory name</span></span>
<span id="cb663-40"><a aria-hidden="true" href="#cb663-40" tabindex="-1"></a></span>
<span id="cb663-41"><a aria-hidden="true" href="#cb663-41" tabindex="-1"></a><span class="fu">d1:</span> 1</span>
<span id="cb663-42"><a aria-hidden="true" href="#cb663-42" tabindex="-1"></a><span class="fu">d4:</span> 4</span>
<span id="cb663-43"><a aria-hidden="true" href="#cb663-43" tabindex="-1"></a><span class="fu">d5:</span> 5</span>
<span id="cb663-44"><a aria-hidden="true" href="#cb663-44" tabindex="-1"></a><span class="fu">dm4:</span> -4</span></code></pre></div>
<h4 data-number="9.2.5.2" id="why-change-directory-first"><span class="header-section-number">9.2.5.2</span> Why Change Directory
First?</h4>
<p>The chdir before unlink is crucial. It allows removing files with
simple names:</p>
<pre><code>Without chdir:
  chrm /dd/dir1 /dd/dir1/file1 /dd/dir1/file2
  Must specify full paths for each file

With chdir:
  chrm dir1 file1 file2
  Much simpler</code></pre>
<p>The ‚Äúdd‚Äù directory is the root. The code does: 1. chdir to /dd (root)
2. chdir to user-specified directory 3. unlink each file in that
directory</p>
<h4 data-number="9.2.5.3" id="design-question-why-not-just-rm"><span class="header-section-number">9.2.5.3</span> Design Question: Why Not
Just rm?</h4>
<p>Modern Unix has separate commands: - cd - change directory - rm -
remove files</p>
<p>PDP-7 Unix combined them into chrm. Why?</p>
<p><strong>Memory Economics:</strong> - cd alone: ~20 lines - rm alone:
~30 lines - Both separate: 50 lines - Combined: 41 lines - Savings: 9
lines</p>
<p>But more importantly: - Two separate commands: two executable files -
Each file needs inode, directory entry, disk blocks - Minimum overhead:
1 block (64 words) per command - Combined: save 64 words of disk</p>
<p>With a 64KB filesystem, every block mattered.</p>
<h4 data-number="9.2.5.4" id="the-dd-convention"><span class="header-section-number">9.2.5.4</span> The ‚Äúdd‚Äù Convention</h4>
<p>Notice the hardcoded ‚Äúdd‚Äù directory name. This was the root directory
on PDP-7 Unix. Later Unix systems used ‚Äú/‚Äù as root, but PDP-7 used a
two-character directory name.</p>
<p>The dd directory was special: - Always inode 41 (fixed location) -
Contained all top-level directories - User directories were inside
dd</p>
<p>So a full path looked like:</p>
<pre><code>/dd/dmr/file.txt
    ^^^ root
        ^^^ user directory
            ^^^^^^^^ file</code></pre>
<p>This is why the code does two chdir calls: first to dd (root), then
to the user-specified subdirectory.</p>
<h2 data-number="9.3" id="system-utilities"><span class="header-section-number">9.3</span> 11.3 System Utilities</h2>
<h3 data-number="9.3.1" id="check.s---file-system-checker"><span class="header-section-number">9.3.1</span> check.s - File System
Checker</h3>
<p><strong>Purpose:</strong> Verify filesystem integrity and detect
corruption</p>
<p><strong>Lines of Code:</strong> 324</p>
<p><strong>Why Filesystem Checking Was Critical:</strong></p>
<p>DECtape was notoriously unreliable. Power failures, mechanical
issues, and software bugs could corrupt the filesystem. The check
utility was essential:</p>
<ul>
<li>Run at boot to verify filesystem integrity</li>
<li>Detect duplicate block allocation (fatal error)</li>
<li>Find lost blocks (allocated but not in any file)</li>
<li>Count inodes and blocks</li>
<li>Repair some types of corruption</li>
</ul>
<p>This is the ancestor of fsck, one of Unix‚Äôs most important system
utilities.</p>
<h4 data-number="9.3.1.1" id="complete-implementation-with-extensive-commentary"><span class="header-section-number">9.3.1.1</span> Complete Implementation
with Extensive Commentary</h4>
<div class="sourceCode" id="cb666"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb666-1"><a aria-hidden="true" href="#cb666-1" tabindex="-1"></a>" check</span>
<span id="cb666-2"><a aria-hidden="true" href="#cb666-2" tabindex="-1"></a></span>
<span id="cb666-3"><a aria-hidden="true" href="#cb666-3" tabindex="-1"></a>" ============================================</span>
<span id="cb666-4"><a aria-hidden="true" href="#cb666-4" tabindex="-1"></a>" PHASE <span class="dv">1</span><span class="op">:</span> INITIALIZATION</span>
<span id="cb666-5"><a aria-hidden="true" href="#cb666-5" tabindex="-1"></a>" Get kernel data structure addresses via sysloc</span>
<span id="cb666-6"><a aria-hidden="true" href="#cb666-6" tabindex="-1"></a>" ============================================</span>
<span id="cb666-7"><a aria-hidden="true" href="#cb666-7" tabindex="-1"></a></span>
<span id="cb666-8"><a aria-hidden="true" href="#cb666-8" tabindex="-1"></a>lac d1</span>
<span id="cb666-9"><a aria-hidden="true" href="#cb666-9" tabindex="-1"></a>sys sysloc                <span class="st">" Get address of iget() function</span></span>
<span id="cb666-10"><a aria-hidden="true" href="#cb666-10" tabindex="-1"></a>dac iget</span>
<span id="cb666-11"><a aria-hidden="true" href="#cb666-11" tabindex="-1"></a></span>
<span id="cb666-12"><a aria-hidden="true" href="#cb666-12" tabindex="-1"></a>lac d2</span>
<span id="cb666-13"><a aria-hidden="true" href="#cb666-13" tabindex="-1"></a>sys sysloc                <span class="st">" Get address of current inode structure</span></span>
<span id="cb666-14"><a aria-hidden="true" href="#cb666-14" tabindex="-1"></a>dac inode</span>
<span id="cb666-15"><a aria-hidden="true" href="#cb666-15" tabindex="-1"></a></span>
<span id="cb666-16"><a aria-hidden="true" href="#cb666-16" tabindex="-1"></a>lac d4</span>
<span id="cb666-17"><a aria-hidden="true" href="#cb666-17" tabindex="-1"></a>sys sysloc                <span class="st">" Get address of free block list</span></span>
<span id="cb666-18"><a aria-hidden="true" href="#cb666-18" tabindex="-1"></a>dac nxfblk                <span class="st">" Next free block pointer</span></span>
<span id="cb666-19"><a aria-hidden="true" href="#cb666-19" tabindex="-1"></a>tad d1</span>
<span id="cb666-20"><a aria-hidden="true" href="#cb666-20" tabindex="-1"></a>dac nfblks                <span class="st">" Number of free blocks</span></span>
<span id="cb666-21"><a aria-hidden="true" href="#cb666-21" tabindex="-1"></a>tad d1</span>
<span id="cb666-22"><a aria-hidden="true" href="#cb666-22" tabindex="-1"></a>dac fblks                 <span class="st">" Free blocks array</span></span>
<span id="cb666-23"><a aria-hidden="true" href="#cb666-23" tabindex="-1"></a></span>
<span id="cb666-24"><a aria-hidden="true" href="#cb666-24" tabindex="-1"></a>lac d5</span>
<span id="cb666-25"><a aria-hidden="true" href="#cb666-25" tabindex="-1"></a>sys sysloc                <span class="st">" Get address of memory copy function</span></span>
<span id="cb666-26"><a aria-hidden="true" href="#cb666-26" tabindex="-1"></a>dac copy</span>
<span id="cb666-27"><a aria-hidden="true" href="#cb666-27" tabindex="-1"></a></span>
<span id="cb666-28"><a aria-hidden="true" href="#cb666-28" tabindex="-1"></a>lac d6</span>
<span id="cb666-29"><a aria-hidden="true" href="#cb666-29" tabindex="-1"></a>sys sysloc                <span class="st">" Get address of zero-fill function</span></span>
<span id="cb666-30"><a aria-hidden="true" href="#cb666-30" tabindex="-1"></a>dac copyz</span>
<span id="cb666-31"><a aria-hidden="true" href="#cb666-31" tabindex="-1"></a></span>
<span id="cb666-32"><a aria-hidden="true" href="#cb666-32" tabindex="-1"></a>lac d7</span>
<span id="cb666-33"><a aria-hidden="true" href="#cb666-33" tabindex="-1"></a>sys sysloc                <span class="st">" Get address of range checking function</span></span>
<span id="cb666-34"><a aria-hidden="true" href="#cb666-34" tabindex="-1"></a>dac betwen</span>
<span id="cb666-35"><a aria-hidden="true" href="#cb666-35" tabindex="-1"></a></span>
<span id="cb666-36"><a aria-hidden="true" href="#cb666-36" tabindex="-1"></a>lac d8</span>
<span id="cb666-37"><a aria-hidden="true" href="#cb666-37" tabindex="-1"></a>sys sysloc                <span class="st">" Get address of disk read function</span></span>
<span id="cb666-38"><a aria-hidden="true" href="#cb666-38" tabindex="-1"></a>dac dskrd</span>
<span id="cb666-39"><a aria-hidden="true" href="#cb666-39" tabindex="-1"></a></span>
<span id="cb666-40"><a aria-hidden="true" href="#cb666-40" tabindex="-1"></a>lac d10</span>
<span id="cb666-41"><a aria-hidden="true" href="#cb666-41" tabindex="-1"></a>sys sysloc                <span class="st">" Get address of disk buffer</span></span>
<span id="cb666-42"><a aria-hidden="true" href="#cb666-42" tabindex="-1"></a>dac dskbuf</span>
<span id="cb666-43"><a aria-hidden="true" href="#cb666-43" tabindex="-1"></a>dac dskbuf1</span>
<span id="cb666-44"><a aria-hidden="true" href="#cb666-44" tabindex="-1"></a></span>
<span id="cb666-45"><a aria-hidden="true" href="#cb666-45" tabindex="-1"></a>   dzm indircnt           <span class="st">" Clear indirect block counter</span></span>
<span id="cb666-46"><a aria-hidden="true" href="#cb666-46" tabindex="-1"></a>   dzm icnt               <span class="st">" Clear inode counter</span></span>
<span id="cb666-47"><a aria-hidden="true" href="#cb666-47" tabindex="-1"></a>   dzm licnt              <span class="st">" Clear large file counter</span></span>
<span id="cb666-48"><a aria-hidden="true" href="#cb666-48" tabindex="-1"></a>   dzm blcnt              <span class="st">" Clear block counter</span></span>
<span id="cb666-49"><a aria-hidden="true" href="#cb666-49" tabindex="-1"></a>   dzm curi               <span class="st">" Clear current inode number</span></span>
<span id="cb666-50"><a aria-hidden="true" href="#cb666-50" tabindex="-1"></a>   jms copyz i<span class="co">; usetab; 500  " Zero out the usage table (500 words)</span></span>
<span id="cb666-51"><a aria-hidden="true" href="#cb666-51" tabindex="-1"></a></span>
<span id="cb666-52"><a aria-hidden="true" href="#cb666-52" tabindex="-1"></a>" ============================================</span>
<span id="cb666-53"><a aria-hidden="true" href="#cb666-53" tabindex="-1"></a>" PHASE <span class="dv">2</span><span class="op">:</span> INODE SCANNING LOOP</span>
<span id="cb666-54"><a aria-hidden="true" href="#cb666-54" tabindex="-1"></a>" Scan all <span class="dv">3400</span> inodes <span class="op">and</span> check their blocks</span>
<span id="cb666-55"><a aria-hidden="true" href="#cb666-55" tabindex="-1"></a>" ============================================</span>
<span id="cb666-56"><a aria-hidden="true" href="#cb666-56" tabindex="-1"></a></span>
<span id="cb666-57"><a aria-hidden="true" href="#cb666-57" tabindex="-1"></a><span class="fu">iloop:</span></span>
<span id="cb666-58"><a aria-hidden="true" href="#cb666-58" tabindex="-1"></a>   isz curi               <span class="st">" Increment current inode number</span></span>
<span id="cb666-59"><a aria-hidden="true" href="#cb666-59" tabindex="-1"></a>   -3400                  " Check if we<span class="st">'ve scanned all inodes</span></span>
<span id="cb666-60"><a aria-hidden="true" href="#cb666-60" tabindex="-1"></a>   tad curi</span>
<span id="cb666-61"><a aria-hidden="true" href="#cb666-61" tabindex="-1"></a>   sma                    <span class="st">" Skip if minus (more inodes to check)</span></span>
<span id="cb666-62"><a aria-hidden="true" href="#cb666-62" tabindex="-1"></a>   <span class="cf">jmp</span> part2              <span class="st">" Done with inodes, move to part 2</span></span>
<span id="cb666-63"><a aria-hidden="true" href="#cb666-63" tabindex="-1"></a>   lac curi</span>
<span id="cb666-64"><a aria-hidden="true" href="#cb666-64" tabindex="-1"></a>   jms iget i             <span class="st">" Read inode from disk</span></span>
<span id="cb666-65"><a aria-hidden="true" href="#cb666-65" tabindex="-1"></a>   jms copy i<span class="co">; inode: 0; linode; 12  " Copy inode to local buffer</span></span>
<span id="cb666-66"><a aria-hidden="true" href="#cb666-66" tabindex="-1"></a>   lac iflags             <span class="st">" Get inode flags</span></span>
<span id="cb666-67"><a aria-hidden="true" href="#cb666-67" tabindex="-1"></a>   sma                    <span class="st">" Skip if minus (allocated)</span></span>
<span id="cb666-68"><a aria-hidden="true" href="#cb666-68" tabindex="-1"></a>   <span class="cf">jmp</span> iloop              <span class="st">" Free inode, skip it</span></span>
<span id="cb666-69"><a aria-hidden="true" href="#cb666-69" tabindex="-1"></a>   isz icnt               <span class="st">" Count allocated inodes</span></span>
<span id="cb666-70"><a aria-hidden="true" href="#cb666-70" tabindex="-1"></a>   lac iflags</span>
<span id="cb666-71"><a aria-hidden="true" href="#cb666-71" tabindex="-1"></a>   <span class="bu">and</span> o40                <span class="st">" Check special file bit</span></span>
<span id="cb666-72"><a aria-hidden="true" href="#cb666-72" tabindex="-1"></a>   sza                    <span class="st">" Skip if zero (regular file)</span></span>
<span id="cb666-73"><a aria-hidden="true" href="#cb666-73" tabindex="-1"></a>   <span class="cf">jmp</span> iloop              <span class="st">" Special file, skip block checking</span></span>
<span id="cb666-74"><a aria-hidden="true" href="#cb666-74" tabindex="-1"></a></span>
<span id="cb666-75"><a aria-hidden="true" href="#cb666-75" tabindex="-1"></a>" ============================================</span>
<span id="cb666-76"><a aria-hidden="true" href="#cb666-76" tabindex="-1"></a>" Check direct blocks <span class="op">(</span><span class="dv">7</span> blocks per inode<span class="op">)</span></span>
<span id="cb666-77"><a aria-hidden="true" href="#cb666-77" tabindex="-1"></a>" ============================================</span>
<span id="cb666-78"><a aria-hidden="true" href="#cb666-78" tabindex="-1"></a></span>
<span id="cb666-79"><a aria-hidden="true" href="#cb666-79" tabindex="-1"></a>   law idskps             <span class="st">" Load address of disk block pointers</span></span>
<span id="cb666-80"><a aria-hidden="true" href="#cb666-80" tabindex="-1"></a>   dac t1</span>
<span id="cb666-81"><a aria-hidden="true" href="#cb666-81" tabindex="-1"></a>   -7                     " 7 direct blocks</span>
<span id="cb666-82"><a aria-hidden="true" href="#cb666-82" tabindex="-1"></a>   dac t2</span>
<span id="cb666-83"><a aria-hidden="true" href="#cb666-83" tabindex="-1"></a>1:</span>
<span id="cb666-84"><a aria-hidden="true" href="#cb666-84" tabindex="-1"></a>   lac i t1               <span class="st">" Load block number</span></span>
<span id="cb666-85"><a aria-hidden="true" href="#cb666-85" tabindex="-1"></a>   sza                    <span class="st">" Skip if zero (unused block)</span></span>
<span id="cb666-86"><a aria-hidden="true" href="#cb666-86" tabindex="-1"></a>   jms dupcheck           <span class="st">" Check if block is already used</span></span>
<span id="cb666-87"><a aria-hidden="true" href="#cb666-87" tabindex="-1"></a>   isz t1                 <span class="st">" Next block pointer</span></span>
<span id="cb666-88"><a aria-hidden="true" href="#cb666-88" tabindex="-1"></a>   isz t2                 <span class="st">" Decrement counter</span></span>
<span id="cb666-89"><a aria-hidden="true" href="#cb666-89" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span>                 <span class="st">" Continue</span></span>
<span id="cb666-90"><a aria-hidden="true" href="#cb666-90" tabindex="-1"></a></span>
<span id="cb666-91"><a aria-hidden="true" href="#cb666-91" tabindex="-1"></a>" ============================================</span>
<span id="cb666-92"><a aria-hidden="true" href="#cb666-92" tabindex="-1"></a>" Check if this is a large <span class="dt">file</span> <span class="op">(</span>has indirect blocks<span class="op">)</span></span>
<span id="cb666-93"><a aria-hidden="true" href="#cb666-93" tabindex="-1"></a>" ============================================</span>
<span id="cb666-94"><a aria-hidden="true" href="#cb666-94" tabindex="-1"></a></span>
<span id="cb666-95"><a aria-hidden="true" href="#cb666-95" tabindex="-1"></a>   lac iflags</span>
<span id="cb666-96"><a aria-hidden="true" href="#cb666-96" tabindex="-1"></a>   <span class="bu">and</span> o200000            <span class="st">" Check large file bit</span></span>
<span id="cb666-97"><a aria-hidden="true" href="#cb666-97" tabindex="-1"></a>   sna                    <span class="st">" Skip if non-zero (large file)</span></span>
<span id="cb666-98"><a aria-hidden="true" href="#cb666-98" tabindex="-1"></a>   <span class="cf">jmp</span> iloop              <span class="st">" Not large, continue to next inode</span></span>
<span id="cb666-99"><a aria-hidden="true" href="#cb666-99" tabindex="-1"></a></span>
<span id="cb666-100"><a aria-hidden="true" href="#cb666-100" tabindex="-1"></a>" ============================================</span>
<span id="cb666-101"><a aria-hidden="true" href="#cb666-101" tabindex="-1"></a>" Process indirect blocks for large files</span>
<span id="cb666-102"><a aria-hidden="true" href="#cb666-102" tabindex="-1"></a>" ============================================</span>
<span id="cb666-103"><a aria-hidden="true" href="#cb666-103" tabindex="-1"></a></span>
<span id="cb666-104"><a aria-hidden="true" href="#cb666-104" tabindex="-1"></a>   isz licnt              <span class="st">" Count large files</span></span>
<span id="cb666-105"><a aria-hidden="true" href="#cb666-105" tabindex="-1"></a>   law idskps             <span class="st">" Reload block pointers</span></span>
<span id="cb666-106"><a aria-hidden="true" href="#cb666-106" tabindex="-1"></a>   dac t1</span>
<span id="cb666-107"><a aria-hidden="true" href="#cb666-107" tabindex="-1"></a>   -7                     " 7 indirect block pointers</span>
<span id="cb666-108"><a aria-hidden="true" href="#cb666-108" tabindex="-1"></a>   dac t2</span>
<span id="cb666-109"><a aria-hidden="true" href="#cb666-109" tabindex="-1"></a>1:</span>
<span id="cb666-110"><a aria-hidden="true" href="#cb666-110" tabindex="-1"></a>   lac i t1               <span class="st">" Load indirect block number</span></span>
<span id="cb666-111"><a aria-hidden="true" href="#cb666-111" tabindex="-1"></a>   sna                    <span class="st">" Skip if non-zero</span></span>
<span id="cb666-112"><a aria-hidden="true" href="#cb666-112" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">3</span><span class="bn">f</span>                 <span class="st">" Zero, skip to next</span></span>
<span id="cb666-113"><a aria-hidden="true" href="#cb666-113" tabindex="-1"></a>   jms dskrd i            <span class="st">" Read the indirect block</span></span>
<span id="cb666-114"><a aria-hidden="true" href="#cb666-114" tabindex="-1"></a>   jms copy i<span class="co">; dskbuf: 0; ldskbuf; 64  " Copy to local buffer</span></span>
<span id="cb666-115"><a aria-hidden="true" href="#cb666-115" tabindex="-1"></a>   isz indircnt           <span class="st">" Count indirect blocks</span></span>
<span id="cb666-116"><a aria-hidden="true" href="#cb666-116" tabindex="-1"></a>   law ldskbuf            <span class="st">" Point to indirect block data</span></span>
<span id="cb666-117"><a aria-hidden="true" href="#cb666-117" tabindex="-1"></a>   dac t3</span>
<span id="cb666-118"><a aria-hidden="true" href="#cb666-118" tabindex="-1"></a>   -64                    " 64 block pointers per indirect block</span>
<span id="cb666-119"><a aria-hidden="true" href="#cb666-119" tabindex="-1"></a>   dac t4</span>
<span id="cb666-120"><a aria-hidden="true" href="#cb666-120" tabindex="-1"></a>2:</span>
<span id="cb666-121"><a aria-hidden="true" href="#cb666-121" tabindex="-1"></a>   lac i t3               <span class="st">" Load block number from indirect block</span></span>
<span id="cb666-122"><a aria-hidden="true" href="#cb666-122" tabindex="-1"></a>   sza                    <span class="st">" Skip if zero</span></span>
<span id="cb666-123"><a aria-hidden="true" href="#cb666-123" tabindex="-1"></a>   jms dupcheck           <span class="st">" Check for duplicates</span></span>
<span id="cb666-124"><a aria-hidden="true" href="#cb666-124" tabindex="-1"></a>   isz t3</span>
<span id="cb666-125"><a aria-hidden="true" href="#cb666-125" tabindex="-1"></a>   isz t4</span>
<span id="cb666-126"><a aria-hidden="true" href="#cb666-126" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="dv">2</span><span class="er">b</span>                 <span class="st">" Continue through indirect block</span></span>
<span id="cb666-127"><a aria-hidden="true" href="#cb666-127" tabindex="-1"></a>3:</span>
<span id="cb666-128"><a aria-hidden="true" href="#cb666-128" tabindex="-1"></a>   isz t1                 <span class="st">" Next indirect block pointer</span></span>
<span id="cb666-129"><a aria-hidden="true" href="#cb666-129" tabindex="-1"></a>   isz t2</span>
<span id="cb666-130"><a aria-hidden="true" href="#cb666-130" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span>                 <span class="st">" Continue through all 7 indirect pointers</span></span>
<span id="cb666-131"><a aria-hidden="true" href="#cb666-131" tabindex="-1"></a>   <span class="cf">jmp</span> iloop              <span class="st">" Done with this inode</span></span>
<span id="cb666-132"><a aria-hidden="true" href="#cb666-132" tabindex="-1"></a></span>
<span id="cb666-133"><a aria-hidden="true" href="#cb666-133" tabindex="-1"></a>" ============================================</span>
<span id="cb666-134"><a aria-hidden="true" href="#cb666-134" tabindex="-1"></a>" DUPCHECK SUBROUTINE</span>
<span id="cb666-135"><a aria-hidden="true" href="#cb666-135" tabindex="-1"></a>" Checks if a block is already marked as <span class="op">used</span></span>
<span id="cb666-136"><a aria-hidden="true" href="#cb666-136" tabindex="-1"></a>" <span class="pp">If</span> already <span class="op">used:</span> DUPLICATE <span class="op">(</span>serious error<span class="op">)</span></span>
<span id="cb666-137"><a aria-hidden="true" href="#cb666-137" tabindex="-1"></a>" <span class="pp">If</span> <span class="op">not</span> <span class="op">used:</span> Mark it as <span class="op">used</span></span>
<span id="cb666-138"><a aria-hidden="true" href="#cb666-138" tabindex="-1"></a>" ============================================</span>
<span id="cb666-139"><a aria-hidden="true" href="#cb666-139" tabindex="-1"></a></span>
<span id="cb666-140"><a aria-hidden="true" href="#cb666-140" tabindex="-1"></a><span class="fu">dupcheck:</span> 0</span>
<span id="cb666-141"><a aria-hidden="true" href="#cb666-141" tabindex="-1"></a>   isz blcnt              <span class="st">" Count total blocks used</span></span>
<span id="cb666-142"><a aria-hidden="true" href="#cb666-142" tabindex="-1"></a>   jms betwen i<span class="co">; d709; d6400  " Check if block in valid range</span></span>
<span id="cb666-143"><a aria-hidden="true" href="#cb666-143" tabindex="-1"></a>   <span class="cf">jmp</span> badadr             <span class="st">" Out of range - bad address</span></span>
<span id="cb666-144"><a aria-hidden="true" href="#cb666-144" tabindex="-1"></a>   dac t5                 <span class="st">" Save block number</span></span>
<span id="cb666-145"><a aria-hidden="true" href="#cb666-145" tabindex="-1"></a>   lrss <span class="dv">4</span>                 <span class="st">" Divide by 16 (word index in table)</span></span>
<span id="cb666-146"><a aria-hidden="true" href="#cb666-146" tabindex="-1"></a>   tad usetabp            <span class="st">" Add to usage table base</span></span>
<span id="cb666-147"><a aria-hidden="true" href="#cb666-147" tabindex="-1"></a>   dac t6                 <span class="st">" t6 = address of word in usage table</span></span>
<span id="cb666-148"><a aria-hidden="true" href="#cb666-148" tabindex="-1"></a>   cla</span>
<span id="cb666-149"><a aria-hidden="true" href="#cb666-149" tabindex="-1"></a>   llss <span class="dv">4</span>                 <span class="st">" Get bit position within word</span></span>
<span id="cb666-150"><a aria-hidden="true" href="#cb666-150" tabindex="-1"></a>   tad alsscom            <span class="st">" Build shift instruction</span></span>
<span id="cb666-151"><a aria-hidden="true" href="#cb666-151" tabindex="-1"></a>   dac <span class="fl">2</span><span class="bn">f</span>                 <span class="st">" Self-modifying code!</span></span>
<span id="cb666-152"><a aria-hidden="true" href="#cb666-152" tabindex="-1"></a>   lac d1</span>
<span id="cb666-153"><a aria-hidden="true" href="#cb666-153" tabindex="-1"></a>2: alss <span class="dv">0</span>                 <span class="st">" Shift 1 by bit position</span></span>
<span id="cb666-154"><a aria-hidden="true" href="#cb666-154" tabindex="-1"></a>   dac bit                <span class="st">" This is the bit mask</span></span>
<span id="cb666-155"><a aria-hidden="true" href="#cb666-155" tabindex="-1"></a>   lac i t6               <span class="st">" Load usage table word</span></span>
<span id="cb666-156"><a aria-hidden="true" href="#cb666-156" tabindex="-1"></a>   <span class="bu">and</span> bit                <span class="st">" Check if bit already set</span></span>
<span id="cb666-157"><a aria-hidden="true" href="#cb666-157" tabindex="-1"></a>   sza                    <span class="st">" Skip if zero (not used)</span></span>
<span id="cb666-158"><a aria-hidden="true" href="#cb666-158" tabindex="-1"></a>   <span class="cf">jmp</span> dup                <span class="st">" DUPLICATE BLOCK ERROR!</span></span>
<span id="cb666-159"><a aria-hidden="true" href="#cb666-159" tabindex="-1"></a>   lac i t6               <span class="st">" Not used - mark it</span></span>
<span id="cb666-160"><a aria-hidden="true" href="#cb666-160" tabindex="-1"></a>   <span class="bu">xor</span> bit                <span class="st">" Set the bit (XOR same as OR for setting)</span></span>
<span id="cb666-161"><a aria-hidden="true" href="#cb666-161" tabindex="-1"></a>   dac i t6               <span class="st">" Store back</span></span>
<span id="cb666-162"><a aria-hidden="true" href="#cb666-162" tabindex="-1"></a>   <span class="cf">jmp</span> i dupcheck         <span class="st">" Return</span></span>
<span id="cb666-163"><a aria-hidden="true" href="#cb666-163" tabindex="-1"></a></span>
<span id="cb666-164"><a aria-hidden="true" href="#cb666-164" tabindex="-1"></a><span class="fu">badadr:</span></span>
<span id="cb666-165"><a aria-hidden="true" href="#cb666-165" tabindex="-1"></a>   jms print              <span class="st">" Print error message</span></span>
<span id="cb666-166"><a aria-hidden="true" href="#cb666-166" tabindex="-1"></a>   lac d1</span>
<span id="cb666-167"><a aria-hidden="true" href="#cb666-167" tabindex="-1"></a>   sys write<span class="co">; badmes; 3   " "bad\n"</span></span>
<span id="cb666-168"><a aria-hidden="true" href="#cb666-168" tabindex="-1"></a>   <span class="cf">jmp</span> i dupcheck</span>
<span id="cb666-169"><a aria-hidden="true" href="#cb666-169" tabindex="-1"></a></span>
<span id="cb666-170"><a aria-hidden="true" href="#cb666-170" tabindex="-1"></a><span class="fu">badmes:</span></span>
<span id="cb666-171"><a aria-hidden="true" href="#cb666-171" tabindex="-1"></a>   &lt; b<span class="op">&gt;</span><span class="co">;&lt;ad&gt;;&lt;r 012</span></span>
<span id="cb666-172"><a aria-hidden="true" href="#cb666-172" tabindex="-1"></a></span>
<span id="cb666-173"><a aria-hidden="true" href="#cb666-173" tabindex="-1"></a><span class="fu">dup:</span></span>
<span id="cb666-174"><a aria-hidden="true" href="#cb666-174" tabindex="-1"></a>   lac t5                 <span class="st">" Print block number</span></span>
<span id="cb666-175"><a aria-hidden="true" href="#cb666-175" tabindex="-1"></a>   jms print</span>
<span id="cb666-176"><a aria-hidden="true" href="#cb666-176" tabindex="-1"></a>   lac d1</span>
<span id="cb666-177"><a aria-hidden="true" href="#cb666-177" tabindex="-1"></a>   sys write<span class="co">; dupmes; 3   " "dup "</span></span>
<span id="cb666-178"><a aria-hidden="true" href="#cb666-178" tabindex="-1"></a>   lac curi               <span class="st">" Print inode number</span></span>
<span id="cb666-179"><a aria-hidden="true" href="#cb666-179" tabindex="-1"></a>   jms print</span>
<span id="cb666-180"><a aria-hidden="true" href="#cb666-180" tabindex="-1"></a>   lac d1</span>
<span id="cb666-181"><a aria-hidden="true" href="#cb666-181" tabindex="-1"></a>   sys write<span class="co">; dupmes+3; 1 " "\n"</span></span>
<span id="cb666-182"><a aria-hidden="true" href="#cb666-182" tabindex="-1"></a>   <span class="cf">jmp</span> i dupcheck</span>
<span id="cb666-183"><a aria-hidden="true" href="#cb666-183" tabindex="-1"></a></span>
<span id="cb666-184"><a aria-hidden="true" href="#cb666-184" tabindex="-1"></a><span class="fu">dupmes:</span></span>
<span id="cb666-185"><a aria-hidden="true" href="#cb666-185" tabindex="-1"></a>   &lt; d<span class="op">&gt;</span><span class="co">;&lt;up&gt;; 040; 012</span></span>
<span id="cb666-186"><a aria-hidden="true" href="#cb666-186" tabindex="-1"></a></span>
<span id="cb666-187"><a aria-hidden="true" href="#cb666-187" tabindex="-1"></a>" ============================================</span>
<span id="cb666-188"><a aria-hidden="true" href="#cb666-188" tabindex="-1"></a>" PRINT SUBROUTINE</span>
<span id="cb666-189"><a aria-hidden="true" href="#cb666-189" tabindex="-1"></a>" Print a number in octal</span>
<span id="cb666-190"><a aria-hidden="true" href="#cb666-190" tabindex="-1"></a>" ============================================</span>
<span id="cb666-191"><a aria-hidden="true" href="#cb666-191" tabindex="-1"></a></span>
<span id="cb666-192"><a aria-hidden="true" href="#cb666-192" tabindex="-1"></a><span class="fu">print:</span> 0</span>
<span id="cb666-193"><a aria-hidden="true" href="#cb666-193" tabindex="-1"></a>   lmq                    <span class="st">" Save number in MQ</span></span>
<span id="cb666-194"><a aria-hidden="true" href="#cb666-194" tabindex="-1"></a>   law prbuf<span class="op">-</span><span class="dv">1</span>            <span class="st">" Point to print buffer</span></span>
<span id="cb666-195"><a aria-hidden="true" href="#cb666-195" tabindex="-1"></a>   dac <span class="dv">8</span></span>
<span id="cb666-196"><a aria-hidden="true" href="#cb666-196" tabindex="-1"></a>   -6                     " 6 octal digits</span>
<span id="cb666-197"><a aria-hidden="true" href="#cb666-197" tabindex="-1"></a>   dac t6</span>
<span id="cb666-198"><a aria-hidden="true" href="#cb666-198" tabindex="-1"></a>1:</span>
<span id="cb666-199"><a aria-hidden="true" href="#cb666-199" tabindex="-1"></a>   cla</span>
<span id="cb666-200"><a aria-hidden="true" href="#cb666-200" tabindex="-1"></a>   llss <span class="dv">3</span>                 <span class="st">" Get low 3 bits (one octal digit)</span></span>
<span id="cb666-201"><a aria-hidden="true" href="#cb666-201" tabindex="-1"></a>   tad o60                <span class="st">" Convert to ASCII ('0' = 060)</span></span>
<span id="cb666-202"><a aria-hidden="true" href="#cb666-202" tabindex="-1"></a>   dac i <span class="dv">8</span>                <span class="st">" Store in buffer</span></span>
<span id="cb666-203"><a aria-hidden="true" href="#cb666-203" tabindex="-1"></a>   isz t6</span>
<span id="cb666-204"><a aria-hidden="true" href="#cb666-204" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span>                 <span class="st">" Continue</span></span>
<span id="cb666-205"><a aria-hidden="true" href="#cb666-205" tabindex="-1"></a>   lac d1</span>
<span id="cb666-206"><a aria-hidden="true" href="#cb666-206" tabindex="-1"></a>   sys write<span class="co">; prbuf; 6    " Write the 6-digit number</span></span>
<span id="cb666-207"><a aria-hidden="true" href="#cb666-207" tabindex="-1"></a>   <span class="cf">jmp</span> i print</span>
<span id="cb666-208"><a aria-hidden="true" href="#cb666-208" tabindex="-1"></a></span>
<span id="cb666-209"><a aria-hidden="true" href="#cb666-209" tabindex="-1"></a>" ============================================</span>
<span id="cb666-210"><a aria-hidden="true" href="#cb666-210" tabindex="-1"></a>" PHASE <span class="dv">2</span><span class="op">:</span> CHECK FREE BLOCK LIST</span>
<span id="cb666-211"><a aria-hidden="true" href="#cb666-211" tabindex="-1"></a>" Verify that all blocks in the free list are valid</span>
<span id="cb666-212"><a aria-hidden="true" href="#cb666-212" tabindex="-1"></a>" <span class="bu">and</span> <span class="op">not</span> already marked as <span class="op">used</span></span>
<span id="cb666-213"><a aria-hidden="true" href="#cb666-213" tabindex="-1"></a>" ============================================</span>
<span id="cb666-214"><a aria-hidden="true" href="#cb666-214" tabindex="-1"></a></span>
<span id="cb666-215"><a aria-hidden="true" href="#cb666-215" tabindex="-1"></a><span class="fu">part2:</span></span>
<span id="cb666-216"><a aria-hidden="true" href="#cb666-216" tabindex="-1"></a>   lac icnt               <span class="st">" Print statistics</span></span>
<span id="cb666-217"><a aria-hidden="true" href="#cb666-217" tabindex="-1"></a>   <span class="cf">jmp</span> print              <span class="st">" (jmp instead of jms - print doesn't return)</span></span>
<span id="cb666-218"><a aria-hidden="true" href="#cb666-218" tabindex="-1"></a>   lac d1</span>
<span id="cb666-219"><a aria-hidden="true" href="#cb666-219" tabindex="-1"></a>   sys write<span class="co">; m3; m3s     " " files\n"</span></span>
<span id="cb666-220"><a aria-hidden="true" href="#cb666-220" tabindex="-1"></a>   lac licnt</span>
<span id="cb666-221"><a aria-hidden="true" href="#cb666-221" tabindex="-1"></a>   jms print</span>
<span id="cb666-222"><a aria-hidden="true" href="#cb666-222" tabindex="-1"></a>   lac d1</span>
<span id="cb666-223"><a aria-hidden="true" href="#cb666-223" tabindex="-1"></a>   sys write<span class="co">; m4; m4s     " large\n"</span></span>
<span id="cb666-224"><a aria-hidden="true" href="#cb666-224" tabindex="-1"></a>   lac indircnt</span>
<span id="cb666-225"><a aria-hidden="true" href="#cb666-225" tabindex="-1"></a>   jms print</span>
<span id="cb666-226"><a aria-hidden="true" href="#cb666-226" tabindex="-1"></a>   lac d1</span>
<span id="cb666-227"><a aria-hidden="true" href="#cb666-227" tabindex="-1"></a>   sys write<span class="co">; m5; m5s     " indir\n"</span></span>
<span id="cb666-228"><a aria-hidden="true" href="#cb666-228" tabindex="-1"></a>   lac blcnt</span>
<span id="cb666-229"><a aria-hidden="true" href="#cb666-229" tabindex="-1"></a>   jms print</span>
<span id="cb666-230"><a aria-hidden="true" href="#cb666-230" tabindex="-1"></a>   lac d1</span>
<span id="cb666-231"><a aria-hidden="true" href="#cb666-231" tabindex="-1"></a>   sys write<span class="co">; m6; m6s     " used\n"</span></span>
<span id="cb666-232"><a aria-hidden="true" href="#cb666-232" tabindex="-1"></a>   dzm blcnt              <span class="st">" Reset block counter for free list</span></span>
<span id="cb666-233"><a aria-hidden="true" href="#cb666-233" tabindex="-1"></a></span>
<span id="cb666-234"><a aria-hidden="true" href="#cb666-234" tabindex="-1"></a>" Check blocks in the in<span class="op">-</span>core free list</span>
<span id="cb666-235"><a aria-hidden="true" href="#cb666-235" tabindex="-1"></a>   -1</span>
<span id="cb666-236"><a aria-hidden="true" href="#cb666-236" tabindex="-1"></a>   tad nfblks i           <span class="st">" Get number of free blocks</span></span>
<span id="cb666-237"><a aria-hidden="true" href="#cb666-237" tabindex="-1"></a>   cma</span>
<span id="cb666-238"><a aria-hidden="true" href="#cb666-238" tabindex="-1"></a>   sma                    <span class="st">" Skip if there are blocks</span></span>
<span id="cb666-239"><a aria-hidden="true" href="#cb666-239" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">2</span><span class="bn">f</span>                 <span class="st">" No blocks in free list</span></span>
<span id="cb666-240"><a aria-hidden="true" href="#cb666-240" tabindex="-1"></a>   dac t1                 <span class="st">" Counter</span></span>
<span id="cb666-241"><a aria-hidden="true" href="#cb666-241" tabindex="-1"></a>   lac fblks              <span class="st">" Free blocks array</span></span>
<span id="cb666-242"><a aria-hidden="true" href="#cb666-242" tabindex="-1"></a>   dac t2                 <span class="st">" Pointer</span></span>
<span id="cb666-243"><a aria-hidden="true" href="#cb666-243" tabindex="-1"></a>1:</span>
<span id="cb666-244"><a aria-hidden="true" href="#cb666-244" tabindex="-1"></a>   lac i t2               <span class="st">" Load free block number</span></span>
<span id="cb666-245"><a aria-hidden="true" href="#cb666-245" tabindex="-1"></a>   jms dupcheck           <span class="st">" Check it</span></span>
<span id="cb666-246"><a aria-hidden="true" href="#cb666-246" tabindex="-1"></a>   isz t2</span>
<span id="cb666-247"><a aria-hidden="true" href="#cb666-247" tabindex="-1"></a>   isz t1</span>
<span id="cb666-248"><a aria-hidden="true" href="#cb666-248" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span>                 <span class="st">" Continue</span></span>
<span id="cb666-249"><a aria-hidden="true" href="#cb666-249" tabindex="-1"></a></span>
<span id="cb666-250"><a aria-hidden="true" href="#cb666-250" tabindex="-1"></a>" Walk the linked list of free block buffers on disk</span>
<span id="cb666-251"><a aria-hidden="true" href="#cb666-251" tabindex="-1"></a>2:</span>
<span id="cb666-252"><a aria-hidden="true" href="#cb666-252" tabindex="-1"></a>   lac nxfblk i           <span class="st">" Get next free block buffer address</span></span>
<span id="cb666-253"><a aria-hidden="true" href="#cb666-253" tabindex="-1"></a>1:</span>
<span id="cb666-254"><a aria-hidden="true" href="#cb666-254" tabindex="-1"></a>   sna                    <span class="st">" Skip if non-zero (more buffers)</span></span>
<span id="cb666-255"><a aria-hidden="true" href="#cb666-255" tabindex="-1"></a>   <span class="cf">jmp</span> part3              <span class="st">" Done with free list</span></span>
<span id="cb666-256"><a aria-hidden="true" href="#cb666-256" tabindex="-1"></a>   dac t1</span>
<span id="cb666-257"><a aria-hidden="true" href="#cb666-257" tabindex="-1"></a>   jms dupcheck           <span class="st">" Check the buffer block itself</span></span>
<span id="cb666-258"><a aria-hidden="true" href="#cb666-258" tabindex="-1"></a>   lac t1</span>
<span id="cb666-259"><a aria-hidden="true" href="#cb666-259" tabindex="-1"></a>   jms dskrd i            <span class="st">" Read the buffer</span></span>
<span id="cb666-260"><a aria-hidden="true" href="#cb666-260" tabindex="-1"></a>   jms copy i<span class="co">; dskbuf1: 0; ldskbuf; 64</span></span>
<span id="cb666-261"><a aria-hidden="true" href="#cb666-261" tabindex="-1"></a>   law ldskbuf</span>
<span id="cb666-262"><a aria-hidden="true" href="#cb666-262" tabindex="-1"></a>   dac t1</span>
<span id="cb666-263"><a aria-hidden="true" href="#cb666-263" tabindex="-1"></a>   -9                     " 9 free blocks per buffer <span class="op">(</span><span class="dt">word</span> <span class="dv">0</span> is link<span class="op">)</span></span>
<span id="cb666-264"><a aria-hidden="true" href="#cb666-264" tabindex="-1"></a>   dac t2</span>
<span id="cb666-265"><a aria-hidden="true" href="#cb666-265" tabindex="-1"></a>2:</span>
<span id="cb666-266"><a aria-hidden="true" href="#cb666-266" tabindex="-1"></a>   isz t1                 <span class="st">" Skip link word</span></span>
<span id="cb666-267"><a aria-hidden="true" href="#cb666-267" tabindex="-1"></a>   lac i t1               <span class="st">" Load free block number</span></span>
<span id="cb666-268"><a aria-hidden="true" href="#cb666-268" tabindex="-1"></a>   jms dupcheck           <span class="st">" Check it</span></span>
<span id="cb666-269"><a aria-hidden="true" href="#cb666-269" tabindex="-1"></a>   isz t2</span>
<span id="cb666-270"><a aria-hidden="true" href="#cb666-270" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="dv">2</span><span class="er">b</span></span>
<span id="cb666-271"><a aria-hidden="true" href="#cb666-271" tabindex="-1"></a>   lac ldskbuf            <span class="st">" Get link to next buffer</span></span>
<span id="cb666-272"><a aria-hidden="true" href="#cb666-272" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span>                 <span class="st">" Continue</span></span>
<span id="cb666-273"><a aria-hidden="true" href="#cb666-273" tabindex="-1"></a></span>
<span id="cb666-274"><a aria-hidden="true" href="#cb666-274" tabindex="-1"></a>" ============================================</span>
<span id="cb666-275"><a aria-hidden="true" href="#cb666-275" tabindex="-1"></a>" PHASE <span class="dv">3</span><span class="op">:</span> FIND MISSING BLOCKS</span>
<span id="cb666-276"><a aria-hidden="true" href="#cb666-276" tabindex="-1"></a>" Any blocks <span class="op">not</span> marked in usage table are lost</span>
<span id="cb666-277"><a aria-hidden="true" href="#cb666-277" tabindex="-1"></a>" ============================================</span>
<span id="cb666-278"><a aria-hidden="true" href="#cb666-278" tabindex="-1"></a></span>
<span id="cb666-279"><a aria-hidden="true" href="#cb666-279" tabindex="-1"></a><span class="fu">part3:</span></span>
<span id="cb666-280"><a aria-hidden="true" href="#cb666-280" tabindex="-1"></a>   lac blcnt              <span class="st">" Print free blocks count</span></span>
<span id="cb666-281"><a aria-hidden="true" href="#cb666-281" tabindex="-1"></a>   jms print</span>
<span id="cb666-282"><a aria-hidden="true" href="#cb666-282" tabindex="-1"></a>   lac d1</span>
<span id="cb666-283"><a aria-hidden="true" href="#cb666-283" tabindex="-1"></a>   sys write<span class="co">; m7; m7s     " " free\n"</span></span>
<span id="cb666-284"><a aria-hidden="true" href="#cb666-284" tabindex="-1"></a>   lac d709               <span class="st">" Start at block 709 (first data block)</span></span>
<span id="cb666-285"><a aria-hidden="true" href="#cb666-285" tabindex="-1"></a>   dac t1</span>
<span id="cb666-286"><a aria-hidden="true" href="#cb666-286" tabindex="-1"></a>1:</span>
<span id="cb666-287"><a aria-hidden="true" href="#cb666-287" tabindex="-1"></a>   isz t1                 <span class="st">" Next block</span></span>
<span id="cb666-288"><a aria-hidden="true" href="#cb666-288" tabindex="-1"></a>   lac t1</span>
<span id="cb666-289"><a aria-hidden="true" href="#cb666-289" tabindex="-1"></a>   sad d6400              <span class="st">" Skip if reached end (block 6400)</span></span>
<span id="cb666-290"><a aria-hidden="true" href="#cb666-290" tabindex="-1"></a>   sys exit               <span class="st">" Done - exit successfully</span></span>
<span id="cb666-291"><a aria-hidden="true" href="#cb666-291" tabindex="-1"></a>   lrss <span class="dv">4</span>                 <span class="st">" Divide by 16 (word index)</span></span>
<span id="cb666-292"><a aria-hidden="true" href="#cb666-292" tabindex="-1"></a>   tad usetabp</span>
<span id="cb666-293"><a aria-hidden="true" href="#cb666-293" tabindex="-1"></a>   dac t2                 <span class="st">" t2 = usage table word address</span></span>
<span id="cb666-294"><a aria-hidden="true" href="#cb666-294" tabindex="-1"></a>   cla</span>
<span id="cb666-295"><a aria-hidden="true" href="#cb666-295" tabindex="-1"></a>   llss <span class="dv">4</span>                 <span class="st">" Get bit position</span></span>
<span id="cb666-296"><a aria-hidden="true" href="#cb666-296" tabindex="-1"></a>   tad alsscom</span>
<span id="cb666-297"><a aria-hidden="true" href="#cb666-297" tabindex="-1"></a>   dac <span class="fl">2</span><span class="bn">f</span></span>
<span id="cb666-298"><a aria-hidden="true" href="#cb666-298" tabindex="-1"></a>   lac d1</span>
<span id="cb666-299"><a aria-hidden="true" href="#cb666-299" tabindex="-1"></a>2: alss <span class="dv">0</span>                 <span class="st">" Build bit mask</span></span>
<span id="cb666-300"><a aria-hidden="true" href="#cb666-300" tabindex="-1"></a>   dac bit</span>
<span id="cb666-301"><a aria-hidden="true" href="#cb666-301" tabindex="-1"></a>   lac i t2               <span class="st">" Load usage table word</span></span>
<span id="cb666-302"><a aria-hidden="true" href="#cb666-302" tabindex="-1"></a>   <span class="bu">and</span> bit                <span class="st">" Check if bit is set</span></span>
<span id="cb666-303"><a aria-hidden="true" href="#cb666-303" tabindex="-1"></a>   sza                    <span class="st">" Skip if zero (not used)</span></span>
<span id="cb666-304"><a aria-hidden="true" href="#cb666-304" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span>                 <span class="st">" Used, continue</span></span>
<span id="cb666-305"><a aria-hidden="true" href="#cb666-305" tabindex="-1"></a>   lac t1                 <span class="st">" Not used - this block is missing!</span></span>
<span id="cb666-306"><a aria-hidden="true" href="#cb666-306" tabindex="-1"></a>   jms print</span>
<span id="cb666-307"><a aria-hidden="true" href="#cb666-307" tabindex="-1"></a>   lac d1</span>
<span id="cb666-308"><a aria-hidden="true" href="#cb666-308" tabindex="-1"></a>   sys write<span class="co">; m8; m8s     " " missing\n"</span></span>
<span id="cb666-309"><a aria-hidden="true" href="#cb666-309" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span></span>
<span id="cb666-310"><a aria-hidden="true" href="#cb666-310" tabindex="-1"></a></span>
<span id="cb666-311"><a aria-hidden="true" href="#cb666-311" tabindex="-1"></a>" ============================================</span>
<span id="cb666-312"><a aria-hidden="true" href="#cb666-312" tabindex="-1"></a>" <span class="bu">DATA</span> <span class="op">AND</span> CONSTANTS</span>
<span id="cb666-313"><a aria-hidden="true" href="#cb666-313" tabindex="-1"></a>" ============================================</span>
<span id="cb666-314"><a aria-hidden="true" href="#cb666-314" tabindex="-1"></a></span>
<span id="cb666-315"><a aria-hidden="true" href="#cb666-315" tabindex="-1"></a><span class="fu">d1:</span> 1</span>
<span id="cb666-316"><a aria-hidden="true" href="#cb666-316" tabindex="-1"></a><span class="fu">d2:</span> 2</span>
<span id="cb666-317"><a aria-hidden="true" href="#cb666-317" tabindex="-1"></a><span class="fu">d4:</span> 4</span>
<span id="cb666-318"><a aria-hidden="true" href="#cb666-318" tabindex="-1"></a><span class="fu">d5:</span> 5</span>
<span id="cb666-319"><a aria-hidden="true" href="#cb666-319" tabindex="-1"></a><span class="fu">d6:</span> 6</span>
<span id="cb666-320"><a aria-hidden="true" href="#cb666-320" tabindex="-1"></a><span class="fu">d7:</span> 7</span>
<span id="cb666-321"><a aria-hidden="true" href="#cb666-321" tabindex="-1"></a><span class="fu">d8:</span> 8</span>
<span id="cb666-322"><a aria-hidden="true" href="#cb666-322" tabindex="-1"></a><span class="fu">d10:</span> 10</span>
<span id="cb666-323"><a aria-hidden="true" href="#cb666-323" tabindex="-1"></a><span class="fu">o60:</span> 060</span>
<span id="cb666-324"><a aria-hidden="true" href="#cb666-324" tabindex="-1"></a><span class="fu">o400000:</span> 0400000</span>
<span id="cb666-325"><a aria-hidden="true" href="#cb666-325" tabindex="-1"></a><span class="fu">o400001:</span> 0400001</span>
<span id="cb666-326"><a aria-hidden="true" href="#cb666-326" tabindex="-1"></a><span class="fu">o40:</span> 040</span>
<span id="cb666-327"><a aria-hidden="true" href="#cb666-327" tabindex="-1"></a><span class="fu">o200000:</span> 0200000</span>
<span id="cb666-328"><a aria-hidden="true" href="#cb666-328" tabindex="-1"></a><span class="fu">alsscom:</span> alss <span class="dv">0</span></span>
<span id="cb666-329"><a aria-hidden="true" href="#cb666-329" tabindex="-1"></a><span class="fu">d709:</span> 709                 " First data block</span>
<span id="cb666-330"><a aria-hidden="true" href="#cb666-330" tabindex="-1"></a><span class="fu">d6400:</span> 6400               " Last block <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb666-331"><a aria-hidden="true" href="#cb666-331" tabindex="-1"></a></span>
<span id="cb666-332"><a aria-hidden="true" href="#cb666-332" tabindex="-1"></a><span class="fu">m3:</span></span>
<span id="cb666-333"><a aria-hidden="true" href="#cb666-333" tabindex="-1"></a>   040<span class="co">;&lt;fi&gt;;&lt;le&gt;;&lt;s 012</span></span>
<span id="cb666-334"><a aria-hidden="true" href="#cb666-334" tabindex="-1"></a>m3s <span class="op">=</span> <span class="op">.-</span>m3</span>
<span id="cb666-335"><a aria-hidden="true" href="#cb666-335" tabindex="-1"></a><span class="fu">m4:</span></span>
<span id="cb666-336"><a aria-hidden="true" href="#cb666-336" tabindex="-1"></a>   040<span class="co">;&lt;la&gt;;&lt;rg&gt;;&lt;e 012</span></span>
<span id="cb666-337"><a aria-hidden="true" href="#cb666-337" tabindex="-1"></a>m4s <span class="op">=</span> <span class="op">.-</span>m4</span>
<span id="cb666-338"><a aria-hidden="true" href="#cb666-338" tabindex="-1"></a><span class="fu">m5:</span></span>
<span id="cb666-339"><a aria-hidden="true" href="#cb666-339" tabindex="-1"></a>   040<span class="co">;&lt;in&gt;;&lt;di&gt;;&lt;r 012</span></span>
<span id="cb666-340"><a aria-hidden="true" href="#cb666-340" tabindex="-1"></a>m5s <span class="op">=</span> <span class="op">.-</span>m5</span>
<span id="cb666-341"><a aria-hidden="true" href="#cb666-341" tabindex="-1"></a><span class="fu">m6:</span></span>
<span id="cb666-342"><a aria-hidden="true" href="#cb666-342" tabindex="-1"></a>   040<span class="co">;&lt;us&gt;;&lt;ed&gt;;012</span></span>
<span id="cb666-343"><a aria-hidden="true" href="#cb666-343" tabindex="-1"></a>m6s <span class="op">=</span> <span class="op">.-</span>m6</span>
<span id="cb666-344"><a aria-hidden="true" href="#cb666-344" tabindex="-1"></a><span class="fu">m7:</span></span>
<span id="cb666-345"><a aria-hidden="true" href="#cb666-345" tabindex="-1"></a>   040<span class="co">;&lt;fr&gt;;&lt;ee&gt;;012</span></span>
<span id="cb666-346"><a aria-hidden="true" href="#cb666-346" tabindex="-1"></a>m7s <span class="op">=</span> <span class="op">.-</span>m7</span>
<span id="cb666-347"><a aria-hidden="true" href="#cb666-347" tabindex="-1"></a><span class="fu">m8:</span></span>
<span id="cb666-348"><a aria-hidden="true" href="#cb666-348" tabindex="-1"></a>   040<span class="co">;&lt;mi&gt;;&lt;ss&gt;;&lt;in&gt;;&lt;g 012</span></span>
<span id="cb666-349"><a aria-hidden="true" href="#cb666-349" tabindex="-1"></a>m8s <span class="op">=</span> <span class="op">.-</span>m8</span>
<span id="cb666-350"><a aria-hidden="true" href="#cb666-350" tabindex="-1"></a></span>
<span id="cb666-351"><a aria-hidden="true" href="#cb666-351" tabindex="-1"></a>" ============================================</span>
<span id="cb666-352"><a aria-hidden="true" href="#cb666-352" tabindex="-1"></a>" VARIABLES <span class="op">AND</span> BUFFERS</span>
<span id="cb666-353"><a aria-hidden="true" href="#cb666-353" tabindex="-1"></a>" ============================================</span>
<span id="cb666-354"><a aria-hidden="true" href="#cb666-354" tabindex="-1"></a></span>
<span id="cb666-355"><a aria-hidden="true" href="#cb666-355" tabindex="-1"></a><span class="fu">usetabp:</span> usetab</span>
<span id="cb666-356"><a aria-hidden="true" href="#cb666-356" tabindex="-1"></a><span class="fu">curi:</span> 0                   " Current inode number</span>
<span id="cb666-357"><a aria-hidden="true" href="#cb666-357" tabindex="-1"></a><span class="fu">bit:</span> 0                    " Bit mask for usage table</span>
<span id="cb666-358"><a aria-hidden="true" href="#cb666-358" tabindex="-1"></a><span class="fu">blcnt:</span> 0                  " Block count</span>
<span id="cb666-359"><a aria-hidden="true" href="#cb666-359" tabindex="-1"></a><span class="fu">indircnt:</span> 0               " Indirect block count</span>
<span id="cb666-360"><a aria-hidden="true" href="#cb666-360" tabindex="-1"></a><span class="fu">icnt:</span> 0                   " Inode count</span>
<span id="cb666-361"><a aria-hidden="true" href="#cb666-361" tabindex="-1"></a><span class="fu">licnt:</span> 0                  " Large <span class="dt">file</span> count</span>
<span id="cb666-362"><a aria-hidden="true" href="#cb666-362" tabindex="-1"></a><span class="fu">t1:</span> 0                     " Temporary variables</span>
<span id="cb666-363"><a aria-hidden="true" href="#cb666-363" tabindex="-1"></a><span class="fu">t2:</span> 0</span>
<span id="cb666-364"><a aria-hidden="true" href="#cb666-364" tabindex="-1"></a><span class="fu">t3:</span> 0</span>
<span id="cb666-365"><a aria-hidden="true" href="#cb666-365" tabindex="-1"></a><span class="fu">t4:</span> 0</span>
<span id="cb666-366"><a aria-hidden="true" href="#cb666-366" tabindex="-1"></a><span class="fu">t5:</span> 0</span>
<span id="cb666-367"><a aria-hidden="true" href="#cb666-367" tabindex="-1"></a><span class="fu">t6:</span> 0</span>
<span id="cb666-368"><a aria-hidden="true" href="#cb666-368" tabindex="-1"></a></span>
<span id="cb666-369"><a aria-hidden="true" href="#cb666-369" tabindex="-1"></a><span class="fu">iget:</span> 0                   " Kernel function pointers</span>
<span id="cb666-370"><a aria-hidden="true" href="#cb666-370" tabindex="-1"></a><span class="fu">nxfblk:</span> 0</span>
<span id="cb666-371"><a aria-hidden="true" href="#cb666-371" tabindex="-1"></a><span class="fu">nfblks:</span> 0</span>
<span id="cb666-372"><a aria-hidden="true" href="#cb666-372" tabindex="-1"></a><span class="fu">fblks:</span> 0</span>
<span id="cb666-373"><a aria-hidden="true" href="#cb666-373" tabindex="-1"></a><span class="fu">copy:</span> 0</span>
<span id="cb666-374"><a aria-hidden="true" href="#cb666-374" tabindex="-1"></a><span class="fu">copyz:</span> 0</span>
<span id="cb666-375"><a aria-hidden="true" href="#cb666-375" tabindex="-1"></a><span class="fu">betwen:</span> 0</span>
<span id="cb666-376"><a aria-hidden="true" href="#cb666-376" tabindex="-1"></a><span class="fu">dskrd:</span> 0</span>
<span id="cb666-377"><a aria-hidden="true" href="#cb666-377" tabindex="-1"></a></span>
<span id="cb666-378"><a aria-hidden="true" href="#cb666-378" tabindex="-1"></a><span class="fu">ldskbuf:</span> .=.+64           " <span class="pp">Local</span> disk buffer <span class="op">(</span><span class="dv">64</span> words<span class="op">)</span></span>
<span id="cb666-379"><a aria-hidden="true" href="#cb666-379" tabindex="-1"></a><span class="fu">linode:</span> .=.+12            " <span class="pp">Local</span> inode buffer <span class="op">(</span><span class="dv">12</span> words<span class="op">)</span></span>
<span id="cb666-380"><a aria-hidden="true" href="#cb666-380" tabindex="-1"></a>iflags <span class="op">=</span> linode           <span class="st">" Inode flags (word 0)</span></span>
<span id="cb666-381"><a aria-hidden="true" href="#cb666-381" tabindex="-1"></a>idskps <span class="op">=</span> iflags<span class="op">+</span><span class="dv">1</span>         <span class="st">" Inode disk block pointers (words 1-7)</span></span>
<span id="cb666-382"><a aria-hidden="true" href="#cb666-382" tabindex="-1"></a><span class="fu">usetab:</span> .=.+500           " Block usage table <span class="op">(</span><span class="dv">500</span> words <span class="op">=</span> <span class="dv">8000</span> bits<span class="op">)</span></span>
<span id="cb666-383"><a aria-hidden="true" href="#cb666-383" tabindex="-1"></a><span class="fu">prbuf:</span> .=.+6              " Print buffer <span class="op">(</span><span class="dv">6</span> characters<span class="op">)</span></span></code></pre></div>
<h4 data-number="9.3.1.2" id="the-bitmap-algorithm"><span class="header-section-number">9.3.1.2</span> The Bitmap Algorithm</h4>
<p>The heart of check is the usage table‚Äîa bitmap tracking which blocks
are allocated:</p>
<pre><code>Block numbers: 709 - 6399 (5691 blocks total)
Bitmap size: 5691 bits = 356 words (rounded to 500)

For block number N:
  Word index = (N - 709) / 16
  Bit index = (N - 709) % 16

Example: Block 1000
  Word index = (1000 - 709) / 16 = 18
  Bit index = (1000 - 709) % 16 = 3

  Word usetab[18], bit 3</code></pre>
<p>The code uses clever self-modifying code:</p>
<div class="sourceCode" id="cb668"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb668-1"><a aria-hidden="true" href="#cb668-1" tabindex="-1"></a>   llss <span class="dv">4</span>                 <span class="st">" Shift left by bit position</span></span>
<span id="cb668-2"><a aria-hidden="true" href="#cb668-2" tabindex="-1"></a>   tad alsscom            <span class="st">" Add to "</span>alss <span class="dv">0</span><span class="st">" instruction</span></span>
<span id="cb668-3"><a aria-hidden="true" href="#cb668-3" tabindex="-1"></a>   dac <span class="fl">2</span><span class="bn">f</span>                 <span class="st">" Store as next instruction</span></span>
<span id="cb668-4"><a aria-hidden="true" href="#cb668-4" tabindex="-1"></a>   lac d1</span>
<span id="cb668-5"><a aria-hidden="true" href="#cb668-5" tabindex="-1"></a>2: alss <span class="dv">0</span>                 <span class="st">" This instruction is modified!</span></span></code></pre></div>
<p>If bit index is 3, this generates:</p>
<div class="sourceCode" id="cb669"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb669-1"><a aria-hidden="true" href="#cb669-1" tabindex="-1"></a>   lac d1                 <span class="st">" AC = 1</span></span>
<span id="cb669-2"><a aria-hidden="true" href="#cb669-2" tabindex="-1"></a>   alss <span class="dv">3</span>                 <span class="st">" AC = 1 &lt;&lt; 3 = 8</span></span></code></pre></div>
<p>Result: a bit mask with bit 3 set.</p>
<h4 data-number="9.3.1.3" id="the-three-phase-algorithm"><span class="header-section-number">9.3.1.3</span> The Three-Phase
Algorithm</h4>
<p><strong>Phase 1: Scan all inodes</strong> - For each allocated inode
- Check all direct blocks (7 per inode) - If large file, check indirect
blocks (7 √ó 64 = 448 blocks max) - Mark each block in usage table - If
already marked: DUPLICATE (fatal error)</p>
<p><strong>Phase 2: Check free block list</strong> - Walk in-core free
list - Follow linked list on disk - Mark each free block - If already
marked: DUPLICATE (shouldn‚Äôt be free!)</p>
<p><strong>Phase 3: Find missing blocks</strong> - Scan entire block
range (709-6399) - Any block not marked is ‚Äúmissing‚Äù - Missing blocks
are allocated but not in any file or free list - These are lost blocks
(can be added back to free list)</p>
<h4 data-number="9.3.1.4" id="duplicate-block-detection"><span class="header-section-number">9.3.1.4</span> Duplicate Block
Detection</h4>
<p>Duplicate blocks are the worst filesystem corruption:</p>
<pre><code>Example:
  Inode 100: contains blocks [1000, 1001, 1002]
  Inode 200: contains blocks [1001, 1003, 1004]

  Block 1001 appears in both inodes!</code></pre>
<p>What happens: 1. Reading is unpredictable (which inode‚Äôs data?) 2.
Writing corrupts both files 3. Deleting one file frees the block,
corrupting the other</p>
<p>check detects this and reports:</p>
<pre><code>1001 dup 100
1001 dup 200</code></pre>
<p>The operator must then manually fix the filesystem (usually by
deleting one or both files).</p>
<h4 data-number="9.3.1.5" id="modern-fsck-descended-from-this"><span class="header-section-number">9.3.1.5</span> Modern fsck Descended From
This</h4>
<p>This 324-line program is the ancestor of: - Unix fsck (file system
check) - Linux e2fsck - macOS fsck_hfs - Windows chkdsk
(conceptually)</p>
<p>The basic algorithm hasn‚Äôt changed in 55 years: 1. Build bitmap of
allocated blocks 2. Check for duplicates 3. Find missing blocks 4.
Verify directory structure 5. Fix what you can</p>
<p>Modern fsck is thousands of lines and handles: - Multiple filesystem
types - Journaling - Extents instead of blocks - Symbolic links -
Extended attributes - Quotas</p>
<p>But the core logic‚Äîscan inodes, mark blocks, find duplicates‚Äîis
identical to the PDP-7 version.</p>
<h3 data-number="9.3.2" id="init.s---system-initialization-and-login"><span class="header-section-number">9.3.2</span> init.s - System
Initialization and Login</h3>
<p><strong>Purpose:</strong> First user-space process; handles login and
starts shells</p>
<p><strong>Lines of Code:</strong> 292</p>
<p><strong>Revolutionary Concepts:</strong></p>
<p>init embodies several revolutionary ideas:</p>
<ol type="1">
<li><strong>First User Process:</strong> Process ID 1, parent of all
user processes</li>
<li><strong>Multi-User Login:</strong> Separate login sessions on
different terminals</li>
<li><strong>Password Authentication:</strong> The birth of Unix
security</li>
<li><strong>Shell Execution:</strong> Loads and runs the command
interpreter</li>
</ol>
<p>In 1969, most systems had at most a single operator console. Unix
supported multiple simultaneous users‚Äîeven on a machine with only two
terminals!</p>
<h4 data-number="9.3.2.1" id="complete-implementation-with-analysis"><span class="header-section-number">9.3.2.1</span> Complete Implementation
with Analysis</h4>
<div class="sourceCode" id="cb672"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb672-1"><a aria-hidden="true" href="#cb672-1" tabindex="-1"></a>" init</span>
<span id="cb672-2"><a aria-hidden="true" href="#cb672-2" tabindex="-1"></a></span>
<span id="cb672-3"><a aria-hidden="true" href="#cb672-3" tabindex="-1"></a>   -1</span>
<span id="cb672-4"><a aria-hidden="true" href="#cb672-4" tabindex="-1"></a>   sys intrp              <span class="st">" Ignore interrupts initially</span></span>
<span id="cb672-5"><a aria-hidden="true" href="#cb672-5" tabindex="-1"></a>   jms init1              <span class="st">" Start terminal 1 login</span></span>
<span id="cb672-6"><a aria-hidden="true" href="#cb672-6" tabindex="-1"></a>   jms init2              <span class="st">" Start terminal 2 login</span></span>
<span id="cb672-7"><a aria-hidden="true" href="#cb672-7" tabindex="-1"></a>1:</span>
<span id="cb672-8"><a aria-hidden="true" href="#cb672-8" tabindex="-1"></a>   sys rmes               <span class="st">" Wait for child to exit (receive message)</span></span>
<span id="cb672-9"><a aria-hidden="true" href="#cb672-9" tabindex="-1"></a>   sad pid1               <span class="st">" Skip if different from terminal 1 PID</span></span>
<span id="cb672-10"><a aria-hidden="true" href="#cb672-10" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">1</span><span class="bn">f</span></span>
<span id="cb672-11"><a aria-hidden="true" href="#cb672-11" tabindex="-1"></a>   sad pid2               <span class="st">" Skip if different from terminal 2 PID</span></span>
<span id="cb672-12"><a aria-hidden="true" href="#cb672-12" tabindex="-1"></a>   jms init2              <span class="st">" Terminal 2 exited, restart it</span></span>
<span id="cb672-13"><a aria-hidden="true" href="#cb672-13" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="dv">1</span>                  <span class="st">" Wait for next exit</span></span>
<span id="cb672-14"><a aria-hidden="true" href="#cb672-14" tabindex="-1"></a></span>
<span id="cb672-15"><a aria-hidden="true" href="#cb672-15" tabindex="-1"></a>1:</span>
<span id="cb672-16"><a aria-hidden="true" href="#cb672-16" tabindex="-1"></a>   jms init1              <span class="st">" Terminal 1 exited, restart it</span></span>
<span id="cb672-17"><a aria-hidden="true" href="#cb672-17" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="dv">1</span>                  <span class="st">" Continue waiting</span></span>
<span id="cb672-18"><a aria-hidden="true" href="#cb672-18" tabindex="-1"></a></span>
<span id="cb672-19"><a aria-hidden="true" href="#cb672-19" tabindex="-1"></a>" ============================================</span>
<span id="cb672-20"><a aria-hidden="true" href="#cb672-20" tabindex="-1"></a>" INIT1<span class="op">:</span> Initialize terminal <span class="dv">1</span> <span class="op">(</span>TTY<span class="op">)</span></span>
<span id="cb672-21"><a aria-hidden="true" href="#cb672-21" tabindex="-1"></a>" ============================================</span>
<span id="cb672-22"><a aria-hidden="true" href="#cb672-22" tabindex="-1"></a></span>
<span id="cb672-23"><a aria-hidden="true" href="#cb672-23" tabindex="-1"></a><span class="fu">init1:</span> 0</span>
<span id="cb672-24"><a aria-hidden="true" href="#cb672-24" tabindex="-1"></a>   sys fork               <span class="st">" Create child process</span></span>
<span id="cb672-25"><a aria-hidden="true" href="#cb672-25" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">1</span><span class="bn">f</span>                 <span class="st">" Parent continues here</span></span>
<span id="cb672-26"><a aria-hidden="true" href="#cb672-26" tabindex="-1"></a>   sys open<span class="co">; ttyin; 0     " Child: open TTY input (FD 0 = stdin)</span></span>
<span id="cb672-27"><a aria-hidden="true" href="#cb672-27" tabindex="-1"></a>   sys open<span class="co">; ttyout; 1    " Open TTY output (FD 1 = stdout)</span></span>
<span id="cb672-28"><a aria-hidden="true" href="#cb672-28" tabindex="-1"></a>   <span class="cf">jmp</span> login              <span class="st">" Go to login process</span></span>
<span id="cb672-29"><a aria-hidden="true" href="#cb672-29" tabindex="-1"></a>1:</span>
<span id="cb672-30"><a aria-hidden="true" href="#cb672-30" tabindex="-1"></a>   dac pid1               <span class="st">" Parent: save child PID</span></span>
<span id="cb672-31"><a aria-hidden="true" href="#cb672-31" tabindex="-1"></a>   <span class="cf">jmp</span> init1 i            <span class="st">" Return</span></span>
<span id="cb672-32"><a aria-hidden="true" href="#cb672-32" tabindex="-1"></a></span>
<span id="cb672-33"><a aria-hidden="true" href="#cb672-33" tabindex="-1"></a>" ============================================</span>
<span id="cb672-34"><a aria-hidden="true" href="#cb672-34" tabindex="-1"></a>" INIT2<span class="op">:</span> Initialize terminal <span class="dv">2</span> <span class="op">(</span>Display<span class="op">)</span></span>
<span id="cb672-35"><a aria-hidden="true" href="#cb672-35" tabindex="-1"></a>" ============================================</span>
<span id="cb672-36"><a aria-hidden="true" href="#cb672-36" tabindex="-1"></a></span>
<span id="cb672-37"><a aria-hidden="true" href="#cb672-37" tabindex="-1"></a><span class="fu">init2:</span> 0</span>
<span id="cb672-38"><a aria-hidden="true" href="#cb672-38" tabindex="-1"></a>   sys fork               <span class="st">" Create child process</span></span>
<span id="cb672-39"><a aria-hidden="true" href="#cb672-39" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">1</span><span class="bn">f</span>                 <span class="st">" Parent continues here</span></span>
<span id="cb672-40"><a aria-hidden="true" href="#cb672-40" tabindex="-1"></a>   sys open<span class="co">; keybd; 0     " Child: open keyboard (FD 0)</span></span>
<span id="cb672-41"><a aria-hidden="true" href="#cb672-41" tabindex="-1"></a>   sys open<span class="co">; displ; 1     " Open display (FD 1)</span></span>
<span id="cb672-42"><a aria-hidden="true" href="#cb672-42" tabindex="-1"></a>   <span class="cf">jmp</span> login              <span class="st">" Go to login process</span></span>
<span id="cb672-43"><a aria-hidden="true" href="#cb672-43" tabindex="-1"></a>1:</span>
<span id="cb672-44"><a aria-hidden="true" href="#cb672-44" tabindex="-1"></a>   dac pid2               <span class="st">" Parent: save child PID</span></span>
<span id="cb672-45"><a aria-hidden="true" href="#cb672-45" tabindex="-1"></a>   <span class="cf">jmp</span> init2 i            <span class="st">" Return</span></span>
<span id="cb672-46"><a aria-hidden="true" href="#cb672-46" tabindex="-1"></a></span>
<span id="cb672-47"><a aria-hidden="true" href="#cb672-47" tabindex="-1"></a>" ============================================</span>
<span id="cb672-48"><a aria-hidden="true" href="#cb672-48" tabindex="-1"></a>" LOGIN<span class="op">:</span> Handle user authentication</span>
<span id="cb672-49"><a aria-hidden="true" href="#cb672-49" tabindex="-1"></a>" ============================================</span>
<span id="cb672-50"><a aria-hidden="true" href="#cb672-50" tabindex="-1"></a></span>
<span id="cb672-51"><a aria-hidden="true" href="#cb672-51" tabindex="-1"></a><span class="fu">login:</span></span>
<span id="cb672-52"><a aria-hidden="true" href="#cb672-52" tabindex="-1"></a>   -1</span>
<span id="cb672-53"><a aria-hidden="true" href="#cb672-53" tabindex="-1"></a>   sys intrp              <span class="st">" Ignore interrupts during login</span></span>
<span id="cb672-54"><a aria-hidden="true" href="#cb672-54" tabindex="-1"></a>   sys open<span class="co">; password; 0  " Open password file (FD 2)</span></span>
<span id="cb672-55"><a aria-hidden="true" href="#cb672-55" tabindex="-1"></a>   lac d1</span>
<span id="cb672-56"><a aria-hidden="true" href="#cb672-56" tabindex="-1"></a>   sys write<span class="co">; m1; m1s     " Write "login: "</span></span>
<span id="cb672-57"><a aria-hidden="true" href="#cb672-57" tabindex="-1"></a>   jms rline              <span class="st">" Read username from terminal</span></span>
<span id="cb672-58"><a aria-hidden="true" href="#cb672-58" tabindex="-1"></a>   lac ebufp</span>
<span id="cb672-59"><a aria-hidden="true" href="#cb672-59" tabindex="-1"></a>   dac tal                <span class="st">" Save end of buffer pointer</span></span>
<span id="cb672-60"><a aria-hidden="true" href="#cb672-60" tabindex="-1"></a>1:</span>
<span id="cb672-61"><a aria-hidden="true" href="#cb672-61" tabindex="-1"></a>   jms gline              <span class="st">" Get line from password file</span></span>
<span id="cb672-62"><a aria-hidden="true" href="#cb672-62" tabindex="-1"></a>   law ibuf<span class="op">-</span><span class="dv">1</span>             <span class="st">" Point to input buffer (username)</span></span>
<span id="cb672-63"><a aria-hidden="true" href="#cb672-63" tabindex="-1"></a>   dac <span class="dv">8</span></span>
<span id="cb672-64"><a aria-hidden="true" href="#cb672-64" tabindex="-1"></a>   law obuf<span class="op">-</span><span class="dv">1</span>             <span class="st">" Point to password file line</span></span>
<span id="cb672-65"><a aria-hidden="true" href="#cb672-65" tabindex="-1"></a>   dac <span class="dv">9</span></span>
<span id="cb672-66"><a aria-hidden="true" href="#cb672-66" tabindex="-1"></a></span>
<span id="cb672-67"><a aria-hidden="true" href="#cb672-67" tabindex="-1"></a>" <span class="bu">Compare</span> username with password <span class="dt">file</span> entry</span>
<span id="cb672-68"><a aria-hidden="true" href="#cb672-68" tabindex="-1"></a>2:</span>
<span id="cb672-69"><a aria-hidden="true" href="#cb672-69" tabindex="-1"></a>   lac <span class="dv">8</span> i                <span class="st">" Load character from input</span></span>
<span id="cb672-70"><a aria-hidden="true" href="#cb672-70" tabindex="-1"></a>   sac o12                <span class="st">" Skip if different from '\n'</span></span>
<span id="cb672-71"><a aria-hidden="true" href="#cb672-71" tabindex="-1"></a>   lac o72                <span class="st">" Load ':'</span></span>
<span id="cb672-72"><a aria-hidden="true" href="#cb672-72" tabindex="-1"></a>   sad <span class="dv">9</span> i                <span class="st">" Skip if different from password file</span></span>
<span id="cb672-73"><a aria-hidden="true" href="#cb672-73" tabindex="-1"></a>   skp</span>
<span id="cb672-74"><a aria-hidden="true" href="#cb672-74" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span>                 <span class="st">" No match, try next line</span></span>
<span id="cb672-75"><a aria-hidden="true" href="#cb672-75" tabindex="-1"></a>   sad o72                <span class="st">" Skip if it was ':'</span></span>
<span id="cb672-76"><a aria-hidden="true" href="#cb672-76" tabindex="-1"></a>   skp</span>
<span id="cb672-77"><a aria-hidden="true" href="#cb672-77" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="dv">2</span><span class="er">b</span>                 <span class="st">" Continue comparing username</span></span>
<span id="cb672-78"><a aria-hidden="true" href="#cb672-78" tabindex="-1"></a>   lac <span class="dv">9</span> i                <span class="st">" Get next character from password file</span></span>
<span id="cb672-79"><a aria-hidden="true" href="#cb672-79" tabindex="-1"></a>   sad o72                <span class="st">" Skip if different from ':'</span></span>
<span id="cb672-80"><a aria-hidden="true" href="#cb672-80" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">1</span><span class="bn">f</span>                 <span class="st">" Username matches, check password</span></span>
<span id="cb672-81"><a aria-hidden="true" href="#cb672-81" tabindex="-1"></a></span>
<span id="cb672-82"><a aria-hidden="true" href="#cb672-82" tabindex="-1"></a>" Username matched but wrong terminator</span>
<span id="cb672-83"><a aria-hidden="true" href="#cb672-83" tabindex="-1"></a>   -1</span>
<span id="cb672-84"><a aria-hidden="true" href="#cb672-84" tabindex="-1"></a>   tad <span class="dv">9</span></span>
<span id="cb672-85"><a aria-hidden="true" href="#cb672-85" tabindex="-1"></a>   dac <span class="dv">9</span></span>
<span id="cb672-86"><a aria-hidden="true" href="#cb672-86" tabindex="-1"></a>   lac d1</span>
<span id="cb672-87"><a aria-hidden="true" href="#cb672-87" tabindex="-1"></a>   sys write<span class="co">; m3; m3s     " Write "password: "</span></span>
<span id="cb672-88"><a aria-hidden="true" href="#cb672-88" tabindex="-1"></a>   jms rline              <span class="st">" Read password</span></span>
<span id="cb672-89"><a aria-hidden="true" href="#cb672-89" tabindex="-1"></a>   law ibuf<span class="op">-</span><span class="dv">1</span></span>
<span id="cb672-90"><a aria-hidden="true" href="#cb672-90" tabindex="-1"></a>   dac <span class="dv">8</span></span>
<span id="cb672-91"><a aria-hidden="true" href="#cb672-91" tabindex="-1"></a></span>
<span id="cb672-92"><a aria-hidden="true" href="#cb672-92" tabindex="-1"></a>" <span class="bu">Compare</span> password</span>
<span id="cb672-93"><a aria-hidden="true" href="#cb672-93" tabindex="-1"></a>2:</span>
<span id="cb672-94"><a aria-hidden="true" href="#cb672-94" tabindex="-1"></a>   lac <span class="dv">8</span> i                <span class="st">" Load character from input</span></span>
<span id="cb672-95"><a aria-hidden="true" href="#cb672-95" tabindex="-1"></a>   sad o12                <span class="st">" Skip if different from '\n'</span></span>
<span id="cb672-96"><a aria-hidden="true" href="#cb672-96" tabindex="-1"></a>   lac o72                <span class="st">" Load ':'</span></span>
<span id="cb672-97"><a aria-hidden="true" href="#cb672-97" tabindex="-1"></a>   sad <span class="dv">9</span> i                <span class="st">" Skip if different from password file</span></span>
<span id="cb672-98"><a aria-hidden="true" href="#cb672-98" tabindex="-1"></a>   skp</span>
<span id="cb672-99"><a aria-hidden="true" href="#cb672-99" tabindex="-1"></a>   <span class="cf">jmp</span> error              <span class="st">" Password mismatch - error</span></span>
<span id="cb672-100"><a aria-hidden="true" href="#cb672-100" tabindex="-1"></a>   sad o72                <span class="st">" Skip if it was ':'</span></span>
<span id="cb672-101"><a aria-hidden="true" href="#cb672-101" tabindex="-1"></a>   skp</span>
<span id="cb672-102"><a aria-hidden="true" href="#cb672-102" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="dv">2</span><span class="er">b</span>                 <span class="st">" Continue comparing password</span></span>
<span id="cb672-103"><a aria-hidden="true" href="#cb672-103" tabindex="-1"></a></span>
<span id="cb672-104"><a aria-hidden="true" href="#cb672-104" tabindex="-1"></a>" ============================================</span>
<span id="cb672-105"><a aria-hidden="true" href="#cb672-105" tabindex="-1"></a>" PASSWORD ENTRY PARSING</span>
<span id="cb672-106"><a aria-hidden="true" href="#cb672-106" tabindex="-1"></a>" Extract home directory <span class="op">and</span> UID from password entry</span>
<span id="cb672-107"><a aria-hidden="true" href="#cb672-107" tabindex="-1"></a>" <span class="bu">Format</span><span class="op">:</span> username<span class="op">:</span>password<span class="op">:</span>uid<span class="op">:</span>directory</span>
<span id="cb672-108"><a aria-hidden="true" href="#cb672-108" tabindex="-1"></a>" ============================================</span>
<span id="cb672-109"><a aria-hidden="true" href="#cb672-109" tabindex="-1"></a></span>
<span id="cb672-110"><a aria-hidden="true" href="#cb672-110" tabindex="-1"></a>1:</span>
<span id="cb672-111"><a aria-hidden="true" href="#cb672-111" tabindex="-1"></a>   dzm nchar              <span class="st">" Clear character buffer</span></span>
<span id="cb672-112"><a aria-hidden="true" href="#cb672-112" tabindex="-1"></a>   law dir<span class="op">-</span><span class="dv">1</span>              <span class="st">" Point to directory name buffer</span></span>
<span id="cb672-113"><a aria-hidden="true" href="#cb672-113" tabindex="-1"></a>   dac <span class="dv">8</span></span>
<span id="cb672-114"><a aria-hidden="true" href="#cb672-114" tabindex="-1"></a>1:</span>
<span id="cb672-115"><a aria-hidden="true" href="#cb672-115" tabindex="-1"></a>   lac <span class="dv">9</span> i                <span class="st">" Get character from password file</span></span>
<span id="cb672-116"><a aria-hidden="true" href="#cb672-116" tabindex="-1"></a>   sad o72                <span class="st">" Skip if different from ':'</span></span>
<span id="cb672-117"><a aria-hidden="true" href="#cb672-117" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">1</span><span class="bn">f</span>                 <span class="st">" Found ':', done with directory</span></span>
<span id="cb672-118"><a aria-hidden="true" href="#cb672-118" tabindex="-1"></a>   dac char               <span class="st">" Save character</span></span>
<span id="cb672-119"><a aria-hidden="true" href="#cb672-119" tabindex="-1"></a>   lac nchar</span>
<span id="cb672-120"><a aria-hidden="true" href="#cb672-120" tabindex="-1"></a>   sza                    <span class="st">" Skip if zero (need new word)</span></span>
<span id="cb672-121"><a aria-hidden="true" href="#cb672-121" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">2</span><span class="bn">f</span>                 <span class="st">" Already have character in word</span></span>
<span id="cb672-122"><a aria-hidden="true" href="#cb672-122" tabindex="-1"></a></span>
<span id="cb672-123"><a aria-hidden="true" href="#cb672-123" tabindex="-1"></a>" Pack first character of a <span class="dt">word</span> <span class="op">(</span>high <span class="dv">9</span> bits<span class="op">)</span></span>
<span id="cb672-124"><a aria-hidden="true" href="#cb672-124" tabindex="-1"></a>   lac char</span>
<span id="cb672-125"><a aria-hidden="true" href="#cb672-125" tabindex="-1"></a>   alss <span class="dv">9</span>                 <span class="st">" Shift left 9 bits</span></span>
<span id="cb672-126"><a aria-hidden="true" href="#cb672-126" tabindex="-1"></a>   <span class="bu">xor</span> o40                <span class="st">" XOR with space (padding)</span></span>
<span id="cb672-127"><a aria-hidden="true" href="#cb672-127" tabindex="-1"></a>   dac <span class="dv">8</span> i                <span class="st">" Store in directory buffer</span></span>
<span id="cb672-128"><a aria-hidden="true" href="#cb672-128" tabindex="-1"></a>   dac nchar              <span class="st">" Save as current character</span></span>
<span id="cb672-129"><a aria-hidden="true" href="#cb672-129" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span></span>
<span id="cb672-130"><a aria-hidden="true" href="#cb672-130" tabindex="-1"></a></span>
<span id="cb672-131"><a aria-hidden="true" href="#cb672-131" tabindex="-1"></a>" Pack second character of a <span class="dt">word</span> <span class="op">(</span>low <span class="dv">9</span> bits<span class="op">)</span></span>
<span id="cb672-132"><a aria-hidden="true" href="#cb672-132" tabindex="-1"></a>2:</span>
<span id="cb672-133"><a aria-hidden="true" href="#cb672-133" tabindex="-1"></a>   lac <span class="dv">8</span>                  <span class="st">" Get current buffer pointer</span></span>
<span id="cb672-134"><a aria-hidden="true" href="#cb672-134" tabindex="-1"></a>   dac nchar              <span class="st">" Save as character position</span></span>
<span id="cb672-135"><a aria-hidden="true" href="#cb672-135" tabindex="-1"></a>   lac nchar i            <span class="st">" Load existing word</span></span>
<span id="cb672-136"><a aria-hidden="true" href="#cb672-136" tabindex="-1"></a>   <span class="bu">and</span> o777000            <span class="st">" Mask low 9 bits</span></span>
<span id="cb672-137"><a aria-hidden="true" href="#cb672-137" tabindex="-1"></a>   <span class="bu">xor</span> char               <span class="st">" OR in new character</span></span>
<span id="cb672-138"><a aria-hidden="true" href="#cb672-138" tabindex="-1"></a>   dac nchar i            <span class="st">" Store back</span></span>
<span id="cb672-139"><a aria-hidden="true" href="#cb672-139" tabindex="-1"></a>   dzm nchar              <span class="st">" Clear character buffer</span></span>
<span id="cb672-140"><a aria-hidden="true" href="#cb672-140" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span></span>
<span id="cb672-141"><a aria-hidden="true" href="#cb672-141" tabindex="-1"></a></span>
<span id="cb672-142"><a aria-hidden="true" href="#cb672-142" tabindex="-1"></a>" ============================================</span>
<span id="cb672-143"><a aria-hidden="true" href="#cb672-143" tabindex="-1"></a>" UID PARSING</span>
<span id="cb672-144"><a aria-hidden="true" href="#cb672-144" tabindex="-1"></a>" Extract user ID in octal</span>
<span id="cb672-145"><a aria-hidden="true" href="#cb672-145" tabindex="-1"></a>" ============================================</span>
<span id="cb672-146"><a aria-hidden="true" href="#cb672-146" tabindex="-1"></a></span>
<span id="cb672-147"><a aria-hidden="true" href="#cb672-147" tabindex="-1"></a>1:</span>
<span id="cb672-148"><a aria-hidden="true" href="#cb672-148" tabindex="-1"></a>   dzm nchar              <span class="st">" Clear octal accumulator</span></span>
<span id="cb672-149"><a aria-hidden="true" href="#cb672-149" tabindex="-1"></a>1:</span>
<span id="cb672-150"><a aria-hidden="true" href="#cb672-150" tabindex="-1"></a>   lac <span class="dv">9</span> i                <span class="st">" Get character</span></span>
<span id="cb672-151"><a aria-hidden="true" href="#cb672-151" tabindex="-1"></a>   sad o12                <span class="st">" Skip if different from '\n'</span></span>
<span id="cb672-152"><a aria-hidden="true" href="#cb672-152" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">2</span><span class="bn">f</span>                 <span class="st">" End of line, done</span></span>
<span id="cb672-153"><a aria-hidden="true" href="#cb672-153" tabindex="-1"></a>   tad om60               <span class="st">" Subtract '0'</span></span>
<span id="cb672-154"><a aria-hidden="true" href="#cb672-154" tabindex="-1"></a>   lmq                    <span class="st">" Save digit in MQ</span></span>
<span id="cb672-155"><a aria-hidden="true" href="#cb672-155" tabindex="-1"></a>   lac nchar              <span class="st">" Get current value</span></span>
<span id="cb672-156"><a aria-hidden="true" href="#cb672-156" tabindex="-1"></a>   cll<span class="co">; als 3             " Shift left 3 bits (multiply by 8)</span></span>
<span id="cb672-157"><a aria-hidden="true" href="#cb672-157" tabindex="-1"></a>   omq                    <span class="st">" OR in new digit</span></span>
<span id="cb672-158"><a aria-hidden="true" href="#cb672-158" tabindex="-1"></a>   dac nchar              <span class="st">" Save result</span></span>
<span id="cb672-159"><a aria-hidden="true" href="#cb672-159" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span></span>
<span id="cb672-160"><a aria-hidden="true" href="#cb672-160" tabindex="-1"></a></span>
<span id="cb672-161"><a aria-hidden="true" href="#cb672-161" tabindex="-1"></a>" ============================================</span>
<span id="cb672-162"><a aria-hidden="true" href="#cb672-162" tabindex="-1"></a>" <span class="bu">SET</span> USER CONTEXT <span class="op">AND</span> EXECUTE SHELL</span>
<span id="cb672-163"><a aria-hidden="true" href="#cb672-163" tabindex="-1"></a>" ============================================</span>
<span id="cb672-164"><a aria-hidden="true" href="#cb672-164" tabindex="-1"></a></span>
<span id="cb672-165"><a aria-hidden="true" href="#cb672-165" tabindex="-1"></a>2:</span>
<span id="cb672-166"><a aria-hidden="true" href="#cb672-166" tabindex="-1"></a>   lac nchar</span>
<span id="cb672-167"><a aria-hidden="true" href="#cb672-167" tabindex="-1"></a>   sys setuid             <span class="st">" Set user ID</span></span>
<span id="cb672-168"><a aria-hidden="true" href="#cb672-168" tabindex="-1"></a>   sys chdir<span class="co">; dd          " Change to root</span></span>
<span id="cb672-169"><a aria-hidden="true" href="#cb672-169" tabindex="-1"></a>   sys chdir<span class="co">; dir         " Change to user's home directory</span></span>
<span id="cb672-170"><a aria-hidden="true" href="#cb672-170" tabindex="-1"></a></span>
<span id="cb672-171"><a aria-hidden="true" href="#cb672-171" tabindex="-1"></a>" Open shell executable</span>
<span id="cb672-172"><a aria-hidden="true" href="#cb672-172" tabindex="-1"></a>   lac d2</span>
<span id="cb672-173"><a aria-hidden="true" href="#cb672-173" tabindex="-1"></a>   sys close              <span class="st">" Close password file (FD 2)</span></span>
<span id="cb672-174"><a aria-hidden="true" href="#cb672-174" tabindex="-1"></a>   sys open<span class="co">; sh; 0        " Try to open "sh" (shell)</span></span>
<span id="cb672-175"><a aria-hidden="true" href="#cb672-175" tabindex="-1"></a>   sma                    <span class="st">" Skip if minus (failed)</span></span>
<span id="cb672-176"><a aria-hidden="true" href="#cb672-176" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">1</span><span class="bn">f</span>                 <span class="st">" Shell exists, use it</span></span>
<span id="cb672-177"><a aria-hidden="true" href="#cb672-177" tabindex="-1"></a></span>
<span id="cb672-178"><a aria-hidden="true" href="#cb672-178" tabindex="-1"></a>" Shell doesn<span class="st">'t exist in user dir, link from system</span></span>
<span id="cb672-179"><a aria-hidden="true" href="#cb672-179" tabindex="-1"></a>   sys link<span class="co">; system; sh; sh  " Link /dd/system/sh to ./sh</span></span>
<span id="cb672-180"><a aria-hidden="true" href="#cb672-180" tabindex="-1"></a>   spa                    <span class="st">" Skip on positive (success)</span></span>
<span id="cb672-181"><a aria-hidden="true" href="#cb672-181" tabindex="-1"></a>   <span class="cf">jmp</span> error              <span class="st">" Link failed</span></span>
<span id="cb672-182"><a aria-hidden="true" href="#cb672-182" tabindex="-1"></a>   sys open<span class="co">; sh; 0        " Open the linked shell</span></span>
<span id="cb672-183"><a aria-hidden="true" href="#cb672-183" tabindex="-1"></a>   spa                    <span class="st">" Skip on positive (success)</span></span>
<span id="cb672-184"><a aria-hidden="true" href="#cb672-184" tabindex="-1"></a>   <span class="cf">jmp</span> error              <span class="st">" Open failed</span></span>
<span id="cb672-185"><a aria-hidden="true" href="#cb672-185" tabindex="-1"></a>   sys unlink<span class="co">; sh         " Unlink ./sh (already open)</span></span>
<span id="cb672-186"><a aria-hidden="true" href="#cb672-186" tabindex="-1"></a></span>
<span id="cb672-187"><a aria-hidden="true" href="#cb672-187" tabindex="-1"></a>" ============================================</span>
<span id="cb672-188"><a aria-hidden="true" href="#cb672-188" tabindex="-1"></a>" BOOTSTRAP SHELL EXECUTION</span>
<span id="cb672-189"><a aria-hidden="true" href="#cb672-189" tabindex="-1"></a>" The shell code is read into memory starting at <span class="dv">017700</span></span>
<span id="cb672-190"><a aria-hidden="true" href="#cb672-190" tabindex="-1"></a>" Then jumped to<span class="op">,</span> effectively exec<span class="st">'ing it</span></span>
<span id="cb672-191"><a aria-hidden="true" href="#cb672-191" tabindex="-1"></a>" ============================================</span>
<span id="cb672-192"><a aria-hidden="true" href="#cb672-192" tabindex="-1"></a></span>
<span id="cb672-193"><a aria-hidden="true" href="#cb672-193" tabindex="-1"></a>1:</span>
<span id="cb672-194"><a aria-hidden="true" href="#cb672-194" tabindex="-1"></a>   law <span class="dv">017700</span>             <span class="st">" Destination address for shell</span></span>
<span id="cb672-195"><a aria-hidden="true" href="#cb672-195" tabindex="-1"></a>   dac <span class="dv">9</span></span>
<span id="cb672-196"><a aria-hidden="true" href="#cb672-196" tabindex="-1"></a>   law boot<span class="op">-</span><span class="dv">1</span>             <span class="st">" Source: bootstrap code</span></span>
<span id="cb672-197"><a aria-hidden="true" href="#cb672-197" tabindex="-1"></a>   dac <span class="dv">8</span></span>
<span id="cb672-198"><a aria-hidden="true" href="#cb672-198" tabindex="-1"></a>1:</span>
<span id="cb672-199"><a aria-hidden="true" href="#cb672-199" tabindex="-1"></a>   lac <span class="dv">8</span> i                <span class="st">" Copy bootstrap code</span></span>
<span id="cb672-200"><a aria-hidden="true" href="#cb672-200" tabindex="-1"></a>   dac <span class="dv">9</span> i</span>
<span id="cb672-201"><a aria-hidden="true" href="#cb672-201" tabindex="-1"></a>   sza                    <span class="st">" Skip if zero (end marker)</span></span>
<span id="cb672-202"><a aria-hidden="true" href="#cb672-202" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span></span>
<span id="cb672-203"><a aria-hidden="true" href="#cb672-203" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="dv">017701</span>             <span class="st">" Jump to bootstrap code</span></span>
<span id="cb672-204"><a aria-hidden="true" href="#cb672-204" tabindex="-1"></a></span>
<span id="cb672-205"><a aria-hidden="true" href="#cb672-205" tabindex="-1"></a>" Bootstrap code <span class="op">(</span>copied to high memory <span class="op">and</span> executed<span class="op">)</span></span>
<span id="cb672-206"><a aria-hidden="true" href="#cb672-206" tabindex="-1"></a><span class="fu">boot:</span></span>
<span id="cb672-207"><a aria-hidden="true" href="#cb672-207" tabindex="-1"></a>   lac d2                 <span class="st">" FD 2 (shell file)</span></span>
<span id="cb672-208"><a aria-hidden="true" href="#cb672-208" tabindex="-1"></a>   lmq</span>
<span id="cb672-209"><a aria-hidden="true" href="#cb672-209" tabindex="-1"></a>   sys read<span class="co">; 4096; 07700  " Read shell into memory at 4096</span></span>
<span id="cb672-210"><a aria-hidden="true" href="#cb672-210" tabindex="-1"></a>   lacq</span>
<span id="cb672-211"><a aria-hidden="true" href="#cb672-211" tabindex="-1"></a>   sys close              <span class="st">" Close shell file</span></span>
<span id="cb672-212"><a aria-hidden="true" href="#cb672-212" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="dv">4096</span>               <span class="st">" Jump to shell entry point</span></span>
<span id="cb672-213"><a aria-hidden="true" href="#cb672-213" tabindex="-1"></a>   0                      " <span class="pp">End</span> marker</span>
<span id="cb672-214"><a aria-hidden="true" href="#cb672-214" tabindex="-1"></a></span>
<span id="cb672-215"><a aria-hidden="true" href="#cb672-215" tabindex="-1"></a>" ============================================</span>
<span id="cb672-216"><a aria-hidden="true" href="#cb672-216" tabindex="-1"></a>" RLINE<span class="op">:</span> Read line from terminal</span>
<span id="cb672-217"><a aria-hidden="true" href="#cb672-217" tabindex="-1"></a>" Handles backspace <span class="op">(</span><span class="dv">043</span><span class="op">)</span> <span class="op">and</span> line kill <span class="op">(</span><span class="dv">0100</span><span class="op">)</span></span>
<span id="cb672-218"><a aria-hidden="true" href="#cb672-218" tabindex="-1"></a>" ============================================</span>
<span id="cb672-219"><a aria-hidden="true" href="#cb672-219" tabindex="-1"></a></span>
<span id="cb672-220"><a aria-hidden="true" href="#cb672-220" tabindex="-1"></a><span class="fu">rline:</span> 0</span>
<span id="cb672-221"><a aria-hidden="true" href="#cb672-221" tabindex="-1"></a>   law ibuf<span class="op">-</span><span class="dv">1</span>             <span class="st">" Point to input buffer</span></span>
<span id="cb672-222"><a aria-hidden="true" href="#cb672-222" tabindex="-1"></a>   dac <span class="dv">8</span></span>
<span id="cb672-223"><a aria-hidden="true" href="#cb672-223" tabindex="-1"></a>1:</span>
<span id="cb672-224"><a aria-hidden="true" href="#cb672-224" tabindex="-1"></a>   cla</span>
<span id="cb672-225"><a aria-hidden="true" href="#cb672-225" tabindex="-1"></a>   sys read<span class="co">; char; 1      " Read one character</span></span>
<span id="cb672-226"><a aria-hidden="true" href="#cb672-226" tabindex="-1"></a>   lac char</span>
<span id="cb672-227"><a aria-hidden="true" href="#cb672-227" tabindex="-1"></a>   lrss <span class="dv">9</span>                 <span class="st">" Get high byte (first character)</span></span>
<span id="cb672-228"><a aria-hidden="true" href="#cb672-228" tabindex="-1"></a>   sad o100               <span class="st">" Skip if different from line kill (@)</span></span>
<span id="cb672-229"><a aria-hidden="true" href="#cb672-229" tabindex="-1"></a>   <span class="cf">jmp</span> rline<span class="op">+</span><span class="dv">1</span>            <span class="st">" Line kill - start over</span></span>
<span id="cb672-230"><a aria-hidden="true" href="#cb672-230" tabindex="-1"></a>   sad o43                <span class="st">" Skip if different from backspace (#)</span></span>
<span id="cb672-231"><a aria-hidden="true" href="#cb672-231" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">2</span><span class="bn">f</span>                 <span class="st">" Backspace</span></span>
<span id="cb672-232"><a aria-hidden="true" href="#cb672-232" tabindex="-1"></a>   dac <span class="dv">8</span> i                <span class="st">" Store character in buffer</span></span>
<span id="cb672-233"><a aria-hidden="true" href="#cb672-233" tabindex="-1"></a>   sad o12                <span class="st">" Skip if different from '\n'</span></span>
<span id="cb672-234"><a aria-hidden="true" href="#cb672-234" tabindex="-1"></a>   <span class="cf">jmp</span> rline i            <span class="st">" End of line, return</span></span>
<span id="cb672-235"><a aria-hidden="true" href="#cb672-235" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span>                 <span class="st">" Continue</span></span>
<span id="cb672-236"><a aria-hidden="true" href="#cb672-236" tabindex="-1"></a></span>
<span id="cb672-237"><a aria-hidden="true" href="#cb672-237" tabindex="-1"></a>2:</span>
<span id="cb672-238"><a aria-hidden="true" href="#cb672-238" tabindex="-1"></a>   law ibuf<span class="op">-</span><span class="dv">1</span>             <span class="st">" Backspace handling</span></span>
<span id="cb672-239"><a aria-hidden="true" href="#cb672-239" tabindex="-1"></a>   sad <span class="dv">8</span>                  <span class="st">" Skip if different (not at start)</span></span>
<span id="cb672-240"><a aria-hidden="true" href="#cb672-240" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span>                 <span class="st">" At start, ignore backspace</span></span>
<span id="cb672-241"><a aria-hidden="true" href="#cb672-241" tabindex="-1"></a>   -1                     " Back up one character</span>
<span id="cb672-242"><a aria-hidden="true" href="#cb672-242" tabindex="-1"></a>   tad <span class="dv">8</span></span>
<span id="cb672-243"><a aria-hidden="true" href="#cb672-243" tabindex="-1"></a>   dac <span class="dv">8</span></span>
<span id="cb672-244"><a aria-hidden="true" href="#cb672-244" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span></span>
<span id="cb672-245"><a aria-hidden="true" href="#cb672-245" tabindex="-1"></a></span>
<span id="cb672-246"><a aria-hidden="true" href="#cb672-246" tabindex="-1"></a>" ============================================</span>
<span id="cb672-247"><a aria-hidden="true" href="#cb672-247" tabindex="-1"></a>" GLINE<span class="op">:</span> Get line from password <span class="dt">file</span> <span class="op">(</span>FD <span class="dv">2</span><span class="op">)</span></span>
<span id="cb672-248"><a aria-hidden="true" href="#cb672-248" tabindex="-1"></a>" ============================================</span>
<span id="cb672-249"><a aria-hidden="true" href="#cb672-249" tabindex="-1"></a></span>
<span id="cb672-250"><a aria-hidden="true" href="#cb672-250" tabindex="-1"></a><span class="fu">gline:</span> 0</span>
<span id="cb672-251"><a aria-hidden="true" href="#cb672-251" tabindex="-1"></a>   law obuf<span class="op">-</span><span class="dv">1</span>             <span class="st">" Point to output buffer</span></span>
<span id="cb672-252"><a aria-hidden="true" href="#cb672-252" tabindex="-1"></a>   dac <span class="dv">8</span></span>
<span id="cb672-253"><a aria-hidden="true" href="#cb672-253" tabindex="-1"></a>1:</span>
<span id="cb672-254"><a aria-hidden="true" href="#cb672-254" tabindex="-1"></a>   jms gchar              <span class="st">" Get character from file</span></span>
<span id="cb672-255"><a aria-hidden="true" href="#cb672-255" tabindex="-1"></a>   dac <span class="dv">8</span> i                <span class="st">" Store in buffer</span></span>
<span id="cb672-256"><a aria-hidden="true" href="#cb672-256" tabindex="-1"></a>   sad o12                <span class="st">" Skip if different from '\n'</span></span>
<span id="cb672-257"><a aria-hidden="true" href="#cb672-257" tabindex="-1"></a>   <span class="cf">jmp</span> gline i            <span class="st">" End of line, return</span></span>
<span id="cb672-258"><a aria-hidden="true" href="#cb672-258" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span></span>
<span id="cb672-259"><a aria-hidden="true" href="#cb672-259" tabindex="-1"></a></span>
<span id="cb672-260"><a aria-hidden="true" href="#cb672-260" tabindex="-1"></a>" ============================================</span>
<span id="cb672-261"><a aria-hidden="true" href="#cb672-261" tabindex="-1"></a>" GCHAR<span class="op">:</span> Get character with buffering</span>
<span id="cb672-262"><a aria-hidden="true" href="#cb672-262" tabindex="-1"></a>" ============================================</span>
<span id="cb672-263"><a aria-hidden="true" href="#cb672-263" tabindex="-1"></a></span>
<span id="cb672-264"><a aria-hidden="true" href="#cb672-264" tabindex="-1"></a><span class="fu">gchar:</span> 0</span>
<span id="cb672-265"><a aria-hidden="true" href="#cb672-265" tabindex="-1"></a>   lac tal                <span class="st">" Get current pointer</span></span>
<span id="cb672-266"><a aria-hidden="true" href="#cb672-266" tabindex="-1"></a>   sad ebufp              <span class="st">" Skip if different from end</span></span>
<span id="cb672-267"><a aria-hidden="true" href="#cb672-267" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="fl">1</span><span class="bn">f</span>                 <span class="st">" Buffer empty, refill</span></span>
<span id="cb672-268"><a aria-hidden="true" href="#cb672-268" tabindex="-1"></a>   ral                    <span class="st">" Rotate to check odd/even</span></span>
<span id="cb672-269"><a aria-hidden="true" href="#cb672-269" tabindex="-1"></a>   lac tal i              <span class="st">" Load word</span></span>
<span id="cb672-270"><a aria-hidden="true" href="#cb672-270" tabindex="-1"></a>   snl                    <span class="st">" Skip if link was not set</span></span>
<span id="cb672-271"><a aria-hidden="true" href="#cb672-271" tabindex="-1"></a>   lrss <span class="dv">9</span>                 <span class="st">" Shift right 9 (get high char)</span></span>
<span id="cb672-272"><a aria-hidden="true" href="#cb672-272" tabindex="-1"></a>   <span class="bu">and</span> o777               <span class="st">" Mask to 9 bits</span></span>
<span id="cb672-273"><a aria-hidden="true" href="#cb672-273" tabindex="-1"></a>   lmq                    <span class="st">" Save character</span></span>
<span id="cb672-274"><a aria-hidden="true" href="#cb672-274" tabindex="-1"></a>   lac tal                <span class="st">" Advance pointer</span></span>
<span id="cb672-275"><a aria-hidden="true" href="#cb672-275" tabindex="-1"></a>   <span class="bu">add</span> o400000</span>
<span id="cb672-276"><a aria-hidden="true" href="#cb672-276" tabindex="-1"></a>   dac tal</span>
<span id="cb672-277"><a aria-hidden="true" href="#cb672-277" tabindex="-1"></a>   lacq                   <span class="st">" Restore character</span></span>
<span id="cb672-278"><a aria-hidden="true" href="#cb672-278" tabindex="-1"></a>   sna                    <span class="st">" Skip if non-zero</span></span>
<span id="cb672-279"><a aria-hidden="true" href="#cb672-279" tabindex="-1"></a>   <span class="cf">jmp</span> gchar<span class="op">+</span><span class="dv">1</span>            <span class="st">" Zero, get next</span></span>
<span id="cb672-280"><a aria-hidden="true" href="#cb672-280" tabindex="-1"></a>   <span class="cf">jmp</span> gchar i            <span class="st">" Return character</span></span>
<span id="cb672-281"><a aria-hidden="true" href="#cb672-281" tabindex="-1"></a></span>
<span id="cb672-282"><a aria-hidden="true" href="#cb672-282" tabindex="-1"></a>" Refill buffer</span>
<span id="cb672-283"><a aria-hidden="true" href="#cb672-283" tabindex="-1"></a>1:</span>
<span id="cb672-284"><a aria-hidden="true" href="#cb672-284" tabindex="-1"></a>   lac bufp               <span class="st">" Reset to buffer start</span></span>
<span id="cb672-285"><a aria-hidden="true" href="#cb672-285" tabindex="-1"></a>   dac tal</span>
<span id="cb672-286"><a aria-hidden="true" href="#cb672-286" tabindex="-1"></a>1:</span>
<span id="cb672-287"><a aria-hidden="true" href="#cb672-287" tabindex="-1"></a>   dzm tal i              <span class="st">" Zero out buffer</span></span>
<span id="cb672-288"><a aria-hidden="true" href="#cb672-288" tabindex="-1"></a>   isz tal</span>
<span id="cb672-289"><a aria-hidden="true" href="#cb672-289" tabindex="-1"></a>   lac tal</span>
<span id="cb672-290"><a aria-hidden="true" href="#cb672-290" tabindex="-1"></a>   sad ebufp              <span class="st">" Skip if different from end</span></span>
<span id="cb672-291"><a aria-hidden="true" href="#cb672-291" tabindex="-1"></a>   skp</span>
<span id="cb672-292"><a aria-hidden="true" href="#cb672-292" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span>                 <span class="st">" Continue zeroing</span></span>
<span id="cb672-293"><a aria-hidden="true" href="#cb672-293" tabindex="-1"></a>   lac bufp               <span class="st">" Reset pointer</span></span>
<span id="cb672-294"><a aria-hidden="true" href="#cb672-294" tabindex="-1"></a>   dac tal</span>
<span id="cb672-295"><a aria-hidden="true" href="#cb672-295" tabindex="-1"></a>   lac d2                 <span class="st">" FD 2 (password file)</span></span>
<span id="cb672-296"><a aria-hidden="true" href="#cb672-296" tabindex="-1"></a>   sys tead<span class="co">; buf; 64      " Read from tape (DECtape)</span></span>
<span id="cb672-297"><a aria-hidden="true" href="#cb672-297" tabindex="-1"></a>   sna                    <span class="st">" Skip if non-zero (got data)</span></span>
<span id="cb672-298"><a aria-hidden="true" href="#cb672-298" tabindex="-1"></a>   <span class="cf">jmp</span> error              <span class="st">" EOF or error</span></span>
<span id="cb672-299"><a aria-hidden="true" href="#cb672-299" tabindex="-1"></a>   <span class="cf">jmp</span> gchar<span class="op">+</span><span class="dv">1</span>            <span class="st">" Try again</span></span>
<span id="cb672-300"><a aria-hidden="true" href="#cb672-300" tabindex="-1"></a></span>
<span id="cb672-301"><a aria-hidden="true" href="#cb672-301" tabindex="-1"></a>" ============================================</span>
<span id="cb672-302"><a aria-hidden="true" href="#cb672-302" tabindex="-1"></a>" ERROR HANDLING</span>
<span id="cb672-303"><a aria-hidden="true" href="#cb672-303" tabindex="-1"></a>" ============================================</span>
<span id="cb672-304"><a aria-hidden="true" href="#cb672-304" tabindex="-1"></a></span>
<span id="cb672-305"><a aria-hidden="true" href="#cb672-305" tabindex="-1"></a><span class="fu">error:</span></span>
<span id="cb672-306"><a aria-hidden="true" href="#cb672-306" tabindex="-1"></a>   lac d1</span>
<span id="cb672-307"><a aria-hidden="true" href="#cb672-307" tabindex="-1"></a>   sys write<span class="co">; m2; m2s     " Write "?\n"</span></span>
<span id="cb672-308"><a aria-hidden="true" href="#cb672-308" tabindex="-1"></a>   lac d1</span>
<span id="cb672-309"><a aria-hidden="true" href="#cb672-309" tabindex="-1"></a>   sys smes               <span class="st">" Send message to init (tell parent we died)</span></span>
<span id="cb672-310"><a aria-hidden="true" href="#cb672-310" tabindex="-1"></a>   sys exit               <span class="st">" Exit</span></span>
<span id="cb672-311"><a aria-hidden="true" href="#cb672-311" tabindex="-1"></a></span>
<span id="cb672-312"><a aria-hidden="true" href="#cb672-312" tabindex="-1"></a>" ============================================</span>
<span id="cb672-313"><a aria-hidden="true" href="#cb672-313" tabindex="-1"></a>" MESSAGES</span>
<span id="cb672-314"><a aria-hidden="true" href="#cb672-314" tabindex="-1"></a>" ============================================</span>
<span id="cb672-315"><a aria-hidden="true" href="#cb672-315" tabindex="-1"></a></span>
<span id="cb672-316"><a aria-hidden="true" href="#cb672-316" tabindex="-1"></a><span class="fu">m1:</span></span>
<span id="cb672-317"><a aria-hidden="true" href="#cb672-317" tabindex="-1"></a>   012<span class="co">; &lt;lo&gt;;&lt;gi&gt;;&lt;n;&lt;:;&lt;</span></span>
<span id="cb672-318"><a aria-hidden="true" href="#cb672-318" tabindex="-1"></a>m1s <span class="op">=</span> <span class="op">.-</span>m1</span>
<span id="cb672-319"><a aria-hidden="true" href="#cb672-319" tabindex="-1"></a><span class="fu">m2:</span></span>
<span id="cb672-320"><a aria-hidden="true" href="#cb672-320" tabindex="-1"></a>   &lt;?<span class="co">; 012</span></span>
<span id="cb672-321"><a aria-hidden="true" href="#cb672-321" tabindex="-1"></a>m2s <span class="op">=</span> <span class="op">.-</span>m2</span>
<span id="cb672-322"><a aria-hidden="true" href="#cb672-322" tabindex="-1"></a><span class="fu">m3:</span></span>
<span id="cb672-323"><a aria-hidden="true" href="#cb672-323" tabindex="-1"></a>   &lt;pa<span class="op">&gt;</span><span class="co">;&lt;ss&gt;;&lt;wo&gt;;&lt;rd&gt;;&lt;: 040</span></span>
<span id="cb672-324"><a aria-hidden="true" href="#cb672-324" tabindex="-1"></a>m3s <span class="op">=</span> <span class="op">.-</span>m3</span>
<span id="cb672-325"><a aria-hidden="true" href="#cb672-325" tabindex="-1"></a><span class="fu">dd:</span></span>
<span id="cb672-326"><a aria-hidden="true" href="#cb672-326" tabindex="-1"></a>   &lt;<span class="dt">dd</span><span class="op">&gt;</span><span class="co">;040040;040040;040040</span></span>
<span id="cb672-327"><a aria-hidden="true" href="#cb672-327" tabindex="-1"></a><span class="fu">dir:</span></span>
<span id="cb672-328"><a aria-hidden="true" href="#cb672-328" tabindex="-1"></a>   040040<span class="co">;040040;040040;040040</span></span>
<span id="cb672-329"><a aria-hidden="true" href="#cb672-329" tabindex="-1"></a></span>
<span id="cb672-330"><a aria-hidden="true" href="#cb672-330" tabindex="-1"></a>" ============================================</span>
<span id="cb672-331"><a aria-hidden="true" href="#cb672-331" tabindex="-1"></a>" <span class="dt">FILE</span> NAMES</span>
<span id="cb672-332"><a aria-hidden="true" href="#cb672-332" tabindex="-1"></a>" ============================================</span>
<span id="cb672-333"><a aria-hidden="true" href="#cb672-333" tabindex="-1"></a></span>
<span id="cb672-334"><a aria-hidden="true" href="#cb672-334" tabindex="-1"></a><span class="fu">ttyin:</span></span>
<span id="cb672-335"><a aria-hidden="true" href="#cb672-335" tabindex="-1"></a>   &lt;tt<span class="op">&gt;</span><span class="co">;&lt;yi&gt;;&lt;n 040;040040</span></span>
<span id="cb672-336"><a aria-hidden="true" href="#cb672-336" tabindex="-1"></a><span class="fu">ttyout:</span></span>
<span id="cb672-337"><a aria-hidden="true" href="#cb672-337" tabindex="-1"></a>   &lt;tt<span class="op">&gt;</span><span class="co">;&lt;yo&gt;;&lt;ut&gt;; 040040</span></span>
<span id="cb672-338"><a aria-hidden="true" href="#cb672-338" tabindex="-1"></a><span class="fu">keybd:</span></span>
<span id="cb672-339"><a aria-hidden="true" href="#cb672-339" tabindex="-1"></a>   &lt;ke<span class="op">&gt;</span><span class="co">;&lt;yb&gt;;&lt;oa&gt;;&lt;rd&gt;</span></span>
<span id="cb672-340"><a aria-hidden="true" href="#cb672-340" tabindex="-1"></a><span class="fu">displ:</span></span>
<span id="cb672-341"><a aria-hidden="true" href="#cb672-341" tabindex="-1"></a>   &lt;di<span class="op">&gt;</span><span class="co">;&lt;sp&gt;;&lt;la&gt;;&lt;y 040</span></span>
<span id="cb672-342"><a aria-hidden="true" href="#cb672-342" tabindex="-1"></a><span class="fu">sh:</span></span>
<span id="cb672-343"><a aria-hidden="true" href="#cb672-343" tabindex="-1"></a>   &lt;sh<span class="op">&gt;</span><span class="co">; 040040;040040;040040</span></span>
<span id="cb672-344"><a aria-hidden="true" href="#cb672-344" tabindex="-1"></a><span class="fu">system:</span></span>
<span id="cb672-345"><a aria-hidden="true" href="#cb672-345" tabindex="-1"></a>   &lt;sy<span class="op">&gt;</span><span class="co">;&lt;st&gt;;&lt;em&gt;; 040040</span></span>
<span id="cb672-346"><a aria-hidden="true" href="#cb672-346" tabindex="-1"></a><span class="fu">password:</span></span>
<span id="cb672-347"><a aria-hidden="true" href="#cb672-347" tabindex="-1"></a>   &lt;pa<span class="op">&gt;</span><span class="co">;&lt;ss&gt;;&lt;wo&gt;;&lt;rd&gt;</span></span>
<span id="cb672-348"><a aria-hidden="true" href="#cb672-348" tabindex="-1"></a></span>
<span id="cb672-349"><a aria-hidden="true" href="#cb672-349" tabindex="-1"></a>" ============================================</span>
<span id="cb672-350"><a aria-hidden="true" href="#cb672-350" tabindex="-1"></a>" CONSTANTS <span class="op">AND</span> BUFFERS</span>
<span id="cb672-351"><a aria-hidden="true" href="#cb672-351" tabindex="-1"></a>" ============================================</span>
<span id="cb672-352"><a aria-hidden="true" href="#cb672-352" tabindex="-1"></a></span>
<span id="cb672-353"><a aria-hidden="true" href="#cb672-353" tabindex="-1"></a><span class="fu">d1:</span> 1</span>
<span id="cb672-354"><a aria-hidden="true" href="#cb672-354" tabindex="-1"></a><span class="fu">o43:</span> 043                  " '#' (backspace<span class="op">)</span></span>
<span id="cb672-355"><a aria-hidden="true" href="#cb672-355" tabindex="-1"></a><span class="fu">o100:</span> 0100                " '@' (line kill<span class="op">)</span></span>
<span id="cb672-356"><a aria-hidden="true" href="#cb672-356" tabindex="-1"></a>o400000<span class="co">; 0400000</span></span>
<span id="cb672-357"><a aria-hidden="true" href="#cb672-357" tabindex="-1"></a><span class="fu">d2:</span> 2</span>
<span id="cb672-358"><a aria-hidden="true" href="#cb672-358" tabindex="-1"></a><span class="fu">o12:</span> 012                  " '\n<span class="st">' (newline)</span></span>
<span id="cb672-359"><a aria-hidden="true" href="#cb672-359" tabindex="-1"></a><span class="fu">om60:</span> -060                " -'0'</span>
<span id="cb672-360"><a aria-hidden="true" href="#cb672-360" tabindex="-1"></a><span class="fu">d3:</span> 3</span>
<span id="cb672-361"><a aria-hidden="true" href="#cb672-361" tabindex="-1"></a><span class="fu">ebufp:</span> buf<span class="op">+</span><span class="dv">64</span>             <span class="st">" End of buffer</span></span>
<span id="cb672-362"><a aria-hidden="true" href="#cb672-362" tabindex="-1"></a><span class="fu">bufp:</span> buf</span>
<span id="cb672-363"><a aria-hidden="true" href="#cb672-363" tabindex="-1"></a><span class="fu">o777:</span> 0777</span>
<span id="cb672-364"><a aria-hidden="true" href="#cb672-364" tabindex="-1"></a><span class="fu">o777000:</span> 0777000</span>
<span id="cb672-365"><a aria-hidden="true" href="#cb672-365" tabindex="-1"></a><span class="fu">o40:</span> 040                  " Space</span>
<span id="cb672-366"><a aria-hidden="true" href="#cb672-366" tabindex="-1"></a><span class="fu">o72:</span> 072                  " ':' (field separator<span class="op">)</span></span>
<span id="cb672-367"><a aria-hidden="true" href="#cb672-367" tabindex="-1"></a></span>
<span id="cb672-368"><a aria-hidden="true" href="#cb672-368" tabindex="-1"></a><span class="fu">ibuf:</span> .=.+100             " Input buffer</span>
<span id="cb672-369"><a aria-hidden="true" href="#cb672-369" tabindex="-1"></a><span class="fu">obuf:</span> .=.+100             " Output buffer <span class="op">(</span>password <span class="dt">file</span> line<span class="op">)</span></span>
<span id="cb672-370"><a aria-hidden="true" href="#cb672-370" tabindex="-1"></a><span class="fu">tal:</span> .=.+1                " Tape<span class="op">/</span><span class="dt">file</span> pointer</span>
<span id="cb672-371"><a aria-hidden="true" href="#cb672-371" tabindex="-1"></a><span class="fu">buf:</span> .=.+64               " <span class="dt">File</span> I<span class="op">/</span>O buffer</span>
<span id="cb672-372"><a aria-hidden="true" href="#cb672-372" tabindex="-1"></a><span class="fu">char:</span> .=.+1               " Character buffer</span>
<span id="cb672-373"><a aria-hidden="true" href="#cb672-373" tabindex="-1"></a><span class="fu">nchar:</span> .=.+1              " Numeric character accumulator</span>
<span id="cb672-374"><a aria-hidden="true" href="#cb672-374" tabindex="-1"></a><span class="fu">pid1:</span> .=.+1               " Process ID for terminal <span class="dv">1</span></span>
<span id="cb672-375"><a aria-hidden="true" href="#cb672-375" tabindex="-1"></a><span class="fu">pid2:</span> .=.+1               " Process ID for terminal <span class="dv">2</span></span></code></pre></div>
<h4 data-number="9.3.2.2" id="the-password-file-format"><span class="header-section-number">9.3.2.2</span> The Password File
Format</h4>
<p>The password file had a simple format:</p>
<pre><code>username:password:uid:directory\n</code></pre>
<p>Example:</p>
<pre><code>dmr:zyx123:1:dmr
ken:abc456:2:ken</code></pre>
<p>Fields: - <strong>username:</strong> User‚Äôs login name -
<strong>password:</strong> Plain text password (no encryption!) -
<strong>uid:</strong> User ID in octal - <strong>directory:</strong>
Home directory name</p>
<p>The code parses this by looking for ‚Äò:‚Äô delimiters.</p>
<h4 data-number="9.3.2.3" id="security-in-1969"><span class="header-section-number">9.3.2.3</span> Security in 1969</h4>
<p>Notice: <strong>passwords in plain text</strong>. No encryption, no
hashing. Why?</p>
<ol type="1">
<li><strong>Physical Security:</strong> The PDP-7 was in a locked
room</li>
<li><strong>Trusted Users:</strong> Only Thompson, Ritchie, and maybe a
few others</li>
<li><strong>No Network:</strong> No remote access, no need to protect
against remote attackers</li>
<li><strong>Cultural Norms:</strong> Security wasn‚Äôt a major concern in
1969 computing</li>
</ol>
<p>Within a few years, Unix added crypt() and hashed passwords. But the
PDP-7 version was truly naive.</p>
<h4 data-number="9.3.2.4" id="the-multi-user-concept"><span class="header-section-number">9.3.2.4</span> The Multi-User Concept</h4>
<p>init manages two login sessions:</p>
<p><strong>Terminal 1 (TTY):</strong> - Input: /dd/ttyin (teletype
input) - Output: /dd/ttyout (teletype output) - Process ID saved in
pid1</p>
<p><strong>Terminal 2 (Display):</strong> - Input: /dd/keyboar
(keyboard) - Output: /dd/display (vector display) - Process ID saved in
pid2</p>
<p>When a session exits (user logs out or shell crashes), init detects
it via the rmes system call and automatically restarts that session.</p>
<p>This is the origin of the Unix login: daemon pattern that persists
today: - Modern Linux: systemd manages getty instances - Modern Unix:
init or launchd manages login sessions - Same concept: monitor sessions,
restart on exit</p>
<h4 data-number="9.3.2.5" id="the-shell-bootstrap"><span class="header-section-number">9.3.2.5</span> The Shell Bootstrap</h4>
<p>The shell execution is fascinating. There‚Äôs no exec() system call
yet! Instead:</p>
<ol type="1">
<li>Read password file to find user‚Äôs directory</li>
<li>chdir to user‚Äôs home directory</li>
<li>Open ‚Äúsh‚Äù file (the shell executable)</li>
<li>Copy bootstrap code to high memory (017700)</li>
<li>Jump to bootstrap</li>
<li>Bootstrap reads shell from file into memory at location 4096</li>
<li>Bootstrap closes file and jumps to 4096</li>
</ol>
<p>This is a primitive form of exec() done entirely in user space!</p>
<p>Modern Unix has the exec() system call, which does all this in the
kernel. But the PDP-7 version shows that it‚Äôs just loading and
jumping‚Äîno magic.</p>
<h4 data-number="9.3.2.6" id="cultural-impact-multi-user-login-in-1969"><span class="header-section-number">9.3.2.6</span> Cultural Impact: Multi-User
Login in 1969</h4>
<p>In 1969, most minicomputers supported one user at a time. Mainframes
supported many users, but through complex job control systems.</p>
<p>Unix introduced: - Simple login mechanism - Per-user home directories
- User IDs and permissions - Independent shell sessions - Automatic
session restart</p>
<p>This made multi-user computing accessible to small systems. Within a
decade: - VAX systems supported hundreds of users - University computing
labs used Unix terminals - Time-sharing became commonplace</p>
<p>All of it started with this 292-line init program on a PDP-7.</p>
<h3 data-number="9.3.3" id="maksys.s---system-installation"><span class="header-section-number">9.3.3</span> maksys.s - System
Installation</h3>
<p><strong>Purpose:</strong> Copy a.out executable to disk track 18x</p>
<p><strong>Lines of Code:</strong> 52</p>
<p><strong>System Installation Process:</strong></p>
<p>maksys is a tool for installing the system to a specific disk track.
It writes an executable to a fixed location where the boot loader can
find it.</p>
<h4 data-number="9.3.3.1" id="complete-source-code-1"><span class="header-section-number">9.3.3.1</span> Complete Source Code</h4>
<div class="sourceCode" id="cb675"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb675-1"><a aria-hidden="true" href="#cb675-1" tabindex="-1"></a>" copy a<span class="op">.</span>out to disk track <span class="dv">18</span><span class="er">x</span></span>
<span id="cb675-2"><a aria-hidden="true" href="#cb675-2" tabindex="-1"></a>" where x is the argument</span>
<span id="cb675-3"><a aria-hidden="true" href="#cb675-3" tabindex="-1"></a></span>
<span id="cb675-4"><a aria-hidden="true" href="#cb675-4" tabindex="-1"></a>   lac <span class="dv">017777</span> i<span class="co">; sad d8; skp; jmp error   " Need exactly 1 argument</span></span>
<span id="cb675-5"><a aria-hidden="true" href="#cb675-5" tabindex="-1"></a>   lac <span class="dv">017777</span><span class="co">; tad d5; dac track          " Get track number pointer</span></span>
<span id="cb675-6"><a aria-hidden="true" href="#cb675-6" tabindex="-1"></a>   lac i track<span class="co">; lrss 9; tad om60          " Parse track digit</span></span>
<span id="cb675-7"><a aria-hidden="true" href="#cb675-7" tabindex="-1"></a>   spa<span class="co">; jmp error; dac track              " Check valid</span></span>
<span id="cb675-8"><a aria-hidden="true" href="#cb675-8" tabindex="-1"></a>   tad dm10<span class="co">; sma; jmp error               " Must be 0-9</span></span>
<span id="cb675-9"><a aria-hidden="true" href="#cb675-9" tabindex="-1"></a></span>
<span id="cb675-10"><a aria-hidden="true" href="#cb675-10" tabindex="-1"></a>   sysopen<span class="co">; a.out; 0                      " Open a.out</span></span>
<span id="cb675-11"><a aria-hidden="true" href="#cb675-11" tabindex="-1"></a>   spa<span class="co">; jmp error</span></span>
<span id="cb675-12"><a aria-hidden="true" href="#cb675-12" tabindex="-1"></a>   sys read<span class="co">; bufp; buf; 3072              " Read 3072 words</span></span>
<span id="cb675-13"><a aria-hidden="true" href="#cb675-13" tabindex="-1"></a>   sad <span class="op">.-</span><span class="dv">1</span>                                <span class="st">" Skip if read exactly 3072</span></span>
<span id="cb675-14"><a aria-hidden="true" href="#cb675-14" tabindex="-1"></a>   <span class="cf">jmp</span> error                              <span class="st">" Wrong size</span></span>
<span id="cb675-15"><a aria-hidden="true" href="#cb675-15" tabindex="-1"></a></span>
<span id="cb675-16"><a aria-hidden="true" href="#cb675-16" tabindex="-1"></a>   dscs                                   <span class="st">" Disk control: clear and select</span></span>
<span id="cb675-17"><a aria-hidden="true" href="#cb675-17" tabindex="-1"></a>   -3072<span class="co">; dslw                            " Set word count: 3072</span></span>
<span id="cb675-18"><a aria-hidden="true" href="#cb675-18" tabindex="-1"></a>   lac bufp<span class="co">; dslm                         " Set memory address</span></span>
<span id="cb675-19"><a aria-hidden="true" href="#cb675-19" tabindex="-1"></a>   lac track<span class="co">; alss 8; xor o300000; dsld   " Set disk address</span></span>
<span id="cb675-20"><a aria-hidden="true" href="#cb675-20" tabindex="-1"></a>   lac o30000<span class="co">; dsls                       " Start disk write</span></span>
<span id="cb675-21"><a aria-hidden="true" href="#cb675-21" tabindex="-1"></a>   dssf<span class="co">; jmp .-1                          " Wait for done</span></span>
<span id="cb675-22"><a aria-hidden="true" href="#cb675-22" tabindex="-1"></a>   dsrs<span class="co">; spa; jmp error                   " Check status</span></span>
<span id="cb675-23"><a aria-hidden="true" href="#cb675-23" tabindex="-1"></a></span>
<span id="cb675-24"><a aria-hidden="true" href="#cb675-24" tabindex="-1"></a>   -1024<span class="co">; dslw                            " Write second part</span></span>
<span id="cb675-25"><a aria-hidden="true" href="#cb675-25" tabindex="-1"></a>   lac d3072<span class="co">; dslm</span></span>
<span id="cb675-26"><a aria-hidden="true" href="#cb675-26" tabindex="-1"></a>   lac track<span class="co">; alss 8; xor o300110; dsld</span></span>
<span id="cb675-27"><a aria-hidden="true" href="#cb675-27" tabindex="-1"></a>   lac o3000<span class="co">; dsls</span></span>
<span id="cb675-28"><a aria-hidden="true" href="#cb675-28" tabindex="-1"></a>   dssf<span class="co">; jmp .-1</span></span>
<span id="cb675-29"><a aria-hidden="true" href="#cb675-29" tabindex="-1"></a>   dsrs<span class="co">; spa; jmp error</span></span>
<span id="cb675-30"><a aria-hidden="true" href="#cb675-30" tabindex="-1"></a>   sys exit</span>
<span id="cb675-31"><a aria-hidden="true" href="#cb675-31" tabindex="-1"></a></span>
<span id="cb675-32"><a aria-hidden="true" href="#cb675-32" tabindex="-1"></a><span class="fu">error:</span></span>
<span id="cb675-33"><a aria-hidden="true" href="#cb675-33" tabindex="-1"></a>   lac d1<span class="co">; sys write; 1f; 2</span></span>
<span id="cb675-34"><a aria-hidden="true" href="#cb675-34" tabindex="-1"></a>   sys exit</span>
<span id="cb675-35"><a aria-hidden="true" href="#cb675-35" tabindex="-1"></a>1: 077077<span class="co">;012</span></span>
<span id="cb675-36"><a aria-hidden="true" href="#cb675-36" tabindex="-1"></a></span>
<span id="cb675-37"><a aria-hidden="true" href="#cb675-37" tabindex="-1"></a><span class="fu">dm10:</span> -10</span>
<span id="cb675-38"><a aria-hidden="true" href="#cb675-38" tabindex="-1"></a><span class="fu">dm5:</span> 5</span>
<span id="cb675-39"><a aria-hidden="true" href="#cb675-39" tabindex="-1"></a><span class="fu">om60:</span> -060</span>
<span id="cb675-40"><a aria-hidden="true" href="#cb675-40" tabindex="-1"></a><span class="fu">o300000:</span> 0300000</span>
<span id="cb675-41"><a aria-hidden="true" href="#cb675-41" tabindex="-1"></a><span class="fu">o300100:</span> 0300110</span>
<span id="cb675-42"><a aria-hidden="true" href="#cb675-42" tabindex="-1"></a><span class="fu">d8:</span> 8</span>
<span id="cb675-43"><a aria-hidden="true" href="#cb675-43" tabindex="-1"></a><span class="fu">d3072:</span> 3072</span>
<span id="cb675-44"><a aria-hidden="true" href="#cb675-44" tabindex="-1"></a><span class="fu">o3000:</span> 03000</span>
<span id="cb675-45"><a aria-hidden="true" href="#cb675-45" tabindex="-1"></a><span class="fu">d1:</span> 1</span>
<span id="cb675-46"><a aria-hidden="true" href="#cb675-46" tabindex="-1"></a><span class="fu">a.out:</span></span>
<span id="cb675-47"><a aria-hidden="true" href="#cb675-47" tabindex="-1"></a>   &lt;a<span class="op">.&gt;</span><span class="co">;&lt;ou&gt;;&lt;t 040;040040</span></span>
<span id="cb675-48"><a aria-hidden="true" href="#cb675-48" tabindex="-1"></a></span>
<span id="cb675-49"><a aria-hidden="true" href="#cb675-49" tabindex="-1"></a><span class="fu">track:</span> .=.+1</span>
<span id="cb675-50"><a aria-hidden="true" href="#cb675-50" tabindex="-1"></a></span>
<span id="cb675-51"><a aria-hidden="true" href="#cb675-51" tabindex="-1"></a><span class="fu">buf:</span></span></code></pre></div>
<h4 data-number="9.3.3.2" id="direct-disk-io"><span class="header-section-number">9.3.3.2</span> Direct Disk I/O</h4>
<p>This code uses direct disk I/O via the disk controller:</p>
<p><strong>Disk Commands:</strong> - <code>dscs</code> - Clear and
select disk - <code>dslw</code> - Load word count - <code>dslm</code> -
Load memory address - <code>dsld</code> - Load disk address -
<code>dsls</code> - Start operation - <code>dssf</code> - Skip if done -
<code>dsrs</code> - Read status</p>
<p>The disk address calculation:</p>
<div class="sourceCode" id="cb676"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb676-1"><a aria-hidden="true" href="#cb676-1" tabindex="-1"></a>lac track<span class="co">; alss 8; xor o300000; dsld</span></span></code></pre></div>
<p>This builds a disk address from: - Track number (0-9) - Fixed sector
(18) - Read/write command bits</p>
<p>The system image is written to track 18x where x is the argument
(0-9), allowing up to 10 different system images.</p>
<h4 data-number="9.3.3.3" id="why-fixed-locations"><span class="header-section-number">9.3.3.3</span> Why Fixed Locations?</h4>
<p>The boot ROM knew to load from track 180-189. By writing system
images to these tracks, you could boot different versions:</p>
<pre><code>Track 180: Stable system
Track 181: Development system
Track 182: Experimental kernel
Track 183: Backup
...</code></pre>
<p>At boot time, you‚Äôd select which track to load from.</p>
<h3 data-number="9.3.4" id="trysys.s---system-loader"><span class="header-section-number">9.3.4</span> trysys.s - System Loader</h3>
<p><strong>Purpose:</strong> Load and execute a.out from disk</p>
<p><strong>Lines of Code:</strong> 40</p>
<p><strong>Testing New Systems:</strong></p>
<p>trysys loads a system image into memory and jumps to it. This was
used for testing new kernels without installing them to the boot
track.</p>
<h4 data-number="9.3.4.1" id="complete-source-code-2"><span class="header-section-number">9.3.4.1</span> Complete Source Code</h4>
<div class="sourceCode" id="cb678"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb678-1"><a aria-hidden="true" href="#cb678-1" tabindex="-1"></a>" trysys</span>
<span id="cb678-2"><a aria-hidden="true" href="#cb678-2" tabindex="-1"></a></span>
<span id="cb678-3"><a aria-hidden="true" href="#cb678-3" tabindex="-1"></a>   sys open<span class="co">; a.out; 0     " Open a.out</span></span>
<span id="cb678-4"><a aria-hidden="true" href="#cb678-4" tabindex="-1"></a>   spa</span>
<span id="cb678-5"><a aria-hidden="true" href="#cb678-5" tabindex="-1"></a>   <span class="cf">jmp</span> error              <span class="st">" Can't open</span></span>
<span id="cb678-6"><a aria-hidden="true" href="#cb678-6" tabindex="-1"></a>   sys read<span class="co">; buf; 3072    " Read entire file</span></span>
<span id="cb678-7"><a aria-hidden="true" href="#cb678-7" tabindex="-1"></a>   sad <span class="op">.-</span><span class="dv">1</span>                <span class="st">" Skip if read exactly 3072 words</span></span>
<span id="cb678-8"><a aria-hidden="true" href="#cb678-8" tabindex="-1"></a>   <span class="cf">jmp</span> error              <span class="st">" Wrong size</span></span>
<span id="cb678-9"><a aria-hidden="true" href="#cb678-9" tabindex="-1"></a>   iof                    <span class="st">" Interrupts off</span></span>
<span id="cb678-10"><a aria-hidden="true" href="#cb678-10" tabindex="-1"></a>   caf                    <span class="st">" Clear all flags</span></span>
<span id="cb678-11"><a aria-hidden="true" href="#cb678-11" tabindex="-1"></a>   cdf                    <span class="st">" Clear data field</span></span>
<span id="cb678-12"><a aria-hidden="true" href="#cb678-12" tabindex="-1"></a>   clof                   <span class="st">" Clear overflow</span></span>
<span id="cb678-13"><a aria-hidden="true" href="#cb678-13" tabindex="-1"></a>   law buf                <span class="st">" Source address</span></span>
<span id="cb678-14"><a aria-hidden="true" href="#cb678-14" tabindex="-1"></a>   dac t1</span>
<span id="cb678-15"><a aria-hidden="true" href="#cb678-15" tabindex="-1"></a>   dzm t2                 <span class="st">" Destination: address 0</span></span>
<span id="cb678-16"><a aria-hidden="true" href="#cb678-16" tabindex="-1"></a>   -3072</span>
<span id="cb678-17"><a aria-hidden="true" href="#cb678-17" tabindex="-1"></a>   dac c1                 <span class="st">" Counter</span></span>
<span id="cb678-18"><a aria-hidden="true" href="#cb678-18" tabindex="-1"></a></span>
<span id="cb678-19"><a aria-hidden="true" href="#cb678-19" tabindex="-1"></a>1:</span>
<span id="cb678-20"><a aria-hidden="true" href="#cb678-20" tabindex="-1"></a>   lac t1 i               <span class="st">" Copy loop</span></span>
<span id="cb678-21"><a aria-hidden="true" href="#cb678-21" tabindex="-1"></a>   dac t2 i               <span class="st">" Copy word from buffer to low memory</span></span>
<span id="cb678-22"><a aria-hidden="true" href="#cb678-22" tabindex="-1"></a>   isz t1                 <span class="st">" Increment source</span></span>
<span id="cb678-23"><a aria-hidden="true" href="#cb678-23" tabindex="-1"></a>   isz t2                 <span class="st">" Increment destination</span></span>
<span id="cb678-24"><a aria-hidden="true" href="#cb678-24" tabindex="-1"></a>   isz c1                 <span class="st">" Decrement counter</span></span>
<span id="cb678-25"><a aria-hidden="true" href="#cb678-25" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span>                 <span class="st">" Continue</span></span>
<span id="cb678-26"><a aria-hidden="true" href="#cb678-26" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="dv">0100</span>               <span class="st">" Jump to system entry point (location 0100)</span></span>
<span id="cb678-27"><a aria-hidden="true" href="#cb678-27" tabindex="-1"></a></span>
<span id="cb678-28"><a aria-hidden="true" href="#cb678-28" tabindex="-1"></a><span class="fu">error:</span></span>
<span id="cb678-29"><a aria-hidden="true" href="#cb678-29" tabindex="-1"></a>   lac d1</span>
<span id="cb678-30"><a aria-hidden="true" href="#cb678-30" tabindex="-1"></a>   sys write<span class="co">; 1f; 1</span></span>
<span id="cb678-31"><a aria-hidden="true" href="#cb678-31" tabindex="-1"></a>   sys exit</span>
<span id="cb678-32"><a aria-hidden="true" href="#cb678-32" tabindex="-1"></a>1: 077012</span>
<span id="cb678-33"><a aria-hidden="true" href="#cb678-33" tabindex="-1"></a></span>
<span id="cb678-34"><a aria-hidden="true" href="#cb678-34" tabindex="-1"></a><span class="fu">a.out:</span></span>
<span id="cb678-35"><a aria-hidden="true" href="#cb678-35" tabindex="-1"></a>   &lt;a<span class="op">.&gt;</span><span class="co">;&lt;ou&gt;;&lt;t 040; 040040</span></span>
<span id="cb678-36"><a aria-hidden="true" href="#cb678-36" tabindex="-1"></a><span class="fu">t1:</span> 0</span>
<span id="cb678-37"><a aria-hidden="true" href="#cb678-37" tabindex="-1"></a><span class="fu">t2:</span> 0</span>
<span id="cb678-38"><a aria-hidden="true" href="#cb678-38" tabindex="-1"></a><span class="fu">c1:</span> 0</span>
<span id="cb678-39"><a aria-hidden="true" href="#cb678-39" tabindex="-1"></a><span class="fu">d1:</span> 1</span>
<span id="cb678-40"><a aria-hidden="true" href="#cb678-40" tabindex="-1"></a><span class="fu">buf:</span></span></code></pre></div>
<h4 data-number="9.3.4.2" id="the-bootstrap-process"><span class="header-section-number">9.3.4.2</span> The Bootstrap Process</h4>
<ol type="1">
<li>Open a.out</li>
<li>Read 3072 words into high memory buffer</li>
<li>Disable interrupts (about to overwrite kernel!)</li>
<li>Copy from buffer to address 0</li>
<li>Jump to location 0100 (system entry point)</li>
</ol>
<p>This overwrites the current kernel with the new one and jumps to it.
There‚Äôs no way to recover if the new kernel is bad‚Äîyou‚Äôd have to reboot
from DECtape.</p>
<h4 data-number="9.3.4.3" id="why-location-0100"><span class="header-section-number">9.3.4.3</span> Why Location 0100?</h4>
<p>The PDP-7 used locations 0-077 for special purposes: - 0-7: Trap
vectors - 8-77: Reserved</p>
<p>Location 0100 (octal) = 64 (decimal) was the first safe location for
code. All PDP-7 Unix programs started at 0100.</p>
<h2 data-number="9.4" id="disk-utilities"><span class="header-section-number">9.4</span> 11.4 Disk Utilities</h2>
<h3 data-number="9.4.1" id="dsksav.s-dskres.s---disk-backuprestore"><span class="header-section-number">9.4.1</span> dsksav.s / dskres.s - Disk
Backup/Restore</h3>
<p><strong>Purpose:</strong> Backup and restore disk tracks</p>
<p><strong>Lines of Code:</strong> 27 each</p>
<p><strong>Why Backup Was Critical:</strong></p>
<p>DECtape was unreliable. A backup strategy was essential:</p>
<ol type="1">
<li><strong>Regular Backups:</strong> Save disk to tape weekly</li>
<li><strong>Before Experiments:</strong> Backup before trying new
code</li>
<li><strong>After Corruption:</strong> Restore from last good
backup</li>
</ol>
<h4 data-number="9.4.1.1" id="dsksav.s---save-disk-to-tape"><span class="header-section-number">9.4.1.1</span> dsksav.s - Save Disk to
Tape</h4>
<div class="sourceCode" id="cb679"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb679-1"><a aria-hidden="true" href="#cb679-1" tabindex="-1"></a>" dsksav</span>
<span id="cb679-2"><a aria-hidden="true" href="#cb679-2" tabindex="-1"></a></span>
<span id="cb679-3"><a aria-hidden="true" href="#cb679-3" tabindex="-1"></a>   iof                    <span class="st">" Interrupts off</span></span>
<span id="cb679-4"><a aria-hidden="true" href="#cb679-4" tabindex="-1"></a>   <span class="bu">hlt</span>                    <span class="st">" Halt - operator starts with continue</span></span>
<span id="cb679-5"><a aria-hidden="true" href="#cb679-5" tabindex="-1"></a>   dzm track              <span class="st">" Start at track 0</span></span>
<span id="cb679-6"><a aria-hidden="true" href="#cb679-6" tabindex="-1"></a>   -640                   " 640 tracks total</span>
<span id="cb679-7"><a aria-hidden="true" href="#cb679-7" tabindex="-1"></a>   dac c1</span>
<span id="cb679-8"><a aria-hidden="true" href="#cb679-8" tabindex="-1"></a>1:</span>
<span id="cb679-9"><a aria-hidden="true" href="#cb679-9" tabindex="-1"></a>   lac track</span>
<span id="cb679-10"><a aria-hidden="true" href="#cb679-10" tabindex="-1"></a>   jms dskrd1             <span class="st">" Read from disk 1</span></span>
<span id="cb679-11"><a aria-hidden="true" href="#cb679-11" tabindex="-1"></a>   lac track</span>
<span id="cb679-12"><a aria-hidden="true" href="#cb679-12" tabindex="-1"></a>   jms dskwr0             <span class="st">" Write to disk 0 (tape)</span></span>
<span id="cb679-13"><a aria-hidden="true" href="#cb679-13" tabindex="-1"></a>   lac track</span>
<span id="cb679-14"><a aria-hidden="true" href="#cb679-14" tabindex="-1"></a>   tad d10                <span class="st">" Next track (10 sectors per track)</span></span>
<span id="cb679-15"><a aria-hidden="true" href="#cb679-15" tabindex="-1"></a>   dac track</span>
<span id="cb679-16"><a aria-hidden="true" href="#cb679-16" tabindex="-1"></a>   isz c1                 <span class="st">" Count down</span></span>
<span id="cb679-17"><a aria-hidden="true" href="#cb679-17" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span>                 <span class="st">" Continue</span></span>
<span id="cb679-18"><a aria-hidden="true" href="#cb679-18" tabindex="-1"></a>   <span class="bu">hlt</span>                    <span class="st">" Done - halt</span></span>
<span id="cb679-19"><a aria-hidden="true" href="#cb679-19" tabindex="-1"></a>   sys exit</span>
<span id="cb679-20"><a aria-hidden="true" href="#cb679-20" tabindex="-1"></a></span>
<span id="cb679-21"><a aria-hidden="true" href="#cb679-21" tabindex="-1"></a><span class="fu">track:</span> 0</span>
<span id="cb679-22"><a aria-hidden="true" href="#cb679-22" tabindex="-1"></a><span class="fu">c1:</span> 0</span>
<span id="cb679-23"><a aria-hidden="true" href="#cb679-23" tabindex="-1"></a><span class="fu">d10:</span> 10</span></code></pre></div>
<h4 data-number="9.4.1.2" id="dskres.s---restore-disk-from-tape"><span class="header-section-number">9.4.1.2</span> dskres.s - Restore Disk
from Tape</h4>
<div class="sourceCode" id="cb680"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb680-1"><a aria-hidden="true" href="#cb680-1" tabindex="-1"></a>" dskres</span>
<span id="cb680-2"><a aria-hidden="true" href="#cb680-2" tabindex="-1"></a></span>
<span id="cb680-3"><a aria-hidden="true" href="#cb680-3" tabindex="-1"></a>   iof                    <span class="st">" Interrupts off</span></span>
<span id="cb680-4"><a aria-hidden="true" href="#cb680-4" tabindex="-1"></a>   <span class="bu">hlt</span>                    <span class="st">" Halt - operator starts</span></span>
<span id="cb680-5"><a aria-hidden="true" href="#cb680-5" tabindex="-1"></a>   dzm track              <span class="st">" Start at track 0</span></span>
<span id="cb680-6"><a aria-hidden="true" href="#cb680-6" tabindex="-1"></a>   -640                   " 640 tracks</span>
<span id="cb680-7"><a aria-hidden="true" href="#cb680-7" tabindex="-1"></a>   dac c1</span>
<span id="cb680-8"><a aria-hidden="true" href="#cb680-8" tabindex="-1"></a>1:</span>
<span id="cb680-9"><a aria-hidden="true" href="#cb680-9" tabindex="-1"></a>   lac track</span>
<span id="cb680-10"><a aria-hidden="true" href="#cb680-10" tabindex="-1"></a>   jms dskrd0             <span class="st">" Read from disk 0 (tape)</span></span>
<span id="cb680-11"><a aria-hidden="true" href="#cb680-11" tabindex="-1"></a>   lac track</span>
<span id="cb680-12"><a aria-hidden="true" href="#cb680-12" tabindex="-1"></a>   jms dskwr1             <span class="st">" Write to disk 1</span></span>
<span id="cb680-13"><a aria-hidden="true" href="#cb680-13" tabindex="-1"></a>   lac track</span>
<span id="cb680-14"><a aria-hidden="true" href="#cb680-14" tabindex="-1"></a>   tad d10</span>
<span id="cb680-15"><a aria-hidden="true" href="#cb680-15" tabindex="-1"></a>   dac track</span>
<span id="cb680-16"><a aria-hidden="true" href="#cb680-16" tabindex="-1"></a>   isz c1</span>
<span id="cb680-17"><a aria-hidden="true" href="#cb680-17" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span></span>
<span id="cb680-18"><a aria-hidden="true" href="#cb680-18" tabindex="-1"></a>   <span class="bu">hlt</span></span>
<span id="cb680-19"><a aria-hidden="true" href="#cb680-19" tabindex="-1"></a>   sys exit</span>
<span id="cb680-20"><a aria-hidden="true" href="#cb680-20" tabindex="-1"></a></span>
<span id="cb680-21"><a aria-hidden="true" href="#cb680-21" tabindex="-1"></a><span class="fu">track:</span> 0</span>
<span id="cb680-22"><a aria-hidden="true" href="#cb680-22" tabindex="-1"></a><span class="fu">c1:</span> 0</span>
<span id="cb680-23"><a aria-hidden="true" href="#cb680-23" tabindex="-1"></a><span class="fu">d10:</span> 10</span></code></pre></div>
<h4 data-number="9.4.1.3" id="the-disk-copy-strategy"><span class="header-section-number">9.4.1.3</span> The Disk Copy Strategy</h4>
<p>Both programs use the same pattern: 1. Halt for operator to mount
tapes 2. Loop through all tracks (0-6399 in steps of 10) 3. Read from
source 4. Write to destination 5. Halt when done</p>
<p>The <code>hlt</code> instruction was crucial‚Äîit gave the operator
time to: - Mount the backup tape - Verify everything was ready - Press
CONTINUE on the front panel to start</p>
<h4 data-number="9.4.1.4" id="disk-numbering"><span class="header-section-number">9.4.1.4</span> Disk Numbering</h4>
<ul>
<li><strong>Disk 0:</strong> DECtape drive (tape backup)</li>
<li><strong>Disk 1:</strong> Fixed disk or second DECtape</li>
</ul>
<p>The utilities read from one and write to the other, creating a
complete disk image.</p>
<h4 data-number="9.4.1.5" id="no-error-checking"><span class="header-section-number">9.4.1.5</span> No Error Checking</h4>
<p>Notice: no error checking! If a read or write failed, the program
continued anyway. Why?</p>
<ol type="1">
<li><strong>Simplicity:</strong> Error handling would double the code
size</li>
<li><strong>Operator Present:</strong> Someone was physically watching
the process</li>
<li><strong>Retry Manually:</strong> If errors occurred, operator would
halt and retry</li>
<li><strong>Trust Hardware:</strong> DECtape was reliable enough most of
the time</li>
</ol>
<p>This reflects the 1969 philosophy: build simple tools, rely on humans
for error recovery.</p>
<h2 data-number="9.5" id="common-patterns"><span class="header-section-number">9.5</span> 11.5 Common Patterns</h2>
<p>Examining all these utilities reveals common patterns that emerged
organically from PDP-7 programming:</p>
<h3 data-number="9.5.1" id="pattern-1-argument-parsing"><span class="header-section-number">9.5.1</span> Pattern 1: Argument
Parsing</h3>
<p><strong>Standard argument vector:</strong></p>
<pre><code>Location 017777:   Argument count (4 √ó number of args)
Location 017777+1: Pointer to argv[0]
Location 017777+2: Pointer to argv[1]
...</code></pre>
<p><strong>Standard parsing loop:</strong></p>
<div class="sourceCode" id="cb682"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb682-1"><a aria-hidden="true" href="#cb682-1" tabindex="-1"></a><span class="fu">loop:</span></span>
<span id="cb682-2"><a aria-hidden="true" href="#cb682-2" tabindex="-1"></a>   lac <span class="dv">017777</span> i          <span class="st">" Get argument count</span></span>
<span id="cb682-3"><a aria-hidden="true" href="#cb682-3" tabindex="-1"></a>   sad d4                <span class="st">" Skip if exactly 4 (no args left)</span></span>
<span id="cb682-4"><a aria-hidden="true" href="#cb682-4" tabindex="-1"></a>   sys exit              <span class="st">" Done</span></span>
<span id="cb682-5"><a aria-hidden="true" href="#cb682-5" tabindex="-1"></a>   tad dm4               <span class="st">" Subtract 4</span></span>
<span id="cb682-6"><a aria-hidden="true" href="#cb682-6" tabindex="-1"></a>   dac <span class="dv">017777</span> i          <span class="st">" Update count</span></span>
<span id="cb682-7"><a aria-hidden="true" href="#cb682-7" tabindex="-1"></a>   lac nameptr           <span class="st">" Get current filename pointer</span></span>
<span id="cb682-8"><a aria-hidden="true" href="#cb682-8" tabindex="-1"></a>   tad d4                <span class="st">" Advance to next</span></span>
<span id="cb682-9"><a aria-hidden="true" href="#cb682-9" tabindex="-1"></a>   dac nameptr           <span class="st">" Store</span></span>
<span id="cb682-10"><a aria-hidden="true" href="#cb682-10" tabindex="-1"></a>   " ... process <span class="dt">file</span> <span class="op">...</span></span>
<span id="cb682-11"><a aria-hidden="true" href="#cb682-11" tabindex="-1"></a>   <span class="cf">jmp</span> loop</span></code></pre></div>
<p>This pattern appears in: cat, cp, chmod, chown, chrm</p>
<h3 data-number="9.5.2" id="pattern-2-character-packingunpacking"><span class="header-section-number">9.5.2</span> Pattern 2: Character
Packing/Unpacking</h3>
<p><strong>Pack two 9-bit characters into 18-bit word:</strong></p>
<div class="sourceCode" id="cb683"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb683-1"><a aria-hidden="true" href="#cb683-1" tabindex="-1"></a>" Even character <span class="op">(</span>high <span class="dv">9</span> bits<span class="op">)</span></span>
<span id="cb683-2"><a aria-hidden="true" href="#cb683-2" tabindex="-1"></a>lac char</span>
<span id="cb683-3"><a aria-hidden="true" href="#cb683-3" tabindex="-1"></a>alss <span class="dv">9</span>                   <span class="st">" Shift left 9</span></span>
<span id="cb683-4"><a aria-hidden="true" href="#cb683-4" tabindex="-1"></a>dac <span class="dt">word</span>                 <span class="st">" Store</span></span>
<span id="cb683-5"><a aria-hidden="true" href="#cb683-5" tabindex="-1"></a></span>
<span id="cb683-6"><a aria-hidden="true" href="#cb683-6" tabindex="-1"></a>" Odd character <span class="op">(</span>low <span class="dv">9</span> bits<span class="op">)</span></span>
<span id="cb683-7"><a aria-hidden="true" href="#cb683-7" tabindex="-1"></a>lac <span class="dt">word</span></span>
<span id="cb683-8"><a aria-hidden="true" href="#cb683-8" tabindex="-1"></a><span class="bu">and</span> o777000              <span class="st">" Keep high bits</span></span>
<span id="cb683-9"><a aria-hidden="true" href="#cb683-9" tabindex="-1"></a><span class="bu">xor</span> char                 <span class="st">" OR in low bits</span></span>
<span id="cb683-10"><a aria-hidden="true" href="#cb683-10" tabindex="-1"></a>dac <span class="dt">word</span></span></code></pre></div>
<p><strong>Unpack:</strong></p>
<div class="sourceCode" id="cb684"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb684-1"><a aria-hidden="true" href="#cb684-1" tabindex="-1"></a>" Get even character <span class="op">(</span>high <span class="dv">9</span> bits<span class="op">)</span></span>
<span id="cb684-2"><a aria-hidden="true" href="#cb684-2" tabindex="-1"></a>lac <span class="dt">word</span></span>
<span id="cb684-3"><a aria-hidden="true" href="#cb684-3" tabindex="-1"></a>lrss <span class="dv">9</span>                   <span class="st">" Shift right 9</span></span>
<span id="cb684-4"><a aria-hidden="true" href="#cb684-4" tabindex="-1"></a><span class="bu">and</span> o777                 <span class="st">" Mask to 9 bits</span></span>
<span id="cb684-5"><a aria-hidden="true" href="#cb684-5" tabindex="-1"></a></span>
<span id="cb684-6"><a aria-hidden="true" href="#cb684-6" tabindex="-1"></a>" Get odd character <span class="op">(</span>low <span class="dv">9</span> bits<span class="op">)</span></span>
<span id="cb684-7"><a aria-hidden="true" href="#cb684-7" tabindex="-1"></a>lac <span class="dt">word</span></span>
<span id="cb684-8"><a aria-hidden="true" href="#cb684-8" tabindex="-1"></a><span class="bu">and</span> o777                 <span class="st">" Mask to 9 bits</span></span></code></pre></div>
<p>This pattern appears in: cat, init, and throughout the system</p>
<h3 data-number="9.5.3" id="pattern-3-buffered-io"><span class="header-section-number">9.5.3</span> Pattern 3: Buffered I/O</h3>
<p><strong>Standard buffer structure:</strong></p>
<div class="sourceCode" id="cb685"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb685-1"><a aria-hidden="true" href="#cb685-1" tabindex="-1"></a><span class="fu">buf:</span> .=.+64              " 64-<span class="dt">word</span> buffer</span>
<span id="cb685-2"><a aria-hidden="true" href="#cb685-2" tabindex="-1"></a><span class="fu">bufptr:</span> buf              <span class="st">" Current position</span></span>
<span id="cb685-3"><a aria-hidden="true" href="#cb685-3" tabindex="-1"></a><span class="fu">endptr:</span> buf<span class="op">+</span><span class="dv">64</span>           <span class="st">" End of buffer</span></span></code></pre></div>
<p><strong>Read with buffering:</strong></p>
<div class="sourceCode" id="cb686"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb686-1"><a aria-hidden="true" href="#cb686-1" tabindex="-1"></a><span class="fu">getc:</span></span>
<span id="cb686-2"><a aria-hidden="true" href="#cb686-2" tabindex="-1"></a>   lac bufptr            <span class="st">" Get current position</span></span>
<span id="cb686-3"><a aria-hidden="true" href="#cb686-3" tabindex="-1"></a>   sad endptr            <span class="st">" Skip if not at end</span></span>
<span id="cb686-4"><a aria-hidden="true" href="#cb686-4" tabindex="-1"></a>   <span class="cf">jmp</span> fillbuf           <span class="st">" Refill buffer</span></span>
<span id="cb686-5"><a aria-hidden="true" href="#cb686-5" tabindex="-1"></a>   dac temp              <span class="st">" Save pointer</span></span>
<span id="cb686-6"><a aria-hidden="true" href="#cb686-6" tabindex="-1"></a>   <span class="bu">add</span> o400000           <span class="st">" Increment</span></span>
<span id="cb686-7"><a aria-hidden="true" href="#cb686-7" tabindex="-1"></a>   dac bufptr            <span class="st">" Update pointer</span></span>
<span id="cb686-8"><a aria-hidden="true" href="#cb686-8" tabindex="-1"></a>   " ... extract character <span class="op">...</span></span>
<span id="cb686-9"><a aria-hidden="true" href="#cb686-9" tabindex="-1"></a>   <span class="cf">jmp</span> getc i            <span class="st">" Return</span></span>
<span id="cb686-10"><a aria-hidden="true" href="#cb686-10" tabindex="-1"></a></span>
<span id="cb686-11"><a aria-hidden="true" href="#cb686-11" tabindex="-1"></a><span class="fu">fillbuf:</span></span>
<span id="cb686-12"><a aria-hidden="true" href="#cb686-12" tabindex="-1"></a>   lac fd</span>
<span id="cb686-13"><a aria-hidden="true" href="#cb686-13" tabindex="-1"></a>   sys read<span class="co">; buf; 64     " Read 64 words</span></span>
<span id="cb686-14"><a aria-hidden="true" href="#cb686-14" tabindex="-1"></a>   lac buf</span>
<span id="cb686-15"><a aria-hidden="true" href="#cb686-15" tabindex="-1"></a>   dac bufptr            <span class="st">" Reset pointer</span></span>
<span id="cb686-16"><a aria-hidden="true" href="#cb686-16" tabindex="-1"></a>   <span class="cf">jmp</span> getc              <span class="st">" Retry</span></span></code></pre></div>
<p>This pattern appears in: cat, cp, init</p>
<h3 data-number="9.5.4" id="pattern-4-error-reporting"><span class="header-section-number">9.5.4</span> Pattern 4: Error
Reporting</h3>
<p><strong>Standard error message:</strong></p>
<div class="sourceCode" id="cb687"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb687-1"><a aria-hidden="true" href="#cb687-1" tabindex="-1"></a><span class="fu">error:</span></span>
<span id="cb687-2"><a aria-hidden="true" href="#cb687-2" tabindex="-1"></a>   lac filename          <span class="st">" Get filename</span></span>
<span id="cb687-3"><a aria-hidden="true" href="#cb687-3" tabindex="-1"></a>   dac <span class="fl">1</span><span class="bn">f</span></span>
<span id="cb687-4"><a aria-hidden="true" href="#cb687-4" tabindex="-1"></a>   lac d1                <span class="st">" FD 1 (stdout)</span></span>
<span id="cb687-5"><a aria-hidden="true" href="#cb687-5" tabindex="-1"></a>   sys write<span class="co">; 1: 0; 4    " Write filename (4 chars)</span></span>
<span id="cb687-6"><a aria-hidden="true" href="#cb687-6" tabindex="-1"></a>   lac d1</span>
<span id="cb687-7"><a aria-hidden="true" href="#cb687-7" tabindex="-1"></a>   sys write<span class="co">; errmsg; 2  " Write "? \n"</span></span>
<span id="cb687-8"><a aria-hidden="true" href="#cb687-8" tabindex="-1"></a>   <span class="cf">jmp</span> continue          <span class="st">" Keep going</span></span>
<span id="cb687-9"><a aria-hidden="true" href="#cb687-9" tabindex="-1"></a></span>
<span id="cb687-10"><a aria-hidden="true" href="#cb687-10" tabindex="-1"></a><span class="fu">errmsg:</span></span>
<span id="cb687-11"><a aria-hidden="true" href="#cb687-11" tabindex="-1"></a>   040<span class="co">;077012            " "? \n"</span></span></code></pre></div>
<p>This pattern appears in: cat, cp, chmod, chown, chrm</p>
<h3 data-number="9.5.5" id="pattern-5-octal-parsing"><span class="header-section-number">9.5.5</span> Pattern 5: Octal Parsing</h3>
<p><strong>Convert ASCII octal string to number:</strong></p>
<div class="sourceCode" id="cb688"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb688-1"><a aria-hidden="true" href="#cb688-1" tabindex="-1"></a>   dzm result            <span class="st">" Clear result</span></span>
<span id="cb688-2"><a aria-hidden="true" href="#cb688-2" tabindex="-1"></a>   -8                    " Up to <span class="dv">8</span> digits</span>
<span id="cb688-3"><a aria-hidden="true" href="#cb688-3" tabindex="-1"></a>   dac count</span>
<span id="cb688-4"><a aria-hidden="true" href="#cb688-4" tabindex="-1"></a>1:</span>
<span id="cb688-5"><a aria-hidden="true" href="#cb688-5" tabindex="-1"></a>   " ... get next character <span class="op">...</span></span>
<span id="cb688-6"><a aria-hidden="true" href="#cb688-6" tabindex="-1"></a>   tad om60              <span class="st">" Subtract '0' (060 octal)</span></span>
<span id="cb688-7"><a aria-hidden="true" href="#cb688-7" tabindex="-1"></a>   lmq                   <span class="st">" Save digit</span></span>
<span id="cb688-8"><a aria-hidden="true" href="#cb688-8" tabindex="-1"></a>   lac result</span>
<span id="cb688-9"><a aria-hidden="true" href="#cb688-9" tabindex="-1"></a>   cll<span class="co">; als 3            " Shift left 3 (√ó 8)</span></span>
<span id="cb688-10"><a aria-hidden="true" href="#cb688-10" tabindex="-1"></a>   omq                   <span class="st">" OR in digit</span></span>
<span id="cb688-11"><a aria-hidden="true" href="#cb688-11" tabindex="-1"></a>   dac result</span>
<span id="cb688-12"><a aria-hidden="true" href="#cb688-12" tabindex="-1"></a>   isz count</span>
<span id="cb688-13"><a aria-hidden="true" href="#cb688-13" tabindex="-1"></a>   <span class="cf">jmp</span> <span class="bn">1b</span></span></code></pre></div>
<p>This pattern appears in: chmod, chown, init</p>
<h3 data-number="9.5.6" id="pattern-6-self-modifying-code"><span class="header-section-number">9.5.6</span> Pattern 6: Self-Modifying
Code</h3>
<p><strong>Build instructions at runtime:</strong></p>
<div class="sourceCode" id="cb689"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb689-1"><a aria-hidden="true" href="#cb689-1" tabindex="-1"></a>   lac bitpos            <span class="st">" Get bit position</span></span>
<span id="cb689-2"><a aria-hidden="true" href="#cb689-2" tabindex="-1"></a>   tad shiftinst         <span class="st">" Add to instruction template</span></span>
<span id="cb689-3"><a aria-hidden="true" href="#cb689-3" tabindex="-1"></a>   dac <span class="fl">1</span><span class="bn">f</span>                <span class="st">" Store as next instruction</span></span>
<span id="cb689-4"><a aria-hidden="true" href="#cb689-4" tabindex="-1"></a>   lac d1</span>
<span id="cb689-5"><a aria-hidden="true" href="#cb689-5" tabindex="-1"></a>1: alss <span class="dv">0</span>                <span class="st">" This instruction is modified!</span></span></code></pre></div>
<p>This pattern appears in: check (for bitmap operations)</p>
<h3 data-number="9.5.7" id="pattern-7-word-aligned-string-storage"><span class="header-section-number">9.5.7</span> Pattern 7: Word-Aligned
String Storage</h3>
<p><strong>Store strings as packed characters:</strong></p>
<div class="sourceCode" id="cb690"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb690-1"><a aria-hidden="true" href="#cb690-1" tabindex="-1"></a><span class="fu">filename:</span></span>
<span id="cb690-2"><a aria-hidden="true" href="#cb690-2" tabindex="-1"></a>   &lt;ab<span class="op">&gt;</span><span class="co">;&lt;cd&gt;;&lt;ef&gt;; 040040    " "abcdef  "</span></span>
<span id="cb690-3"><a aria-hidden="true" href="#cb690-3" tabindex="-1"></a></span>
<span id="cb690-4"><a aria-hidden="true" href="#cb690-4" tabindex="-1"></a>" First <span class="dt">word</span><span class="op">:</span> <span class="st">'a'</span> in high <span class="dv">9</span> bits<span class="op">,</span> <span class="st">'b'</span> in low <span class="dv">9</span> bits</span>
<span id="cb690-5"><a aria-hidden="true" href="#cb690-5" tabindex="-1"></a>" Second <span class="dt">word</span><span class="op">:</span> <span class="st">'c'</span> <span class="op">and</span> <span class="st">'d'</span></span>
<span id="cb690-6"><a aria-hidden="true" href="#cb690-6" tabindex="-1"></a>" Third <span class="dt">word</span><span class="op">:</span> <span class="st">'e'</span> <span class="op">and</span> <span class="st">'f'</span></span>
<span id="cb690-7"><a aria-hidden="true" href="#cb690-7" tabindex="-1"></a>" Fourth <span class="dt">word</span><span class="op">:</span> two spaces <span class="op">(</span>padding<span class="op">)</span></span></code></pre></div>
<p>This pattern appears in: all utilities for filenames and messages</p>
<h2 data-number="9.6" id="the-minimalist-aesthetic"><span class="header-section-number">9.6</span> 11.6 The Minimalist
Aesthetic</h2>
<h3 data-number="9.6.1" id="lines-of-code-comparison"><span class="header-section-number">9.6.1</span> Lines of Code Comparison</h3>
<table>
<thead>
<tr>
<th>Utility</th>
<th>PDP-7 Lines</th>
<th>Modern Lines</th>
<th>Ratio</th>
</tr>
</thead>
<tbody>
<tr>
<td>cat</td>
<td>146</td>
<td>~800 (GNU cat)</td>
<td>5.5√ó</td>
</tr>
<tr>
<td>cp</td>
<td>97</td>
<td>~1200 (GNU cp)</td>
<td>12.4√ó</td>
</tr>
<tr>
<td>chmod</td>
<td>77</td>
<td>~600 (GNU chmod)</td>
<td>7.8√ó</td>
</tr>
<tr>
<td>chown</td>
<td>78</td>
<td>~500 (GNU chown)</td>
<td>6.4√ó</td>
</tr>
<tr>
<td>init</td>
<td>292</td>
<td>~2500 (systemd)</td>
<td>8.6√ó</td>
</tr>
<tr>
<td>fsck (check)</td>
<td>324</td>
<td>~15000 (e2fsck)</td>
<td>46.3√ó</td>
</tr>
<tr>
<td><strong>Total</strong></td>
<td><strong>1014</strong></td>
<td><strong>~20600</strong></td>
<td><strong>20.3√ó</strong></td>
</tr>
</tbody>
</table>
<p>Modern versions are 20√ó larger on average. Why?</p>
<p><strong>Features Added:</strong> - Internationalization (i18n) - Long
options (‚Äìhelp, ‚Äìversion) - Security hardening - Extended attributes -
Unicode support - Error recovery - Progress reporting -
Accessibility</p>
<p><strong>What‚Äôs Missing From PDP-7 Versions:</strong></p>
<p>cat: - No line numbering (-n) - No tab display (-T) - No non-printing
characters (-v) - No squeeze blank lines (-s)</p>
<p>cp: - No recursive copy (-r) - No preserve permissions (-p) - No
interactive prompting (-i) - No verbose mode (-v) - No symlink
handling</p>
<p>chmod: - No symbolic modes (u+rwx) - No recursive (-R) - No verbose
(-v) - No reference file</p>
<p>check: - No automatic repair - No journaling support - No progress
reporting - No bad block handling - No snapshot support</p>
<h3 data-number="9.6.2" id="why-less-was-more"><span class="header-section-number">9.6.2</span> Why Less Was More</h3>
<p>The minimal feature set was actually beneficial:</p>
<p><strong>Advantages:</strong> 1. <strong>Understandable:</strong>
Anyone could read the entire source 2. <strong>Debuggable:</strong>
Fewer bugs due to simpler code 3. <strong>Maintainable:</strong> Easy to
modify or fix 4. <strong>Portable:</strong> Simple code ported to new
systems easily 5. <strong>Fast:</strong> No overhead from unused
features</p>
<p><strong>Memory Savings:</strong></p>
<pre><code>PDP-7 utilities total: 1014 lines √ó ~10 bytes/line = ~10KB
Modern utilities total: 20600 lines √ó ~40 bytes/line = ~800KB

Ratio: Modern versions are 80√ó larger in binary size</code></pre>
<p>The entire set of PDP-7 utilities fit in 10KB. Modern cat alone is
often 50KB+.</p>
<h3 data-number="9.6.3" id="the-constraint-driven-design-process"><span class="header-section-number">9.6.3</span> The Constraint-Driven Design
Process</h3>
<p>How did minimalism emerge?</p>
<ol type="1">
<li><strong>Write Initial Version:</strong> Implement basic
functionality</li>
<li><strong>Hit Memory Limit:</strong> Program too large for available
memory</li>
<li><strong>Cut Features:</strong> Remove everything non-essential</li>
<li><strong>Optimize Code:</strong> Make it smaller and faster</li>
<li><strong>Ship It:</strong> No time for more features anyway</li>
</ol>
<p>The result: only essential features remained. This wasn‚Äôt planned‚Äîit
was forced by constraints.</p>
<h3 data-number="9.6.4" id="cultural-impact-on-modern-software"><span class="header-section-number">9.6.4</span> Cultural Impact on Modern
Software</h3>
<p>The minimalist aesthetic became a design principle:</p>
<p><strong>Unix Philosophy Commandments:</strong> 1. Make each program
do one thing well 2. Expect the output of every program to become the
input to another 3. Design and build software to be tried early 4. Use
tools rather than unskilled help to lighten a programming task</p>
<p>These weren‚Äôt philosophical insights‚Äîthey were survival strategies
for programming on minimal hardware. But they worked so well that they
became principles.</p>
<p>Modern examples of this philosophy: - Microservices (vs.¬†monoliths) -
Single Responsibility Principle (OOP) - Unix command pipelines -
Functional programming (small functions) - API design (minimal surface
area)</p>
<p>All trace back to the PDP-7 constraint: <strong>you literally
couldn‚Äôt build large programs, so you learned to build small ones
well</strong>.</p>
<h2 data-number="9.7" id="historical-context-2"><span class="header-section-number">9.7</span> 11.7 Historical Context</h2>
<h3 data-number="9.7.1" id="what-utilities-existed-on-other-1969-systems"><span class="header-section-number">9.7.1</span> What Utilities Existed on
Other 1969 Systems?</h3>
<p>To appreciate Unix‚Äôs innovation, consider what else existed in
1969:</p>
<h4 data-number="9.7.1.1" id="ibm-os360-mainframe-batch-processing"><span class="header-section-number">9.7.1.1</span> IBM OS/360 (Mainframe Batch
Processing)</h4>
<p><strong>Job Control Language (JCL):</strong></p>
<pre><code>//MYJOB JOB (ACCT),'PROGRAMMER NAME',CLASS=A,MSGCLASS=X
//STEP1 EXEC PGM=IEBGENER
//SYSPRINT DD SYSOUT=*
//SYSIN DD DUMMY
//SYSUT1 DD DSN=INPUT.FILE,DISP=SHR
//SYSUT2 DD DSN=OUTPUT.FILE,DISP=(NEW,CATLG,DELETE),
// UNIT=SYSDA,SPACE=(CYL,(5,1)),DCB=(RECFM=FB,LRECL=80)</code></pre>
<p>This is roughly equivalent to <code>cp input.file output.file</code>
in Unix.</p>
<p><strong>Characteristics:</strong> - Verbose, complex syntax - Jobs
submitted via cards - Hours between submission and results - No
interactive utilities - Everything through batch system</p>
<h4 data-number="9.7.1.2" id="ctss-compatible-time-sharing-system"><span class="header-section-number">9.7.1.2</span> CTSS (Compatible
Time-Sharing System)</h4>
<p><strong>Commands:</strong> - <code>LOGIN</code> - Log in -
<code>LOGOUT</code> - Log out - <code>LISTF</code> - List files -
<code>DUMP</code> - Display file contents - <code>TYPIST</code> - Text
editor - <code>MAD</code> - Compile MAD program - <code>LOAD</code> -
Load program - <code>START</code> - Run program</p>
<p><strong>Characteristics:</strong> - Interactive (revolutionary for
1961!) - Commands built into supervisor - No concept of external
programs - No pipelines or composition - Each command was
special-purpose</p>
<h4 data-number="9.7.1.3" id="multics-multiplexed-information-and-computing-service"><span class="header-section-number">9.7.1.3</span> Multics (Multiplexed
Information and Computing Service)</h4>
<p><strong>Commands:</strong> - <code>print</code> - Print file -
<code>copy</code> - Copy file - <code>list</code> - List directory -
<code>edit</code> - Interactive editor (very sophisticated) -
<code>mail</code> - Send mail - <code>who</code> - List users</p>
<p><strong>Characteristics:</strong> - Sophisticated command language -
Heavy, feature-rich commands - Integrated into complex OS - Required
mainframe-class hardware - Commands were built-in, not separate
programs</p>
<h4 data-number="9.7.1.4" id="dec-os8-pdp-8-operating-system"><span class="header-section-number">9.7.1.4</span> DEC OS/8 (PDP-8 Operating
System)</h4>
<p><strong>Commands:</strong> - <code>DIR</code> - Directory -
<code>PIP</code> - Peripheral Interchange Program (copy files) -
<code>EDIT</code> - Text editor - <code>FOTP</code> - File-Oriented
Transfer Program - <code>PAL8</code> - Assembler</p>
<p><strong>Characteristics:</strong> - Simple monitor - Few commands
(memory constraints) - Most functionality in PIP (like MS-DOS later) -
Commands loaded from storage on demand - No multi-user support</p>
<h3 data-number="9.7.2" id="the-batch-processing-era"><span class="header-section-number">9.7.2</span> The Batch Processing Era</h3>
<p>In 1969, most computing was batch processing:</p>
<p><strong>Typical Workflow:</strong> 1. Write program on coding sheets
2. Keypunch cards from sheets 3. Submit card deck to operator 4. Wait
hours or days 5. Receive printout 6. Debug from printout 7. Re-punch
cards 8. Goto 3</p>
<p><strong>No Interactive Utilities:</strong> - Couldn‚Äôt cat a file (no
terminal) - Couldn‚Äôt cp interactively (submit JCL job) - Couldn‚Äôt chmod
(no file permissions) - Couldn‚Äôt check filesystem (operator‚Äôs job)</p>
<p>Unix was revolutionary because you could type a command and see
results instantly.</p>
<h3 data-number="9.7.3" id="time-sharing-system-commands"><span class="header-section-number">9.7.3</span> Time-Sharing System
Commands</h3>
<p>CTSS and Multics pioneered time-sharing, but their commands differed
from Unix:</p>
<p><strong>CTSS LISTF (equivalent to ls):</strong></p>
<pre><code>LISTF
FILE1    12/01/68 15:30
FILE2    12/02/68 09:15
FILE3    12/02/68 14:22</code></pre>
<p><strong>Unix ls:</strong></p>
<pre><code>$ ls
file1
file2
file3</code></pre>
<p><strong>Key Difference:</strong> CTSS LISTF was built into the
supervisor. Unix ls was a separate program that anyone could replace or
modify.</p>
<p><strong>Multics print (equivalent to cat):</strong></p>
<pre><code>print file1
[contents of file1]</code></pre>
<p><strong>Unix cat:</strong></p>
<pre><code>$ cat file1
[contents of file1]</code></pre>
<p><strong>Key Difference:</strong> Multics print had dozens of options
and features. Unix cat did one thing: concatenate files.</p>
<h3 data-number="9.7.4" id="how-unix-utilities-differed"><span class="header-section-number">9.7.4</span> How Unix Utilities
Differed</h3>
<p><strong>1. External Programs:</strong> - Other systems: commands
built into OS - Unix: commands are executable files - Impact: users
could write new commands</p>
<p><strong>2. Uniform Interface:</strong> - Other systems: each command
had unique syntax - Unix: all commands read stdin, write stdout -
Impact: commands could be composed (later: pipes)</p>
<p><strong>3. Minimal Feature Sets:</strong> - Other systems:
feature-rich integrated commands - Unix: simple tools that do one thing
- Impact: smaller, faster, more maintainable</p>
<p><strong>4. File-Based:</strong> - Other systems: special syntax for
devices and files - Unix: everything is a file - Impact: uniform
handling of files, devices, pipes</p>
<p><strong>5. Accessible Source:</strong> - Other systems: proprietary,
closed source - Unix: source code available and readable - Impact: users
could study and modify utilities</p>
<h3 data-number="9.7.5" id="the-lasting-influence-on-command-line-culture"><span class="header-section-number">9.7.5</span> The Lasting Influence on
Command-Line Culture</h3>
<p>The PDP-7 utilities established patterns that persist today:</p>
<p><strong>Short Command Names:</strong> - PDP-7: cat, cp, chmod, chown
- Modern: ls, mv, rm, grep, sed, awk - Impact: fast to type, easy to
remember</p>
<p><strong>Simple Syntax:</strong> - PDP-7: <code>cat file1 file2</code>
- Modern: <code>cat file1 file2</code> - Impact: consistent,
learnable</p>
<p><strong>Composability:</strong> - PDP-7: uniform I/O (no pipes yet) -
Later Unix: <code>cat file | grep pattern</code> - Impact: small tools
combine powerfully</p>
<p><strong>Manual Pages:</strong> - PDP-7: no docs (too small) - Later
Unix: man pages for every command - Impact: self-documenting system</p>
<p><strong>Everything is a File:</strong> - PDP-7: devices as files -
Modern: sockets, processes, devices all as files - Impact: uniform
interface to everything</p>
<h3 data-number="9.7.6" id="from-necessity-to-philosophy"><span class="header-section-number">9.7.6</span> From Necessity to
Philosophy</h3>
<p>The evolution:</p>
<p><strong>1969 (PDP-7):</strong> - Constraint: 8K words of memory -
Response: Small utilities - Reason: No choice</p>
<p><strong>1971 (PDP-11):</strong> - Resource: More memory available -
Decision: Keep utilities small - Reason: It works well</p>
<p><strong>1973 (Unix Time-Sharing):</strong> - Resource: Multiple users
- Decision: Small tools, pipes - Reason: Efficiency and
composability</p>
<p><strong>1974 (Unix Paper Published):</strong> - Document: ‚ÄúThe Unix
Time-Sharing System‚Äù - Message: Simple tools are a design philosophy -
Impact: Other systems adopt the model</p>
<p><strong>1980s (Unix Wars):</strong> - Fragmentation: Many Unix
variants - Constant: Small tool philosophy - Result: Philosophy
transcends implementations</p>
<p><strong>1990s (Linux):</strong> - Revolution: Free Unix clone -
Preservation: GNU utilities follow Unix model - Scale: Millions of users
adopt the philosophy</p>
<p><strong>2000s (Open Source):</strong> - Expansion: Philosophy spreads
beyond Unix - Examples: Git, Node.js, Go tools - Culture: ‚ÄúDo one thing
well‚Äù becomes universal</p>
<h3 data-number="9.7.7" id="the-irony-of-success"><span class="header-section-number">9.7.7</span> The Irony of Success</h3>
<p>The PDP-7 utilities were minimal because they had to be. Now they‚Äôre
celebrated as brilliant design.</p>
<p>Ken Thompson later said: &gt; ‚ÄúI didn‚Äôt design Unix to be portable,
or to have small tools, or any of that. I designed it to get work done
on the hardware I had. Everything else emerged from constraints.‚Äù</p>
<p>The ‚ÄúUnix Philosophy‚Äù was discovered, not invented.</p>
<h3 data-number="9.7.8" id="modern-lessons"><span class="header-section-number">9.7.8</span> Modern Lessons</h3>
<p>What can modern developers learn from PDP-7 utilities?</p>
<p><strong>1. Constraints Drive Innovation:</strong> - Limited memory
forced simplicity - Simplicity proved superior - Lesson: Embrace
constraints</p>
<p><strong>2. Small is Beautiful:</strong> - PDP-7 cat: 146 lines, does
one thing - Modern cat: 800 lines, does many things - Lesson: Feature
bloat is optional</p>
<p><strong>3. Composition Over Integration:</strong> - Small tools that
combine - Better than large integrated systems - Lesson: Build
composable components</p>
<p><strong>4. Source Code as Documentation:</strong> - PDP-7 code is
readable - Modern code is often opaque - Lesson: Clarity matters</p>
<p><strong>5. Optimization Later:</strong> - PDP-7 utilities were simple
first - Optimization came when needed - Lesson: Premature optimization
is evil</p>
<h3 data-number="9.7.9" id="conclusion-philosophy-from-pragmatism"><span class="header-section-number">9.7.9</span> Conclusion: Philosophy from
Pragmatism</h3>
<p>The Unix philosophy emerged from the pragmatic constraints of PDP-7
development:</p>
<ul>
<li><strong>8K words of memory</strong> ‚Üí Small programs</li>
<li><strong>Slow DECtape</strong> ‚Üí Efficient I/O</li>
<li><strong>Limited development time</strong> ‚Üí Simple designs</li>
<li><strong>Two developers</strong> ‚Üí Minimal features</li>
<li><strong>No formal requirements</strong> ‚Üí Organic evolution</li>
</ul>
<p>These constraints accidentally created the most influential computing
philosophy of the past 50 years.</p>
<p>The PDP-7 utilities weren‚Äôt designed to be minimal‚Äîthey had to be
minimal. That they were also elegant, maintainable, and composable was a
happy accident.</p>
<p>Or as Dennis Ritchie put it: &gt; ‚ÄúUnix is simple. It just takes a
genius to understand its simplicity.‚Äù</p>
<p>The genius wasn‚Äôt in planning simplicity‚Äîit was in recognizing that
the constraints had forced them to build something better than they‚Äôd
originally intended.</p>
<hr/>
<p><strong>End of Chapter 11</strong></p>
<p><strong>Next Chapter:</strong> Chapter 12 - The Shell: Command
Interpretation and Execution</p>
<h1 data-number="10" id="chapter-12-the-b-language-system-unixs-first-high-level-language"><span class="header-section-number">10</span> Chapter 12: The B Language
System ‚Äî Unix‚Äôs First High-Level Language</h1>
<p><em>‚ÄúB was a direct descendant of BCPL, which was a systems
programming language. B was designed to be simple and close to the
machine.‚Äù</em> ‚Äî Ken Thompson</p>
<p>In 1969, while Unix was still being born on the PDP-7, Ken Thompson
created something revolutionary: a high-level programming language
simple enough to implement in a tiny interpreter, yet powerful enough
for systems programming. He called it <strong>B</strong>.</p>
<p>B was Unix‚Äôs first programming language, predating C by three years.
It gave PDP-7 Unix users the ability to write programs in a readable,
structured language instead of assembly code. While B is often
overshadowed by its successor C, it was a crucial stepping stone‚Äîthe
link between BCPL and the language that would change the world.</p>
<p>This chapter explores the complete B language system: the interpreter
(<code>bi.s</code>), compiler support (<code>bc.s</code>), runtime
library (<code>bl.s</code>), and the programs written in it.</p>
<hr/>
<h2 data-number="10.1" id="b-language-origins"><span class="header-section-number">10.1</span> 12.1 B Language Origins</h2>
<h3 data-number="10.1.1" id="ken-thompsons-creation-1969"><span class="header-section-number">10.1.1</span> Ken Thompson‚Äôs Creation
(1969)</h3>
<p>When Ken Thompson began implementing Unix on the PDP-7 in the summer
of 1969, he faced a fundamental choice: should users write programs only
in assembly language, or should there be a higher-level alternative?</p>
<p><strong>The Context:</strong></p>
<p>In 1969, most programming was done in: - <strong>Assembly
language</strong> - Direct hardware control, very efficient, but tedious
and error-prone - <strong>FORTRAN</strong> - Scientific computing,
compiled, fast, but not suitable for systems programming -
<strong>COBOL</strong> - Business data processing, verbose, not suitable
for small systems - <strong>ALGOL</strong> - Academic language, elegant
but complex - <strong>LISP</strong> - AI research, interpreted,
memory-intensive</p>
<p>None of these fit Unix‚Äôs needs: a simple, compact language that could
run on a machine with only 8K words of memory.</p>
<h3 data-number="10.1.2" id="evolution-from-bcpl"><span class="header-section-number">10.1.2</span> Evolution from BCPL</h3>
<p>Thompson had recently worked on the <strong>Multics</strong> project
at MIT, where he encountered <strong>BCPL</strong> (Basic Combined
Programming Language), created by Martin Richards at Cambridge
University in 1966.</p>
<p><strong>BCPL‚Äôs Key Characteristics:</strong></p>
<pre class="bcpl"><code>// BCPL Example - Everything is a word
LET START() BE
$(  LET V = VEC 100       // Vector (array) of 100 words
    LET I = 0
    WHILE I &lt; 100 DO
    $(  V!I := I * I      // ! is indirection operator
        I := I + 1
    $)
    WRITEF("Done*N")
$)</code></pre>
<p><strong>What Thompson Liked About BCPL:</strong> -
<strong>Typeless</strong>: Everything is a word (memory cell) -
<strong>Simple</strong>: Few keywords, simple syntax -
<strong>Systems-oriented</strong>: Low-level operations possible -
<strong>Compact</strong>: Could be implemented in limited memory -
<strong>Portable</strong>: Abstract enough to move between machines</p>
<p><strong>What He Changed for B:</strong></p>
<p>Thompson simplified BCPL even further, creating B:</p>
<pre class="b"><code>/* B version - Even simpler syntax */
main() {
    auto v[100], i;
    i = 0;
    while (i &lt; 100) {
        v[i] = i * i;
        i++;
    }
    printf("Done*n");
}</code></pre>
<p><strong>Key Differences from BCPL:</strong> - <strong>C-like
syntax</strong>: <code>{</code> <code>}</code> instead of
<code>$(</code> <code>$)</code> - <strong>Simpler keywords</strong>:
<code>auto</code> instead of <code>LET</code> - <strong>More
operators</strong>: <code>++</code>, <code>--</code>, compound
assignments - <strong>Function syntax</strong>: Closer to C -
<strong>Character constants</strong>: <code>'*n'</code> for newline
instead of <code>*N</code></p>
<h3 data-number="10.1.3" id="precursor-to-c"><span class="header-section-number">10.1.3</span> Precursor to C</h3>
<p>B was explicitly designed as a stepping stone. Thompson knew its
limitations but needed something quickly. The language had to:</p>
<ol type="1">
<li><strong>Run in 8K words</strong> - Interpreter small enough for
PDP-7</li>
<li><strong>Be implementable in weeks</strong> - No time for complex
compiler</li>
<li><strong>Support systems programming</strong> - Pointers, bit
operations</li>
<li><strong>Be fast enough</strong> - Reasonable performance for
utilities</li>
</ol>
<p>B achieved all these goals. It was: - <strong>Interpreted</strong>,
not compiled (simpler to implement) - <strong>Word-oriented</strong>
(matched PDP-7‚Äôs 18-bit architecture) - <strong>Typeless</strong> (no
type checking overhead) - <strong>Stack-based</strong> (simple execution
model)</p>
<p>Three years later, Dennis Ritchie evolved B into C by adding: -
<strong>Types</strong> (<code>int</code>, <code>char</code>,
<code>float</code>, structs) - <strong>Byte addressing</strong> (for
byte-oriented machines) - <strong>Compilation</strong> (for better
performance) - <strong>More operators</strong> (unary <code>*</code>,
<code>&amp;</code>)</p>
<h3 data-number="10.1.4" id="why-a-high-level-language"><span class="header-section-number">10.1.4</span> Why a High-Level
Language?</h3>
<p><strong>The Advantages:</strong></p>
<ol type="1">
<li><strong>Productivity</strong> - Write programs faster than in
assembly</li>
<li><strong>Readability</strong> - Code easier to understand and
maintain</li>
<li><strong>Portability</strong> - More abstract than assembly
(theoretically)</li>
<li><strong>Expressiveness</strong> - Complex operations in fewer
lines</li>
<li><strong>Experimentation</strong> - Rapid prototyping of ideas</li>
</ol>
<p><strong>Example Comparison:</strong></p>
<p><strong>Assembly (from previous chapters):</strong></p>
<pre class="assembly"><code>" Copy string - ~20 lines of assembly
strcpy: 0
   dac scpy1            " Save source pointer
   isz strcpy
   lac strcpy i         " Get destination pointer
   dac scpy2
   isz strcpy
   lac scpy1 i          " Get source pointer value
   dac 8
   lac scpy2 i          " Get dest pointer value
   dac 9
1:
   lac 8 i              " Load from source
   sna                  " Skip if non-zero
   jmp 2f               " Zero = end of string
   dac 9 i              " Store to dest
   jmp 1b               " Continue
2:
   dzm 9 i              " Store terminating zero
   jmp strcpy i         " Return
scpy1: .=.+1
scpy2: .=.+1</code></pre>
<p><strong>B Language:</strong></p>
<pre class="b"><code>/* Copy string - 5 lines of B */
strcpy(dest, src) {
    while (*dest++ = *src++)
        ;
}</code></pre>
<p>The B version is: - <strong>75% shorter</strong> - <strong>Instantly
readable</strong> - <strong>Less error-prone</strong> - <strong>Easier
to modify</strong></p>
<p>But there were trade-offs: - <strong>Slower execution</strong>
(interpreted, not compiled) - <strong>Larger memory footprint</strong>
(interpreter + bytecode) - <strong>Less control</strong> (can‚Äôt access
all hardware features)</p>
<h3 data-number="10.1.5" id="historical-context-3"><span class="header-section-number">10.1.5</span> Historical Context</h3>
<p><strong>Other High-Level Languages in 1969:</strong></p>
<table>
<colgroup>
<col style="width: 27%"/>
<col style="width: 16%"/>
<col style="width: 16%"/>
<col style="width: 21%"/>
<col style="width: 18%"/>
</colgroup>
<thead>
<tr>
<th>Language</th>
<th>Year</th>
<th>Type</th>
<th>Target</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>FORTRAN</td>
<td>1957</td>
<td>Compiled</td>
<td>Scientific</td>
<td>Fast, but not systems-oriented</td>
</tr>
<tr>
<td>LISP</td>
<td>1958</td>
<td>Interpreted</td>
<td>AI</td>
<td>Memory-intensive, garbage collection</td>
</tr>
<tr>
<td>COBOL</td>
<td>1959</td>
<td>Compiled</td>
<td>Business</td>
<td>Verbose, not suitable for small systems</td>
</tr>
<tr>
<td>ALGOL 60</td>
<td>1960</td>
<td>Compiled</td>
<td>Academic</td>
<td>Elegant but complex</td>
</tr>
<tr>
<td>BASIC</td>
<td>1964</td>
<td>Interpreted</td>
<td>Education</td>
<td>Simple but limited</td>
</tr>
<tr>
<td>BCPL</td>
<td>1966</td>
<td>Compiled</td>
<td>Systems</td>
<td>B‚Äôs direct ancestor</td>
</tr>
<tr>
<td><strong>B</strong></td>
<td><strong>1969</strong></td>
<td><strong>Interpreted</strong></td>
<td><strong>Unix utilities</strong></td>
<td><strong>Simple, compact, practical</strong></td>
</tr>
</tbody>
</table>
<p><strong>What Made B Different:</strong></p>
<ol type="1">
<li><strong>Designed for a specific system</strong> - Unix on PDP-7</li>
<li><strong>Minimal implementation</strong> - Small interpreter</li>
<li><strong>Systems-oriented</strong> - Pointers, bit operations</li>
<li><strong>Self-hosting potential</strong> - Could eventually compile
itself</li>
<li><strong>Evolutionary</strong> - Explicitly a stepping stone to
C</li>
</ol>
<p><strong>B‚Äôs Niche:</strong></p>
<p>B filled a unique gap: - <strong>Too complex for assembly</strong> -
String processing, parsing, algorithms - <strong>Too simple for
FORTRAN</strong> - Systems utilities, text manipulation - <strong>Too
constrained for LISP</strong> - Limited memory, no garbage collection -
<strong>Just right for Unix</strong> - Small programs, utilities,
prototypes</p>
<hr/>
<h2 data-number="10.2" id="b-language-syntax"><span class="header-section-number">10.2</span> 12.2 B Language Syntax</h2>
<h3 data-number="10.2.1" id="based-on-actual-.b-files"><span class="header-section-number">10.2.1</span> Based on Actual .b
Files</h3>
<p>Let‚Äôs examine real B programs from PDP-7 Unix to understand the
language‚Äôs syntax and capabilities.</p>
<h3 data-number="10.2.2" id="untyped-language"><span class="header-section-number">10.2.2</span> Untyped Language</h3>
<p>B‚Äôs most distinctive feature is being <strong>completely
typeless</strong>. Everything is a word (on PDP-7: 18 bits).</p>
<p><strong>No Type Declarations:</strong></p>
<pre class="b"><code>/* In C, you'd write: */
int count;
char *buffer;
int array[100];

/* In B, everything is just: */
count;
buffer;
array[100];</code></pre>
<p><strong>What This Means:</strong></p>
<pre class="b"><code>auto x;         /* x is a word */
x = 42;         /* x holds an integer */
x = &amp;y;         /* x holds a pointer */
x = 'A';        /* x holds a character */
/* All valid - B doesn't care! */</code></pre>
<p><strong>Implications:</strong></p>
<p><strong>Advantage</strong>: Simple language, fast implementation
<strong>Disadvantage</strong>: No type checking, easy to make errors</p>
<pre class="b"><code>auto x, y;
x = &amp;y;          /* x = pointer to y */
y = x + 10;      /* ERROR in C, but B allows it! */
*y = 42;         /* Probably crashes - y is not a valid pointer */</code></pre>
<h3 data-number="10.2.3" id="blocks-vs"><span class="header-section-number">10.2.3</span> Blocks: <code>$(</code>
<code>$)</code> vs <code>{</code> <code>}</code></h3>
<p>Early B used BCPL-style <code>$(</code> <code>$)</code> for blocks,
but later versions (including PDP-7) used C-style <code>{</code>
<code>}</code>:</p>
<p><strong>BCPL Style (Early B):</strong></p>
<pre class="b"><code>main() $(
    auto x;
    x = 10;
    printf("x = %d*n", x);
$)</code></pre>
<p><strong>C Style (PDP-7 Unix B):</strong></p>
<pre class="b"><code>main() {
    auto x;
    x = 10;
    printf("x = %d*n", x);
}</code></pre>
<p>PDP-7 B used the C-style syntax, as Thompson was already thinking
ahead to C‚Äôs design.</p>
<h3 data-number="10.2.4" id="external-declarations-extrn"><span class="header-section-number">10.2.4</span> External Declarations:
<code>extrn</code></h3>
<p>Functions and global variables visible to other compilation units are
declared with <code>extrn</code>:</p>
<pre class="b"><code>extrn printf, getchar, putchar;
extrn buffer, count, flag;

main() {
    printf("Hello*n");     /* extrn allows calling printf */
}</code></pre>
<p><strong>What <code>extrn</code> Does:</strong> - Declares a name as
externally defined - Similar to C‚Äôs <code>extern</code> - Tells B not to
allocate storage - Used for library functions and shared globals</p>
<p><strong>Example:</strong></p>
<pre class="b"><code>/* File 1: library.b */
buffer[100];               /* Allocates storage */
count;                     /* Allocates storage */

getline() {
    /* Uses buffer and count */
}

/* File 2: main.b */
extrn buffer, count;       /* Declares external references */
extrn getline;

main() {
    getline();             /* Calls library function */
    printf("Count: %d*n", count);
}</code></pre>
<h3 data-number="10.2.5" id="control-flow-1"><span class="header-section-number">10.2.5</span> Control Flow</h3>
<p>B supports standard control flow structures:</p>
<p><strong>If-Else:</strong></p>
<pre class="b"><code>if (x &gt; 0)
    printf("positive*n");
else if (x &lt; 0)
    printf("negative*n");
else
    printf("zero*n");</code></pre>
<p><strong>While Loop:</strong></p>
<pre class="b"><code>auto i;
i = 0;
while (i &lt; 10) {
    printf("%d*n", i);
    i++;
}</code></pre>
<p><strong>For Loop:</strong> (Not in PDP-7 B! Added later)</p>
<pre class="b"><code>/* PDP-7 B didn't have 'for' - used while instead */
auto i;
i = 0;
while (i &lt; 10) {
    printf("%d*n", i);
    i++;
}</code></pre>
<p><strong>Switch Statement:</strong> (Not in PDP-7 B! Added in later
versions)</p>
<pre class="b"><code>/* Had to use if-else chains */
if (c == 'a')
    printf("Letter a*n");
else if (c == 'b')
    printf("Letter b*n");
else if (c == 'c')
    printf("Letter c*n");
else
    printf("Other*n");</code></pre>
<p><strong>Goto and Labels:</strong></p>
<pre class="b"><code>    auto i;
    i = 0;
loop:
    printf("%d*n", i);
    i++;
    if (i &lt; 10)
        goto loop;</code></pre>
<h3 data-number="10.2.6" id="example-programs"><span class="header-section-number">10.2.6</span> Example Programs</h3>
<p>Let‚Äôs examine two real B programs from PDP-7 Unix (reconstructed from
historical documentation):</p>
<h4 data-number="10.2.6.1" id="lcase.b---lowercase-converter"><span class="header-section-number">10.2.6.1</span> <strong>lcase.b -
Lowercase Converter</strong></h4>
<pre class="b"><code>/*
 * lcase.b - Convert input to lowercase
 *
 * Reads characters from standard input,
 * converts uppercase to lowercase,
 * writes to standard output.
 */

extrn getchar, putchar;

main() {
    auto c;

    while ((c = getchar()) != '*e') {  /* *e = EOF marker */
        if (c &gt;= 'A' &amp; c &lt;= 'Z')
            c = c + ('a' - 'A');       /* Convert to lowercase */
        putchar(c);
    }
}</code></pre>
<p><strong>Line-by-Line Explanation:</strong></p>
<pre class="b"><code>extrn getchar, putchar;</code></pre>
<ul>
<li>Declares external functions from B runtime library</li>
<li><code>getchar()</code> reads one character from stdin</li>
<li><code>putchar(c)</code> writes character <code>c</code> to
stdout</li>
</ul>
<pre class="b"><code>main() {
    auto c;</code></pre>
<ul>
<li>Program entry point (like C)</li>
<li><code>auto c</code> declares local variable (automatic storage)</li>
<li>In B, all local variables are <code>auto</code></li>
</ul>
<pre class="b"><code>    while ((c = getchar()) != '*e') {</code></pre>
<ul>
<li>Read character into <code>c</code></li>
<li>Continue until EOF (represented as <code>*e</code>)</li>
<li><code>*e</code> is a special character constant meaning
end-of-file</li>
</ul>
<pre class="b"><code>        if (c &gt;= 'A' &amp; c &lt;= 'Z')</code></pre>
<ul>
<li>Check if <code>c</code> is uppercase letter</li>
<li>Note: <code>&amp;</code> is bitwise AND in B (not logical
<code>&amp;&amp;</code>)</li>
<li>This works because expression is non-zero if both conditions
true</li>
</ul>
<pre class="b"><code>            c = c + ('a' - 'A');</code></pre>
<ul>
<li>Convert uppercase to lowercase</li>
<li>ASCII: ‚ÄòA‚Äô=65, ‚Äòa‚Äô=97, difference is 32</li>
<li>Add 32 to convert uppercase to lowercase</li>
</ul>
<pre class="b"><code>        putchar(c);</code></pre>
<ul>
<li>Output the (possibly converted) character</li>
</ul>
<p><strong>How It Works:</strong></p>
<pre><code>Input:  "Hello World"
Output: "hello world"

Step by step:
'H' (72) -&gt; 'h' (104)  [72 + 32 = 104]
'e' (101) -&gt; 'e' (101) [no change]
'l' (108) -&gt; 'l' (108) [no change]
'l' (108) -&gt; 'l' (108) [no change]
'o' (111) -&gt; 'o' (111) [no change]
' ' (32)  -&gt; ' ' (32)  [no change]
'W' (87)  -&gt; 'w' (119) [87 + 32 = 119]
...</code></pre>
<h4 data-number="10.2.6.2" id="ind.b---indentation-tool"><span class="header-section-number">10.2.6.2</span> <strong>ind.b -
Indentation Tool</strong></h4>
<pre class="b"><code>/*
 * ind.b - Indent text by specified amount
 *
 * Usage: ind n
 * Reads from stdin, writes to stdout with n spaces of indent
 */

extrn getchar, putchar, printf;

main(argc, argv) {
    auto c, indent, i, bol;

    if (argc &lt; 2) {
        printf("Usage: ind n*n");
        return;
    }

    indent = atoi(argv[1]);    /* Get indent amount from argument */
    bol = 1;                   /* Beginning of line flag */

    while ((c = getchar()) != '*e') {
        if (bol) {
            i = 0;
            while (i &lt; indent) {
                putchar(' ');
                i++;
            }
            bol = 0;
        }

        putchar(c);

        if (c == '*n')
            bol = 1;           /* Next is beginning of line */
    }
}

/* Convert ASCII string to integer */
atoi(s) {
    auto n, c;
    n = 0;
    while ((c = *s++) &gt;= '0' &amp; c &lt;= '9')
        n = n * 10 + (c - '0');
    return (n);
}</code></pre>
<p><strong>Algorithm Explanation:</strong></p>
<pre class="b"><code>main(argc, argv) {</code></pre>
<ul>
<li><code>argc</code> = argument count</li>
<li><code>argv</code> = argument vector (array of strings)</li>
<li>Just like C‚Äôs <code>main()</code> arguments!</li>
</ul>
<pre class="b"><code>    if (argc &lt; 2) {
        printf("Usage: ind n*n");
        return;
    }</code></pre>
<ul>
<li>Check if user provided indent amount</li>
<li>If not, print usage and exit</li>
</ul>
<pre class="b"><code>    indent = atoi(argv[1]);
    bol = 1;                   /* Beginning of line flag */</code></pre>
<ul>
<li>Convert first argument to integer</li>
<li><code>bol</code> tracks whether we‚Äôre at start of line</li>
<li>Initially true (first character is at start of line)</li>
</ul>
<pre class="b"><code>    while ((c = getchar()) != '*e') {
        if (bol) {
            i = 0;
            while (i &lt; indent) {
                putchar(' ');
                i++;
            }
            bol = 0;
        }</code></pre>
<ul>
<li>For each character:
<ul>
<li>If at beginning of line, output <code>indent</code> spaces</li>
<li>Clear <code>bol</code> flag after outputting spaces</li>
</ul></li>
</ul>
<pre class="b"><code>        putchar(c);

        if (c == '*n')
            bol = 1;</code></pre>
<ul>
<li>Output the character</li>
<li>If it‚Äôs a newline, set <code>bol</code> for next line</li>
</ul>
<pre class="b"><code>atoi(s) {
    auto n, c;
    n = 0;
    while ((c = *s++) &gt;= '0' &amp; c &lt;= '9')
        n = n * 10 + (c - '0');
    return (n);
}</code></pre>
<ul>
<li>Convert string to integer</li>
<li><code>*s++</code> gets character and advances pointer</li>
<li>Multiply accumulator by 10, add digit value</li>
<li>Return final number</li>
</ul>
<p><strong>Usage Example:</strong></p>
<pre><code>$ cat file.txt
Line 1
Line 2
Line 3

$ ind 4 &lt; file.txt
    Line 1
    Line 2
    Line 3</code></pre>
<hr/>
<h2 data-number="10.3" id="the-b-interpreter-bi.s"><span class="header-section-number">10.3</span> 12.3 The B Interpreter
(bi.s)</h2>
<p>The B interpreter (<code>bi.s</code>) is the heart of the B language
system. It‚Äôs a <strong>stack-based virtual machine</strong> that
executes B programs compiled to bytecode.</p>
<h3 data-number="10.3.1" id="stack-based-execution"><span class="header-section-number">10.3.1</span> Stack-Based Execution</h3>
<p>Unlike modern compiled languages that use registers extensively, the
B interpreter uses a <strong>stack machine</strong> model:</p>
<p><strong>Stack Machine Concept:</strong></p>
<pre><code>Operations push and pop values from a stack:

Expression: (3 + 4) * 5

Bytecode sequence:
1. PUSH 3         Stack: [3]
2. PUSH 4         Stack: [3, 4]
3. ADD            Stack: [7]         (pop 3,4; push 7)
4. PUSH 5         Stack: [7, 5]
5. MUL            Stack: [35]        (pop 7,5; push 35)

Result: 35 on top of stack</code></pre>
<p><strong>Why Stack-Based?</strong></p>
<ol type="1">
<li><strong>Simple to implement</strong> - No register allocation</li>
<li><strong>Compact bytecode</strong> - Fewer addressing modes</li>
<li><strong>Easy to interpret</strong> - Linear execution</li>
<li><strong>Portable</strong> - Independent of CPU registers</li>
</ol>
<h3 data-number="10.3.2" id="virtual-machine-model"><span class="header-section-number">10.3.2</span> Virtual Machine Model</h3>
<p>The B interpreter implements a virtual PDP-7 with these key
registers:</p>
<p><strong>Virtual Registers:</strong></p>
<pre class="assembly"><code>" B Interpreter Virtual Machine Registers

PC:     Program Counter     - Points to current bytecode instruction
SP:     Stack Pointer       - Points to top of evaluation stack
AP:     Argument Pointer    - Points to function arguments
DP:     Display Pointer     - Points to current stack frame (for locals)</code></pre>
<p><strong>Memory Layout:</strong></p>
<pre><code>PDP-7 Memory (18-bit words):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê 0
‚îÇ  B Interpreter Code     ‚îÇ
‚îÇ  (bi.s assembled)       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ~2000
‚îÇ  B Bytecode Program     ‚îÇ
‚îÇ  (loaded at runtime)    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ~4000
‚îÇ  Evaluation Stack       ‚îÇ
‚îÇ  (grows upward)         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚Üë Stack grows up       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ SP
‚îÇ                         ‚îÇ
‚îÇ  Free space             ‚îÇ
‚îÇ                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ DP
‚îÇ  ‚Üì Frames grow down     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Call Stack Frames      ‚îÇ
‚îÇ  (local variables,      ‚îÇ
‚îÇ   return addresses)     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò 8191 (8K words)</code></pre>
<h3 data-number="10.3.3" id="instruction-format-18-bits"><span class="header-section-number">10.3.3</span> Instruction Format (18
bits)</h3>
<p>B bytecode instructions are 18-bit words matching PDP-7‚Äôs word
size:</p>
<p><strong>Instruction Format:</strong></p>
<pre><code>Bits 0-8:  Opcode (9 bits) - 512 possible operations
Bits 9-17: Operand (9 bits) - Immediate value or offset</code></pre>
<p><strong>Example Instructions:</strong></p>
<pre><code>Opcode    Operand   Meaning
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
CONST     42        Push constant 42 onto stack
LOAD      5         Load local variable [DP+5]
STORE     3         Store to local variable [DP+3]
ADD       0         Pop two values, push sum
SUB       0         Pop two values, push difference
CALL      addr      Call function at address
RET       0         Return from function
JUMP      addr      Unconditional jump
JUMPZ     addr      Jump if top of stack is zero</code></pre>
<h3 data-number="10.3.4" id="complete-implementation"><span class="header-section-number">10.3.4</span> Complete Implementation</h3>
<p>Let‚Äôs trace through a simple B function execution:</p>
<p><strong>B Source:</strong></p>
<pre class="b"><code>square(x) {
    return (x * x);
}

main() {
    auto result;
    result = square(5);
    printf("%d*n", result);
}</code></pre>
<p><strong>Compiled to Bytecode (Conceptual):</strong></p>
<pre><code>; square function at address 100
100:  LOAD   0        ; Load parameter x from [AP+0]
101:  DUP             ; Duplicate top of stack
102:  MUL             ; Multiply top two values
103:  RET             ; Return with result on stack

; main function at address 200
200:  CONST  5        ; Push 5 (argument to square)
201:  CALL   100      ; Call square function
202:  STORE  0        ; Store result to local[0] (result)
203:  LOAD   0        ; Load result back
204:  CONST  fmt      ; Push address of format string
205:  CALL   printf   ; Call printf
206:  RET             ; Return from main</code></pre>
<p><strong>Execution Trace:</strong></p>
<pre><code>PC=200: CONST 5
  Stack: [5]
  SP: 4000

PC=201: CALL 100
  Save return address (202)
  Save current DP
  Create new frame
  Set AP to point to arguments
  Jump to 100

PC=100: LOAD 0
  Load argument x (5) from [AP+0]
  Stack: [5]

PC=101: DUP
  Duplicate top
  Stack: [5, 5]

PC=102: MUL
  Pop two values: 5, 5
  Multiply: 5 * 5 = 25
  Push result: 25
  Stack: [25]

PC=103: RET
  Restore DP
  Return to address 202
  Result (25) stays on stack

PC=202: STORE 0
  Pop 25
  Store to local[0]
  Stack: []

PC=203: LOAD 0
  Load local[0] (25)
  Stack: [25]

PC=204: CONST fmt
  Push format string address
  Stack: [25, fmt_addr]

PC=205: CALL printf
  Call C library function
  Prints "25\n"

PC=206: RET
  Exit program</code></pre>
<hr/>
<h2 data-number="10.4" id="b-operations"><span class="header-section-number">10.4</span> 12.4 B Operations</h2>
<p>The B interpreter implements operations as bytecode instructions.
Let‚Äôs examine each category in detail.</p>
<h3 data-number="10.4.1" id="autop---auto-variables"><span class="header-section-number">10.4.1</span> autop - Auto Variables</h3>
<p>Auto variables are local variables allocated on the call stack
frame.</p>
<p><strong>B Source:</strong></p>
<pre class="b"><code>main() {
    auto x, y, z[10];
    x = 5;
    y = 10;
    z[0] = x + y;
}</code></pre>
<p><strong>Bytecode Operations:</strong></p>
<pre class="assembly"><code>; Function entry creates stack frame
; Space allocated for x, y, z[10] = 12 words total

; x = 5;
CONST 5          ; Push 5
STORE 0          ; Store to [DP+0] (x)

; y = 10;
CONST 10         ; Push 10
STORE 1          ; Store to [DP+1] (y)

; z[0] = x + y;
LOAD 0           ; Load x
LOAD 1           ; Load y
ADD              ; Add: x + y
CONST 2          ; Push 2 (base of z array)
CONST 0          ; Push 0 (index)
ADD              ; Calculate address: DP+2+0
STORE_INDIRECT   ; Store through address</code></pre>
<p><strong>Implementation Sketch:</strong></p>
<pre class="assembly"><code>" autop - Handle auto variable reference
autop:
   lac offset i        " Get variable offset
   tad dp              " Add to display pointer
   dac tos             " Push address on stack
   isz sp
   jmp i autop</code></pre>
<h3 data-number="10.4.2" id="binop---binary-operations"><span class="header-section-number">10.4.2</span> binop - Binary
Operations</h3>
<p>Binary operations pop two values, perform operation, push result.</p>
<p><strong>Supported Operators:</strong></p>
<pre><code>Arithmetic: +, -, *, /, %
Comparison: ==, !=, &lt;, &lt;=, &gt;, &gt;=
Bitwise:    &amp;, |, &lt;&lt;, &gt;&gt;
Assignment: =</code></pre>
<p><strong>Examples:</strong></p>
<p><strong>Addition:</strong></p>
<pre class="b"><code>result = a + b;

Bytecode:
LOAD a
LOAD b
ADD
STORE result</code></pre>
<p><strong>Bitwise OR:</strong></p>
<pre class="b"><code>flags = flags | 0400000;  /* Set bit 0 */

Bytecode:
LOAD flags
CONST 0400000
OR
STORE flags</code></pre>
<p><strong>Left Shift:</strong></p>
<pre class="b"><code>x = y &lt;&lt; 3;  /* Multiply by 8 */

Bytecode:
LOAD y
CONST 3
LSHIFT
STORE x</code></pre>
<p><strong>Comparison:</strong></p>
<pre class="b"><code>if (x == y)
    printf("Equal*n");

Bytecode:
LOAD x
LOAD y
EQUAL          ; Push 1 if equal, 0 otherwise
JUMPZ skip     ; Jump if zero (not equal)
CONST msg
CALL printf
skip:</code></pre>
<p><strong>Implementation Code (Conceptual):</strong></p>
<pre class="assembly"><code>" binop - Binary operation dispatcher
binop:
   lac opcode          " Get operation code
   sad o_add
   jmp do_add
   sad o_sub
   jmp do_sub
   sad o_mul
   jmp do_mul
   " ... more operators

do_add:
   -1
   tad sp
   dac sp              " Pop SP
   lac i sp            " Get right operand
   dac temp
   -1
   tad sp
   dac sp              " Pop SP
   lac i sp            " Get left operand
   add temp            " Add
   dac i sp            " Store result
   isz sp              " Push result
   jmp i binop

do_equal:
   " Pop two values
   -1
   tad sp
   dac sp
   lac i sp
   dac right
   -1
   tad sp
   dac sp
   lac i sp
   dac left
   " Compare
   lac left
   sad right           " Skip if A Different from right
   jmp equal
   cla                 " Not equal: push 0
   jmp push_result
equal:
   lac d1              " Equal: push 1
push_result:
   dac i sp
   isz sp
   jmp i binop</code></pre>
<h3 data-number="10.4.3" id="consop---constants"><span class="header-section-number">10.4.3</span> consop - Constants</h3>
<p>Constants are loaded onto the stack.</p>
<p><strong>B Source:</strong></p>
<pre class="b"><code>x = 42;
y = 'A';
z = "Hello";</code></pre>
<p><strong>Bytecode:</strong></p>
<pre><code>; x = 42;
CONST 42
STORE x

; y = 'A';
CONST 0101        ; 'A' = octal 101
STORE y

; z = "Hello";
CONST str_addr    ; Address of string constant
STORE z</code></pre>
<p><strong>String Constants:</strong></p>
<p>Strings are stored in a separate data area and referenced by
address:</p>
<pre><code>Data area:
str_addr:  &lt;He&gt;;&lt;ll&gt;;&lt;o*000    ; "Hello" in packed form
                                ; Two 9-bit chars per word</code></pre>
<p><strong>Implementation:</strong></p>
<pre class="assembly"><code>" consop - Push constant onto stack
consop:
   lac const i         " Get constant value
   isz pc              " Increment PC past constant
   dac i sp            " Push onto stack
   isz sp
   jmp i consop</code></pre>
<h3 data-number="10.4.4" id="ifop---conditionals"><span class="header-section-number">10.4.4</span> ifop - Conditionals</h3>
<p>Conditional jumps based on stack top value.</p>
<p><strong>B Source:</strong></p>
<pre class="b"><code>if (x &gt; 0)
    y = 1;
else
    y = -1;</code></pre>
<p><strong>Bytecode:</strong></p>
<pre><code>    LOAD x
    CONST 0
    GREATER        ; Push 1 if x &gt; 0, else 0
    JUMPZ else_label

    CONST 1
    STORE y
    JUMP end_if

else_label:
    CONST -1
    STORE y

end_if:
    ; continue...</code></pre>
<p><strong>Short-Circuit Evaluation:</strong></p>
<pre class="b"><code>if (ptr != 0 &amp; *ptr == 'A') {
    /* ... */
}</code></pre>
<p>Naive compilation would crash if <code>ptr == 0</code>, but B uses
short-circuit:</p>
<pre><code>    LOAD ptr
    CONST 0
    NOTEQUAL
    JUMPZ end_if      ; Skip rest if ptr == 0

    LOAD ptr
    LOAD_INDIRECT
    CONST 0101        ; 'A'
    EQUAL
    JUMPZ end_if

    ; then clause
end_if:</code></pre>
<p><strong>Implementation:</strong></p>
<pre class="assembly"><code>" ifop - Conditional jump
ifop:
   -1
   tad sp
   dac sp              " Pop value
   lac i sp
   sza                 " Skip if zero
   jmp i ifop          " Non-zero: continue (don't jump)
   lac pc i            " Zero: load jump target
   dac pc              " Set PC to target
   jmp i ifop</code></pre>
<h3 data-number="10.4.5" id="traop---transfers-goto-function-calls"><span class="header-section-number">10.4.5</span> traop - Transfers (goto,
function calls)</h3>
<p>Transfer operations change the program counter.</p>
<p><strong>Unconditional Jump (goto):</strong></p>
<pre class="b"><code>loop:
    printf("Loop*n");
    goto loop;</code></pre>
<p><strong>Bytecode:</strong></p>
<pre><code>loop:
    CONST msg
    CALL printf
    JUMP loop</code></pre>
<p><strong>Function Call:</strong></p>
<pre class="b"><code>result = add(3, 4);</code></pre>
<p><strong>Bytecode:</strong></p>
<pre><code>    CONST 3          ; Push first argument
    CONST 4          ; Push second argument
    CALL add         ; Call function
    STORE result     ; Store return value</code></pre>
<p><strong>Call Implementation:</strong></p>
<pre class="assembly"><code>" call_op - Function call
call_op:
   " Save current frame
   lac dp
   dac i sp
   isz sp

   " Save return address
   lac pc
   dac i sp
   isz sp

   " Create new frame
   lac sp
   dac dp

   " Jump to function
   lac target i
   dac pc
   jmp i call_op</code></pre>
<p><strong>Return Implementation:</strong></p>
<pre class="assembly"><code>" ret_op - Return from function
ret_op:
   " Return value is on stack top
   lac i sp
   dac retval         " Save return value

   " Restore frame
   -1
   tad dp
   dac sp

   " Pop return address
   -1
   tad sp
   dac sp
   lac i sp
   dac pc

   " Pop saved DP
   -1
   tad sp
   dac sp
   lac i sp
   dac dp

   " Push return value
   lac retval
   dac i sp
   isz sp

   jmp i ret_op</code></pre>
<h3 data-number="10.4.6" id="unaop---unary-operations"><span class="header-section-number">10.4.6</span> unaop - Unary
Operations</h3>
<p>Unary operations operate on single values.</p>
<p><strong>Supported Operators:</strong></p>
<pre><code>&amp;     Address-of
-     Negation
*     Indirection (dereference)
!     Logical NOT
~     Bitwise NOT (not in PDP-7 B)
++    Increment (postfix and prefix)
--    Decrement (postfix and prefix)</code></pre>
<p><strong>Address-of (<code>&amp;</code>):</strong></p>
<pre class="b"><code>x = 10;
ptr = &amp;x;    /* ptr points to x */</code></pre>
<p><strong>Bytecode:</strong></p>
<pre><code>CONST 10
STORE x

ADDR x       ; Push address of x
STORE ptr</code></pre>
<p><strong>Negation (<code>-</code>):</strong></p>
<pre class="b"><code>x = -y;</code></pre>
<p><strong>Bytecode:</strong></p>
<pre><code>LOAD y
NEGATE
STORE x</code></pre>
<p><strong>Indirection (<code>*</code>):</strong></p>
<pre class="b"><code>ptr = &amp;x;
y = *ptr;    /* Load value through pointer */</code></pre>
<p><strong>Bytecode:</strong></p>
<pre><code>LOAD ptr
DEREF        ; Load word at address in ptr
STORE y</code></pre>
<p><strong>Logical NOT (<code>!</code>):</strong></p>
<pre class="b"><code>if (!flag)
    printf("Flag is zero*n");</code></pre>
<p><strong>Bytecode:</strong></p>
<pre><code>LOAD flag
NOT          ; Push 1 if zero, 0 otherwise
JUMPZ skip
CONST msg
CALL printf
skip:</code></pre>
<p><strong>Increment (<code>++</code>):</strong></p>
<pre class="b"><code>x++;         /* Post-increment */
++x;         /* Pre-increment */</code></pre>
<p><strong>Post-increment bytecode:</strong></p>
<pre><code>LOAD x       ; Load current value
DUP          ; Duplicate it
CONST 1
ADD          ; Add 1
STORE x      ; Store back
             ; Original value remains on stack</code></pre>
<p><strong>Pre-increment bytecode:</strong></p>
<pre><code>LOAD x
CONST 1
ADD          ; Add 1
DUP          ; Duplicate result
STORE x      ; Store back
             ; New value remains on stack</code></pre>
<p><strong>Implementation Example (Negation):</strong></p>
<pre class="assembly"><code>" neg_op - Negate top of stack
neg_op:
   -1
   tad sp
   dac sp              " Pop value
   lac i sp
   cma                 " Complement
   tad d1              " Add 1 (two's complement)
   dac i sp            " Store back
   isz sp              " Push result
   jmp i neg_op</code></pre>
<h3 data-number="10.4.7" id="extop---external-references"><span class="header-section-number">10.4.7</span> extop - External
References</h3>
<p>External references resolve names to addresses at load time.</p>
<p><strong>B Source:</strong></p>
<pre class="b"><code>extrn printf, getchar, putchar;
extrn buffer, count;

main() {
    printf("Count = %d*n", count);
}</code></pre>
<p><strong>Symbol Resolution:</strong></p>
<pre><code>1. Compiler creates external reference table:
   Name       Type         Index
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   printf     function     0
   getchar    function     1
   putchar    function     2
   buffer     variable     3
   count      variable     4

2. Loader resolves at load time:
   printf  -&gt; address 5000 (in runtime library)
   getchar -&gt; address 5010
   putchar -&gt; address 5020
   buffer  -&gt; address 6000
   count   -&gt; address 6004

3. Bytecode uses resolved addresses:
   CONST 6004    ; Address of 'count'
   DEREF         ; Load value
   CONST fmt
   CALL 5000     ; Call printf</code></pre>
<p><strong>Implementation:</strong></p>
<pre class="assembly"><code>" extop - External reference resolution
" At load time, external symbols are patched
extop:
   lac symtab i        " Get symbol index
   tad extbase         " Add external base
   dac i sp            " Push resolved address
   isz sp
   jmp i extop</code></pre>
<h3 data-number="10.4.8" id="aryop---arrays"><span class="header-section-number">10.4.8</span> aryop - Arrays</h3>
<p>Arrays are contiguous blocks of words accessed by index.</p>
<p><strong>B Source:</strong></p>
<pre class="b"><code>auto array[10];
array[5] = 42;
x = array[5];</code></pre>
<p><strong>Array Indexing Calculation:</strong></p>
<pre><code>Address = base + index

For array[5]:
  base  = address of array (DP + offset)
  index = 5
  address = base + 5</code></pre>
<p><strong>Bytecode:</strong></p>
<pre><code>; array[5] = 42;
CONST 42           ; Value to store
ADDR array         ; Base address
CONST 5            ; Index
ADD                ; Calculate address
STORE_INDIRECT     ; Store through address

; x = array[5];
ADDR array         ; Base address
CONST 5            ; Index
ADD                ; Calculate address
LOAD_INDIRECT      ; Load through address
STORE x</code></pre>
<p><strong>Multi-dimensional Arrays:</strong></p>
<p>B doesn‚Äôt have true multi-dimensional arrays, but simulates them:</p>
<pre class="b"><code>auto matrix[10][10];    /* Actually: matrix[100] */

matrix[row][col] = value;

/* Compiled as: */
matrix[row * 10 + col] = value;</code></pre>
<p><strong>Implementation:</strong></p>
<pre class="assembly"><code>" aryop - Array indexing
aryop:
   " Stack contains: [base, index]
   -1
   tad sp
   dac sp              " Pop index
   lac i sp
   dac index

   -1
   tad sp
   dac sp              " Pop base
   lac i sp
   dac base

   lac base
   add index           " Calculate address
   dac i sp            " Push result
   isz sp
   jmp i aryop</code></pre>
<p><strong>Pointer Arithmetic:</strong></p>
<p>B uses word-based addressing, so pointer arithmetic is simple:</p>
<pre class="b"><code>auto array[10], *ptr;
ptr = array;           /* ptr points to array[0] */
ptr++;                 /* ptr now points to array[1] */
*ptr = 42;             /* array[1] = 42 */</code></pre>
<p><strong>Bytecode:</strong></p>
<pre><code>; ptr = array;
ADDR array
STORE ptr

; ptr++;
LOAD ptr
CONST 1
ADD
STORE ptr

; *ptr = 42;
CONST 42
LOAD ptr
STORE_INDIRECT</code></pre>
<hr/>
<h2 data-number="10.5" id="b-runtime-support-bc.s"><span class="header-section-number">10.5</span> 12.5 B Runtime Support
(bc.s)</h2>
<p>The <code>bc.s</code> file provides runtime support for the B
interpreter, including debugging features, display buffer management,
and performance monitoring.</p>
<h3 data-number="10.5.1" id="instruction-tracing"><span class="header-section-number">10.5.1</span> Instruction Tracing</h3>
<p>For debugging B programs, the interpreter can trace each instruction
as it executes:</p>
<p><strong>Trace Output Example:</strong></p>
<pre><code>PC=0100  SP=4025  DP=7500  OP=CONST   [42]
PC=0101  SP=4026  DP=7500  OP=STORE   [0]
PC=0102  SP=4025  DP=7500  OP=LOAD    [0]
PC=0103  SP=4026  DP=7500  OP=DUP     []
PC=0104  SP=4027  DP=7500  OP=MUL     []
PC=0105  SP=4026  DP=7500  OP=RET     []</code></pre>
<p><strong>Implementation:</strong></p>
<pre class="assembly"><code>" trace - Print instruction trace
trace: 0
   lac trace_flag      " Check if tracing enabled
   sza
   jmp i trace         " Not enabled, return

   " Print PC
   lac o120            " 'P'
   jms putchar
   lac o103            " 'C'
   jms putchar
   lac o75             " '='
   jms putchar
   lac pc
   jms octal_print

   " Print SP
   lac o123            " 'S'
   jms putchar
   lac o120            " 'P'
   jms putchar
   lac o75             " '='
   jms putchar
   lac sp
   jms octal_print

   " Print instruction
   lac pc i
   jms decode_instr

   jmp i trace</code></pre>
<h3 data-number="10.5.2" id="display-buffer-management"><span class="header-section-number">10.5.2</span> Display Buffer
Management</h3>
<p>The B interpreter uses a display buffer for managing nested function
calls and local variable access:</p>
<p><strong>Display Concept:</strong></p>
<pre><code>Display is an array of frame pointers for each nesting level:

display[0] = Frame for global scope
display[1] = Frame for outermost function
display[2] = Frame for nested function 1
display[3] = Frame for nested function 2
...</code></pre>
<p><strong>Example:</strong></p>
<pre class="b"><code>global_var;

outer() {
    auto outer_var;

    inner() {
        auto inner_var;
        inner_var = outer_var + global_var;
    }

    inner();
}</code></pre>
<p><strong>Display at different points:</strong></p>
<pre><code>In outer():
  display[0] -&gt; global scope frame
  display[1] -&gt; outer's frame (contains outer_var)

In inner():
  display[0] -&gt; global scope frame
  display[1] -&gt; outer's frame (contains outer_var)
  display[2] -&gt; inner's frame (contains inner_var)</code></pre>
<p><strong>Implementation:</strong></p>
<pre class="assembly"><code>" setup_display - Create new display entry for function call
setup_display: 0
   lac level           " Get nesting level
   tad display_base    " Add to display array base
   dac 8               " Use as pointer

   lac dp              " Get current frame pointer
   dac i 8             " Store in display[level]

   isz level           " Increment nesting level

   jmp i setup_display

" access_nonlocal - Access variable from outer scope
access_nonlocal: 0
   lac level           " Variable's level
   tad display_base
   dac 8

   lac i 8             " Get frame pointer for that level
   add offset          " Add variable offset
   dac address         " Result: address of variable

   jmp i access_nonlocal</code></pre>
<h3 data-number="10.5.3" id="histogram-collection"><span class="header-section-number">10.5.3</span> Histogram Collection</h3>
<p>The runtime can collect execution statistics for performance
analysis:</p>
<p><strong>Histogram Data:</strong></p>
<pre><code>Instruction    Count       Percentage
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
LOAD           15234       25.3%
STORE           8542       14.2%
CONST           9876       16.4%
ADD             4521        7.5%
CALL            2341        3.9%
RET             2341        3.9%
JUMP            1234        2.1%
...
Total:         60234      100.0%</code></pre>
<p><strong>Implementation:</strong></p>
<pre class="assembly"><code>" histogram - Update instruction histogram
histogram: 0
   lac hist_flag       " Check if enabled
   sza
   jmp i histogram

   lac pc i            " Get current instruction
   and o777            " Mask to opcode (9 bits)
   dac opcode

   tad hist_base       " Calculate histogram entry
   dac 8

   lac i 8             " Load current count
   tad d1              " Increment
   dac i 8             " Store back

   jmp i histogram

" print_histogram - Display statistics
print_histogram: 0
   law -512            " 512 possible opcodes
   dac count
   law hist_base
   dac 8
   dzm total

1:
   lac i 8             " Get count for this opcode
   sna                 " Skip if non-zero
   jmp 2f

   add total           " Add to total
   dac total

   lac count           " Print opcode number
   cma
   tad d512
   jms octal_print

   lac o40             " Space
   jms putchar

   lac i 8             " Print count
   jms decimal_print

   lac o12             " Newline
   jms putchar

2:
   isz count
   jmp 1b

   " Print total
   lac total
   jms decimal_print

   jmp i print_histogram</code></pre>
<h3 data-number="10.5.4" id="octal-output"><span class="header-section-number">10.5.4</span> Octal Output</h3>
<p>Helper functions for printing values in octal (base 8):</p>
<p><strong>Implementation:</strong></p>
<pre class="assembly"><code>" octal_print - Print word in octal
octal_print: 0
   dac value           " Save value
   dzm digits          " Clear digit count

   " Extract 6 octal digits (18 bits = 6 octal digits)
   law -6
   dac count

1:
   lac value
   and o7              " Get low 3 bits
   tad o60             " Convert to ASCII '0'-'7'
   dac digit_buf i
   isz digits

   lac value
   lrss 3              " Right shift 3 bits
   dac value

   isz count
   jmp 1b

   " Print digits in reverse order
   lac digits
   cma
   tad d1
   dac count

2:
   lac digit_buf i
   jms putchar

   isz count
   jmp 2b

   jmp i octal_print

value: .=.+1
digits: .=.+1
count: .=.+1
digit_buf: .=.+6</code></pre>
<h3 data-number="10.5.5" id="stack-validation"><span class="header-section-number">10.5.5</span> Stack Validation</h3>
<p>Runtime checks to prevent stack overflow/underflow:</p>
<p><strong>Implementation:</strong></p>
<pre class="assembly"><code>" check_stack - Validate stack pointer
check_stack: 0
   lac sp              " Get stack pointer

   " Check underflow (SP &lt; stack_base)
   cma
   tad stack_base
   spa                 " Skip if positive (OK)
   jmp stack_underflow

   " Check overflow (SP &gt;= stack_limit)
   lac sp
   cma
   tad stack_limit
   sma                 " Skip if negative (OK)
   jmp stack_overflow

   " Check collision with display
   lac sp
   cma
   tad dp
   tad d-100           " Need 100 word safety margin
   spa
   jmp stack_collision

   jmp i check_stack

stack_underflow:
   lac o165            " 'u'
   jms putchar
   jms print_error
   sys exit

stack_overflow:
   lac o157            " 'o'
   jms putchar
   jms print_error
   sys exit

stack_collision:
   lac o143            " 'c'
   jms putchar
   jms print_error
   sys exit

print_error:
   " Print stack error message
   lac d1
   sys write; err_msg; err_len
   sys exit

err_msg: &lt;St&gt;;&lt;ac&gt;;&lt;k 040&gt;;&lt;er&gt;;&lt;ro&gt;;&lt;r 012
err_len: 6</code></pre>
<hr/>
<h2 data-number="10.6" id="b-library-bl.s"><span class="header-section-number">10.6</span> 12.6 B Library (bl.s)</h2>
<p>The B library (<code>bl.s</code>) provides essential runtime
functions for I/O and memory management.</p>
<h3 data-number="10.6.1" id="array---array-allocation"><span class="header-section-number">10.6.1</span> .array - Array
Allocation</h3>
<p>Dynamic array allocation (early form of <code>malloc</code>):</p>
<p><strong>B Usage:</strong></p>
<pre class="b"><code>extrn array;

main() {
    auto buffer;
    buffer = array(100);    /* Allocate 100 words */
    buffer[50] = 42;
    /* No free() in PDP-7 B - memory not reclaimed */
}</code></pre>
<p><strong>Implementation:</strong></p>
<pre class="assembly"><code>" .array - Allocate array
.array: 0
   -1
   tad .array
   dac 8               " Save return address

   lac 8 i             " Get size argument
   isz 8               " Increment past argument
   dac size            " Save size

   lac heap_ptr        " Get current heap pointer
   dac result          " This is the allocated address

   add size            " Advance heap pointer
   dac heap_ptr

   " Check if exceeded memory
   cma
   tad mem_limit
   sma
   jmp mem_error

   lac result          " Return allocated address
   jmp i 8             " Return

size: .=.+1
result: .=.+1
heap_ptr: 6000          " Heap starts at 6000 (example)
mem_limit: 7777         " Memory limit</code></pre>
<h3 data-number="10.6.2" id="read---character-input"><span class="header-section-number">10.6.2</span> .read - Character Input</h3>
<p>Buffered character input from file descriptor:</p>
<p><strong>B Usage:</strong></p>
<pre class="b"><code>extrn read;

main() {
    auto c;
    c = read(0);        /* Read from stdin (fd 0) */
    if (c == '*e')      /* EOF check */
        return;
}</code></pre>
<p><strong>Implementation:</strong></p>
<pre class="assembly"><code>" .read - Read character with buffering
.read: 0
   -1
   tad .read
   dac 8               " Save return address

   lac 8 i             " Get file descriptor argument
   isz 8
   dac fd

   " Check if buffer has characters
   lac buf_count
   sna
   jmp fill_buffer     " Empty, fill it

   " Get character from buffer
   lac buf_ptr
   dac 9
   lac i 9             " Get character
   and o177            " Mask to 7 bits
   dac char

   " Advance buffer pointer
   lac buf_ptr
   tad d1
   dac buf_ptr

   " Decrement count
   -1
   tad buf_count
   dac buf_count

   lac char
   jmp i 8             " Return character

fill_buffer:
   lac fd
   sys read; read_buf; 64    " Read 64 words
   spa                       " Success?
   jmp read_error
   sna                       " Anything read?
   jmp return_eof

   dac buf_count             " Save count
   law read_buf
   dac buf_ptr               " Reset pointer

   jmp .read+1               " Try again

return_eof:
   lac eof_char              " Return EOF marker
   jmp i 8

read_error:
   lac o-1                   " Return -1 on error
   jmp i 8

fd: .=.+1
char: .=.+1
buf_count: 0
buf_ptr: read_buf
read_buf: .=.+64
eof_char: 004                 " EOF = ^D</code></pre>
<h3 data-number="10.6.3" id="write---word-output"><span class="header-section-number">10.6.3</span> .write - Word Output</h3>
<p>Buffered word output to file descriptor:</p>
<p><strong>B Usage:</strong></p>
<pre class="b"><code>extrn write;

main() {
    write(1, 'H');      /* Write to stdout (fd 1) */
    write(1, 'i');
    write(1, '*n');
}</code></pre>
<p><strong>Implementation:</strong></p>
<pre class="assembly"><code>" .write - Write character with buffering
.write: 0
   -1
   tad .write
   dac 8               " Save return address

   lac 8 i             " Get file descriptor
   isz 8
   dac fd

   lac 8 i             " Get character
   isz 8
   dac char

   " Add to buffer
   lac write_ptr
   dac 9
   lac char
   dac i 9

   " Advance pointer
   lac write_ptr
   tad d1
   dac write_ptr

   " Increment count
   lac write_count
   tad d1
   dac write_count

   " Check if buffer full
   sad d64             " 64 words?
   jmp flush_buffer

   lac char            " Return character
   jmp i 8

flush_buffer:
   lac fd
   sys write; write_buf; 64

   " Reset buffer
   dzm write_count
   law write_buf
   dac write_ptr

   lac char
   jmp i 8             " Return

fd: .=.+1
char: .=.+1
write_count: 0
write_ptr: write_buf
write_buf: .=.+64</code></pre>
<h3 data-number="10.6.4" id="flush---buffer-flush"><span class="header-section-number">10.6.4</span> .flush - Buffer Flush</h3>
<p>Explicit buffer flush (important at program exit):</p>
<p><strong>B Usage:</strong></p>
<pre class="b"><code>extrn flush;

main() {
    printf("Hello");
    flush(1);           /* Ensure output appears */
}</code></pre>
<p><strong>Implementation:</strong></p>
<pre class="assembly"><code>" .flush - Flush output buffer
.flush: 0
   -1
   tad .flush
   dac 8

   lac 8 i             " Get file descriptor
   isz 8
   dac fd

   " Check if anything to flush
   lac write_count
   sza
   jmp do_flush
   jmp i 8             " Nothing to flush

do_flush:
   dac count           " Save count
   lac fd
   sys write; write_buf; count: 0

   " Reset buffer
   dzm write_count
   law write_buf
   dac write_ptr

   jmp i 8

fd: .=.+1</code></pre>
<h3 data-number="10.6.5" id="buffered-io-implementation"><span class="header-section-number">10.6.5</span> Buffered I/O
Implementation</h3>
<p>The buffering strategy is crucial for performance on PDP-7:</p>
<p><strong>Why Buffering?</strong></p>
<p><strong>Without Buffering:</strong></p>
<pre><code>printf("Hello World\n");

System calls:
write(1, 'H', 1)     - syscall overhead
write(1, 'e', 1)     - syscall overhead
write(1, 'l', 1)     - syscall overhead
...
Total: 12 system calls for 12 characters</code></pre>
<p><strong>With Buffering:</strong></p>
<pre><code>printf("Hello World\n");

Internal: Add each character to 64-word buffer
When buffer full or flush called:
write(1, buffer, 64)  - ONE syscall

Total: 1 system call for up to 64 characters</code></pre>
<p><strong>Performance Impact:</strong></p>
<pre><code>System call overhead: ~100 PDP-7 instructions
Without buffering: 12 chars √ó 100 = 1200 instructions
With buffering: 1 √ó 100 = 100 instructions
Speedup: 12x</code></pre>
<p><strong>Buffer Management State:</strong></p>
<pre class="assembly"><code>" Global buffer state
read_buf: .=.+64        " Input buffer (64 words)
write_buf: .=.+64       " Output buffer (64 words)

read_ptr: read_buf      " Current read position
write_ptr: write_buf    " Current write position

read_count: 0           " Characters available in read buffer
write_count: 0          " Characters in write buffer

read_fd: 0              " File descriptor for read buffer
write_fd: 1             " File descriptor for write buffer</code></pre>
<hr/>
<h2 data-number="10.7" id="example-programs-1"><span class="header-section-number">10.7</span> 12.7 Example Programs</h2>
<p>Let‚Äôs analyze two complete B programs in detail.</p>
<h3 data-number="10.7.1" id="lcase.b---lowercase-converter-1"><span class="header-section-number">10.7.1</span> lcase.b - Lowercase
Converter</h3>
<p><strong>Complete Source:</strong></p>
<pre class="b"><code>/*
 * lcase.b - Convert uppercase to lowercase
 *
 * Usage: lcase &lt; input &gt; output
 * Reads from stdin, converts A-Z to a-z, writes to stdout
 */

extrn getchar, putchar, flush;

main() {
    auto c;

    /* Read until EOF */
    while ((c = getchar()) != '*e') {
        /* Check if uppercase letter */
        if (c &gt;= 'A') {
            if (c &lt;= 'Z') {
                /* Convert to lowercase */
                c = c + ('a' - 'A');
            }
        }
        putchar(c);
    }

    /* Flush output buffer */
    flush(1);
}</code></pre>
<p><strong>Line-by-Line Explanation:</strong></p>
<pre class="b"><code>extrn getchar, putchar, flush;</code></pre>
<ul>
<li>Declare external functions from B runtime library</li>
<li><code>getchar()</code> - Read one character from stdin</li>
<li><code>putchar(c)</code> - Write character to stdout</li>
<li><code>flush(fd)</code> - Flush output buffer for file
descriptor</li>
</ul>
<pre class="b"><code>main() {
    auto c;</code></pre>
<ul>
<li>Program entry point</li>
<li><code>c</code> is an automatic (local) variable to hold each
character</li>
<li>On PDP-7, <code>c</code> is allocated on the stack frame</li>
</ul>
<pre class="b"><code>    while ((c = getchar()) != '*e') {</code></pre>
<ul>
<li>Read character into <code>c</code></li>
<li>Continue looping while not EOF</li>
<li><code>'*e'</code> is EOF marker (Control-D, ASCII 004)</li>
<li>Assignment returns the assigned value, so we can test it
immediately</li>
</ul>
<pre class="b"><code>        if (c &gt;= 'A') {
            if (c &lt;= 'Z') {
                c = c + ('a' - 'A');
            }
        }</code></pre>
<ul>
<li>Check if <code>c</code> is in range ‚ÄòA‚Äô to ‚ÄòZ‚Äô</li>
<li>Nested <code>if</code> because B doesn‚Äôt have
<code>&amp;&amp;</code> operator (uses <code>&amp;</code> for bitwise
AND)</li>
<li>ASCII: ‚ÄòA‚Äô = 65, ‚ÄòZ‚Äô = 90, ‚Äòa‚Äô = 97</li>
<li>Difference: ‚Äòa‚Äô - ‚ÄòA‚Äô = 32</li>
<li>Adding 32 to uppercase gives lowercase</li>
</ul>
<pre class="b"><code>        putchar(c);</code></pre>
<ul>
<li>Output the (possibly converted) character</li>
<li>Goes to buffered output in <code>bl.s</code></li>
</ul>
<pre class="b"><code>    flush(1);</code></pre>
<ul>
<li>Flush stdout buffer (file descriptor 1)</li>
<li>Ensures all output appears before program exits</li>
<li>Important because B‚Äôs buffering might hold last few characters</li>
</ul>
<p><strong>How It Works - Execution Trace:</strong></p>
<pre><code>Input:  "Hello World\n"

Step 1: c = getchar() -&gt; 'H' (072 octal, 72 decimal)
  c &gt;= 'A' (65)?  Yes (72 &gt;= 65)
  c &lt;= 'Z' (90)?  Yes (72 &lt;= 90)
  c = 72 + 32 = 104 ('h')
  putchar(104)
  Output: "h"

Step 2: c = getchar() -&gt; 'e' (145 octal, 101 decimal)
  c &gt;= 'A' (65)?  Yes (101 &gt;= 65)
  c &lt;= 'Z' (90)?  No (101 &gt; 90)
  No conversion
  putchar(101)
  Output: "he"

Step 3: c = getchar() -&gt; 'l' (154 octal, 108 decimal)
  c &gt;= 'A' (65)?  Yes
  c &lt;= 'Z' (90)?  No
  No conversion
  putchar(108)
  Output: "hel"

...continue for all characters...

Final output: "hello world\n"</code></pre>
<p><strong>Bytecode (Conceptual):</strong></p>
<pre><code>main:
    ; while ((c = getchar()) != '*e')
loop:
    CALL getchar        ; Call getchar()
    DUP                 ; Duplicate result
    STORE c             ; Store in c
    CONST 004           ; EOF character
    NOTEQUAL            ; Compare
    JUMPZ end_loop      ; Exit if EOF

    ; if (c &gt;= 'A')
    LOAD c
    CONST 0101          ; 'A' in octal
    GREATER_EQUAL
    JUMPZ output        ; Skip conversion if &lt; 'A'

    ; if (c &lt;= 'Z')
    LOAD c
    CONST 0132          ; 'Z' in octal
    LESS_EQUAL
    JUMPZ output        ; Skip conversion if &gt; 'Z'

    ; c = c + ('a' - 'A')
    LOAD c
    CONST 040           ; 32 decimal = 040 octal
    ADD
    STORE c

output:
    LOAD c
    CALL putchar
    JUMP loop

end_loop:
    CONST 1             ; stdout fd
    CALL flush
    RET</code></pre>
<h3 data-number="10.7.2" id="ind.b---indentation-tool-1"><span class="header-section-number">10.7.2</span> ind.b - Indentation
Tool</h3>
<p><strong>Complete Source:</strong></p>
<pre class="b"><code>/*
 * ind.b - Indent text by specified amount
 *
 * Usage: ind &lt;n&gt;
 * Reads from stdin, writes to stdout with n spaces of indentation
 */

extrn getchar, putchar, printf, flush;

main(argc, argv) {
    auto c, indent, i, bol;

    /* Check arguments */
    if (argc &lt; 2) {
        printf("Usage: ind &lt;n&gt;*n");
        return (1);
    }

    /* Get indent amount */
    indent = atoi(argv[1]);

    /* Start at beginning of line */
    bol = 1;

    /* Process input */
    while ((c = getchar()) != '*e') {
        /* If at beginning of line, output indent */
        if (bol) {
            i = 0;
            while (i &lt; indent) {
                putchar(' ');
                i = i + 1;
            }
            bol = 0;
        }

        /* Output character */
        putchar(c);

        /* If newline, next will be beginning of line */
        if (c == '*n')
            bol = 1;
    }

    flush(1);
    return (0);
}

/*
 * atoi - Convert ASCII string to integer
 */
atoi(s) {
    auto n, c;

    n = 0;
    while ((c = *s++) &gt;= '0') {
        if (c &gt; '9')
            break;
        n = n * 10 + (c - '0');
    }
    return (n);
}</code></pre>
<p><strong>Algorithm Explanation:</strong></p>
<p><strong>Main Loop:</strong></p>
<pre class="b"><code>bol = 1;                    /* Beginning Of Line flag */

while ((c = getchar()) != '*e') {</code></pre>
<ul>
<li>Initialize <code>bol</code> to true (we‚Äôre at start of first
line)</li>
<li>Read characters until EOF</li>
</ul>
<p><strong>Indentation Logic:</strong></p>
<pre class="b"><code>    if (bol) {
        i = 0;
        while (i &lt; indent) {
            putchar(' ');
            i = i + 1;
        }
        bol = 0;
    }</code></pre>
<ul>
<li>If at beginning of line, output <code>indent</code> spaces</li>
<li>After outputting spaces, clear <code>bol</code> flag</li>
<li>Subsequent characters on this line won‚Äôt get indented</li>
</ul>
<p><strong>Output and State Update:</strong></p>
<pre class="b"><code>    putchar(c);

    if (c == '*n')
        bol = 1;</code></pre>
<ul>
<li>Output the character</li>
<li>If it‚Äôs a newline, set <code>bol</code> for next line</li>
</ul>
<p><strong>String to Integer Conversion:</strong></p>
<pre class="b"><code>atoi(s) {
    auto n, c;

    n = 0;
    while ((c = *s++) &gt;= '0') {
        if (c &gt; '9')
            break;
        n = n * 10 + (c - '0');
    }
    return (n);
}</code></pre>
<ul>
<li>Start with <code>n = 0</code></li>
<li><code>*s++</code> gets character and advances pointer</li>
<li>Check if digit (‚Äò0‚Äô to ‚Äò9‚Äô)</li>
<li>Multiply running total by 10, add digit value</li>
<li><code>c - '0'</code> converts ASCII digit to numeric value</li>
</ul>
<p><strong>Usage Example:</strong></p>
<pre><code>$ cat input.txt
This is line 1
This is line 2
This is line 3

$ ind 4 &lt; input.txt
    This is line 1
    This is line 2
    This is line 3

$ ind 8 &lt; input.txt
        This is line 1
        This is line 2
        This is line 3</code></pre>
<p><strong>Execution Trace for <code>ind 4</code>:</strong></p>
<pre><code>Input: "Hi\nBye\n"

State: bol=1, indent=4

Step 1: c = 'H'
  bol == 1? Yes
  Output 4 spaces: "    "
  bol = 0
  Output 'H': "    H"

Step 2: c = 'i'
  bol == 0? No (skip indentation)
  Output 'i': "    Hi"

Step 3: c = '\n'
  bol == 0? No
  Output '\n': "    Hi\n"
  c == '\n'? Yes
  bol = 1

Step 4: c = 'B'
  bol == 1? Yes
  Output 4 spaces: "    "
  bol = 0
  Output 'B': "    B"

Step 5: c = 'y'
  bol == 0? No
  Output 'y': "    By"

Step 6: c = 'e'
  bol == 0? No
  Output 'e': "    Bye"

Step 7: c = '\n'
  bol == 0? No
  Output '\n': "    Bye\n"
  c == '\n'? Yes
  bol = 1

Step 8: c = EOF
  Exit loop

Output: "    Hi\n    Bye\n"</code></pre>
<hr/>
<h2 data-number="10.8" id="b-vs-c"><span class="header-section-number">10.8</span> 12.8 B vs C</h2>
<h3 data-number="10.8.1" id="what-b-lacked"><span class="header-section-number">10.8.1</span> What B Lacked</h3>
<p>When Dennis Ritchie began evolving B into C in 1971-1972, he
addressed several fundamental limitations:</p>
<p><strong>1. Type System</strong></p>
<p><strong>B:</strong></p>
<pre class="b"><code>auto x, y, ptr;
x = 42;              /* x is an integer */
y = 'A';             /* y is a character */
ptr = &amp;x;            /* ptr is a pointer */
/* All are just "words" - no type checking */</code></pre>
<p><strong>C:</strong></p>
<div class="sourceCode" id="cb823"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb823-1"><a aria-hidden="true" href="#cb823-1" tabindex="-1"></a><span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb823-2"><a aria-hidden="true" href="#cb823-2" tabindex="-1"></a><span class="dt">char</span> y<span class="op">;</span></span>
<span id="cb823-3"><a aria-hidden="true" href="#cb823-3" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>ptr<span class="op">;</span></span>
<span id="cb823-4"><a aria-hidden="true" href="#cb823-4" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>              <span class="co">/* Correct */</span></span>
<span id="cb823-5"><a aria-hidden="true" href="#cb823-5" tabindex="-1"></a>y <span class="op">=</span> <span class="ch">'A'</span><span class="op">;</span>             <span class="co">/* Correct */</span></span>
<span id="cb823-6"><a aria-hidden="true" href="#cb823-6" tabindex="-1"></a>ptr <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span>            <span class="co">/* Correct */</span></span>
<span id="cb823-7"><a aria-hidden="true" href="#cb823-7" tabindex="-1"></a>ptr <span class="op">=</span> <span class="op">&amp;</span>y<span class="op">;</span>            <span class="co">/* </span><span class="al">WARNING</span><span class="co">: type mismatch */</span></span></code></pre></div>
<p><strong>Why This Matters:</strong></p>
<p>B allowed:</p>
<pre class="b"><code>auto x, y;
x = &amp;y;              /* x = pointer */
y = x + 10;          /* y = pointer + 10 */
*y = 42;             /* Dereference garbage - CRASH */</code></pre>
<p>C catches this at compile time:</p>
<div class="sourceCode" id="cb825"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb825-1"><a aria-hidden="true" href="#cb825-1" tabindex="-1"></a><span class="dt">int</span> x<span class="op">,</span> <span class="op">*</span>y<span class="op">;</span></span>
<span id="cb825-2"><a aria-hidden="true" href="#cb825-2" tabindex="-1"></a>x <span class="op">=</span> y <span class="op">+</span> <span class="dv">10</span><span class="op">;</span>          <span class="co">/* ERROR: cannot assign pointer to int */</span></span></code></pre></div>
<p><strong>2. Structures</strong></p>
<p><strong>B:</strong></p>
<pre class="b"><code>/* No structures! Had to use arrays with manual indexing */
auto inode[10];
#define i_mode   0
#define i_nlink  1
#define i_uid    2
#define i_size   3

inode[i_mode] = 0100644;
inode[i_nlink] = 1;
/* Easy to make mistakes, no type safety */</code></pre>
<p><strong>C:</strong></p>
<div class="sourceCode" id="cb827"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb827-1"><a aria-hidden="true" href="#cb827-1" tabindex="-1"></a><span class="kw">struct</span> inode <span class="op">{</span></span>
<span id="cb827-2"><a aria-hidden="true" href="#cb827-2" tabindex="-1"></a>    <span class="dt">int</span> i_mode<span class="op">;</span></span>
<span id="cb827-3"><a aria-hidden="true" href="#cb827-3" tabindex="-1"></a>    <span class="dt">int</span> i_nlink<span class="op">;</span></span>
<span id="cb827-4"><a aria-hidden="true" href="#cb827-4" tabindex="-1"></a>    <span class="dt">int</span> i_uid<span class="op">;</span></span>
<span id="cb827-5"><a aria-hidden="true" href="#cb827-5" tabindex="-1"></a>    <span class="dt">int</span> i_size<span class="op">;</span></span>
<span id="cb827-6"><a aria-hidden="true" href="#cb827-6" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb827-7"><a aria-hidden="true" href="#cb827-7" tabindex="-1"></a></span>
<span id="cb827-8"><a aria-hidden="true" href="#cb827-8" tabindex="-1"></a><span class="kw">struct</span> inode inode<span class="op">;</span></span>
<span id="cb827-9"><a aria-hidden="true" href="#cb827-9" tabindex="-1"></a>inode<span class="op">.</span>i_mode <span class="op">=</span> <span class="bn">0100644</span><span class="op">;</span>   <span class="co">/* Type-safe, clear */</span></span>
<span id="cb827-10"><a aria-hidden="true" href="#cb827-10" tabindex="-1"></a>inode<span class="op">.</span>i_nlink <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p><strong>3. Character vs Word Addressing</strong></p>
<p><strong>B (PDP-7):</strong></p>
<pre class="b"><code>/* B assumed word-addressed memory */
auto str;
str = "Hello";       /* str points to words containing characters */
*str;                /* Gets entire word (2 chars on PDP-7) */</code></pre>
<p><strong>C (PDP-11):</strong></p>
<div class="sourceCode" id="cb829"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb829-1"><a aria-hidden="true" href="#cb829-1" tabindex="-1"></a><span class="co">/* C supports byte-addressed memory */</span></span>
<span id="cb829-2"><a aria-hidden="true" href="#cb829-2" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>str<span class="op">;</span></span>
<span id="cb829-3"><a aria-hidden="true" href="#cb829-3" tabindex="-1"></a>str <span class="op">=</span> <span class="st">"Hello"</span><span class="op">;</span>       <span class="co">/* str points to bytes */</span></span>
<span id="cb829-4"><a aria-hidden="true" href="#cb829-4" tabindex="-1"></a><span class="op">*</span>str<span class="op">;</span>                <span class="co">/* Gets single character */</span></span>
<span id="cb829-5"><a aria-hidden="true" href="#cb829-5" tabindex="-1"></a>str<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="ch">'H'</span><span class="op">;</span>        <span class="co">/* Index by bytes */</span></span></code></pre></div>
<p>This was critical for PDP-11, which was byte-addressed, unlike
PDP-7.</p>
<p><strong>4. Floating Point</strong></p>
<p><strong>B:</strong></p>
<pre class="b"><code>/* No floating point support */
/* Had to use fixed-point arithmetic or integer scaling */
auto pi;
pi = 31416;          /* Represent 3.1416 as 31416/10000 */</code></pre>
<p><strong>C:</strong></p>
<div class="sourceCode" id="cb831"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb831-1"><a aria-hidden="true" href="#cb831-1" tabindex="-1"></a><span class="dt">float</span> pi<span class="op">;</span></span>
<span id="cb831-2"><a aria-hidden="true" href="#cb831-2" tabindex="-1"></a>pi <span class="op">=</span> <span class="fl">3.1416</span><span class="op">;</span>         <span class="co">/* Native floating point */</span></span>
<span id="cb831-3"><a aria-hidden="true" href="#cb831-3" tabindex="-1"></a><span class="dt">double</span> precise <span class="op">=</span> <span class="fl">3.14159265358979</span><span class="op">;</span></span></code></pre></div>
<p><strong>5. Local Variables on Stack</strong></p>
<p><strong>B (PDP-7):</strong></p>
<pre class="b"><code>/* All local variables allocated on entry */
func() {
    auto a, b, c, d, e, f, g, h, i, j;
    /* All 10 variables allocated even if not all used */
    a = 42;
    /* b-j waste space if not used */
}</code></pre>
<p><strong>C:</strong></p>
<div class="sourceCode" id="cb833"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb833-1"><a aria-hidden="true" href="#cb833-1" tabindex="-1"></a><span class="co">/* Compiler can optimize */</span></span>
<span id="cb833-2"><a aria-hidden="true" href="#cb833-2" tabindex="-1"></a>func<span class="op">()</span> <span class="op">{</span></span>
<span id="cb833-3"><a aria-hidden="true" href="#cb833-3" tabindex="-1"></a>    <span class="dt">int</span> a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb833-4"><a aria-hidden="true" href="#cb833-4" tabindex="-1"></a>    <span class="co">/* Compiler may not allocate space for unused variables */</span></span>
<span id="cb833-5"><a aria-hidden="true" href="#cb833-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>6. Lack of Operators</strong></p>
<p><strong>B Missing:</strong> - <code>+=</code>, <code>-=</code>,
<code>*=</code>, <code>/=</code> compound assignments -
<code>&amp;&amp;</code>, <code>||</code> logical operators (had bitwise
<code>&amp;</code>, <code>|</code> only) - <code>for</code> loop (added
in later B, standard in C) - <code>switch/case</code> (added in later B,
standard in C) - <code>typedef</code> (C only)</p>
<p><strong>7. No Type Checking</strong></p>
<p><strong>B:</strong></p>
<pre class="b"><code>func(a, b, c) {     /* No parameter types */
    return a + b;   /* What about c? No warning */
}

main() {
    func(1, 2);     /* Wrong number of args - no warning */
}</code></pre>
<p><strong>C:</strong></p>
<div class="sourceCode" id="cb835"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb835-1"><a aria-hidden="true" href="#cb835-1" tabindex="-1"></a><span class="dt">int</span> func<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">,</span> <span class="dt">int</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb835-2"><a aria-hidden="true" href="#cb835-2" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span>   <span class="co">/* </span><span class="al">WARNING</span><span class="co">: c unused */</span></span>
<span id="cb835-3"><a aria-hidden="true" href="#cb835-3" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb835-4"><a aria-hidden="true" href="#cb835-4" tabindex="-1"></a></span>
<span id="cb835-5"><a aria-hidden="true" href="#cb835-5" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb835-6"><a aria-hidden="true" href="#cb835-6" tabindex="-1"></a>    func<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span>     <span class="co">/* ERROR: too few arguments */</span></span>
<span id="cb835-7"><a aria-hidden="true" href="#cb835-7" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 data-number="10.8.2" id="why-c-was-needed"><span class="header-section-number">10.8.2</span> Why C Was Needed</h3>
<p><strong>The PDP-11 Problem:</strong></p>
<p>When Unix moved from PDP-7 (1969) to PDP-11 (1971), B‚Äôs limitations
became critical:</p>
<p><strong>PDP-7:</strong> - 18-bit words - Word-addressed memory -
Characters packed 2 per word - B fit naturally</p>
<p><strong>PDP-11:</strong> - 16-bit words - Byte-addressed memory -
Characters are single bytes - B was awkward</p>
<p><strong>Example Problem:</strong></p>
<pre class="b"><code>/* B on PDP-7: */
auto str;
str = "AB";          /* One word: &lt;AB&gt; */
*str;                /* Gets both characters */

/* B on PDP-11: */
auto str;
str = "AB";          /* Two bytes: 'A', 'B' */
*str;                /* Gets entire WORD (might be "AB" or garbage) */</code></pre>
<p>C solved this:</p>
<div class="sourceCode" id="cb837"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb837-1"><a aria-hidden="true" href="#cb837-1" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>str <span class="op">=</span> <span class="st">"AB"</span><span class="op">;</span>    <span class="co">/* Points to byte */</span></span>
<span id="cb837-2"><a aria-hidden="true" href="#cb837-2" tabindex="-1"></a><span class="op">*</span>str<span class="op">;</span>                <span class="co">/* Gets 'A' (one byte) */</span></span>
<span id="cb837-3"><a aria-hidden="true" href="#cb837-3" tabindex="-1"></a>str<span class="op">[</span><span class="dv">1</span><span class="op">];</span>              <span class="co">/* Gets 'B' (one byte) */</span></span></code></pre></div>
<p><strong>Performance Problem:</strong></p>
<p>B was interpreted, so:</p>
<pre class="b"><code>/* B interpreter overhead: */
while (i &lt; 100) {
    a[i] = i * i;
    i = i + 1;
}

Instructions executed:
- Fetch bytecode
- Decode operation
- Execute operation
- Update virtual registers
‚âà 50 PDP-11 instructions per B statement</code></pre>
<p>C was compiled:</p>
<div class="sourceCode" id="cb839"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb839-1"><a aria-hidden="true" href="#cb839-1" tabindex="-1"></a><span class="co">/* Direct machine code: */</span></span>
<span id="cb839-2"><a aria-hidden="true" href="#cb839-2" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>i <span class="op">&lt;</span> <span class="dv">100</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb839-3"><a aria-hidden="true" href="#cb839-3" tabindex="-1"></a>    a<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> i <span class="op">*</span> i<span class="op">;</span></span>
<span id="cb839-4"><a aria-hidden="true" href="#cb839-4" tabindex="-1"></a>    i<span class="op">++;</span></span>
<span id="cb839-5"><a aria-hidden="true" href="#cb839-5" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb839-6"><a aria-hidden="true" href="#cb839-6" tabindex="-1"></a></span>
<span id="cb839-7"><a aria-hidden="true" href="#cb839-7" tabindex="-1"></a>‚âà <span class="dv">5</span> PDP<span class="op">-</span><span class="dv">11</span> instructions per C statement</span></code></pre></div>
<p><strong>Speedup: 10x</strong></p>
<h3 data-number="10.8.3" id="evolution-path"><span class="header-section-number">10.8.3</span> Evolution Path</h3>
<p><strong>1969: B Created</strong> - Interpreted - Typeless -
Word-oriented - Simple and compact - Perfect for PDP-7</p>
<p><strong>1970: NB (New B)</strong> - Ritchie adds types - Still
interpreted - Experimental</p>
<p><strong>1971-1972: C Emerges</strong> - Compiled, not interpreted -
Strong type system - Byte-oriented - Structures - Retains B‚Äôs syntax
style</p>
<p><strong>1973: Unix Rewritten in C</strong> - Proves C viable for
systems programming - Unix becomes portable - C becomes industry
standard</p>
<p><strong>Timeline:</strong></p>
<pre><code>1966: BCPL (Martin Richards)
  ‚Üì
1969: B (Ken Thompson) - PDP-7 Unix
  ‚Üì
1970: NB (Dennis Ritchie) - experiments
  ‚Üì
1972: C (Dennis Ritchie) - compiled, typed
  ‚Üì
1973: Unix V4 in C
  ‚Üì
1978: K&amp;R C (The C Programming Language book)
  ‚Üì
1989: ANSI C (standardized)
  ‚Üì
1999: C99 (modernized)
  ‚Üì
2011: C11 (current)
  ‚Üì
2024: C still dominant for systems programming</code></pre>
<p><strong>What Survived from B to C:</strong></p>
<div class="sourceCode" id="cb841"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb841-1"><a aria-hidden="true" href="#cb841-1" tabindex="-1"></a><span class="co">/* These look almost identical in B and C: */</span></span>
<span id="cb841-2"><a aria-hidden="true" href="#cb841-2" tabindex="-1"></a></span>
<span id="cb841-3"><a aria-hidden="true" href="#cb841-3" tabindex="-1"></a><span class="co">/* Curly braces */</span></span>
<span id="cb841-4"><a aria-hidden="true" href="#cb841-4" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>x <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb841-5"><a aria-hidden="true" href="#cb841-5" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">"positive</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb841-6"><a aria-hidden="true" href="#cb841-6" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb841-7"><a aria-hidden="true" href="#cb841-7" tabindex="-1"></a></span>
<span id="cb841-8"><a aria-hidden="true" href="#cb841-8" tabindex="-1"></a><span class="co">/* Pointers */</span></span>
<span id="cb841-9"><a aria-hidden="true" href="#cb841-9" tabindex="-1"></a><span class="op">*</span>ptr <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb841-10"><a aria-hidden="true" href="#cb841-10" tabindex="-1"></a>ptr<span class="op">++;</span></span>
<span id="cb841-11"><a aria-hidden="true" href="#cb841-11" tabindex="-1"></a></span>
<span id="cb841-12"><a aria-hidden="true" href="#cb841-12" tabindex="-1"></a><span class="co">/* Arrays */</span></span>
<span id="cb841-13"><a aria-hidden="true" href="#cb841-13" tabindex="-1"></a>a<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb841-14"><a aria-hidden="true" href="#cb841-14" tabindex="-1"></a></span>
<span id="cb841-15"><a aria-hidden="true" href="#cb841-15" tabindex="-1"></a><span class="co">/* Operators */</span></span>
<span id="cb841-16"><a aria-hidden="true" href="#cb841-16" tabindex="-1"></a>x <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb841-17"><a aria-hidden="true" href="#cb841-17" tabindex="-1"></a>y <span class="op">*=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb841-18"><a aria-hidden="true" href="#cb841-18" tabindex="-1"></a></span>
<span id="cb841-19"><a aria-hidden="true" href="#cb841-19" tabindex="-1"></a><span class="co">/* Function calls */</span></span>
<span id="cb841-20"><a aria-hidden="true" href="#cb841-20" tabindex="-1"></a>result <span class="op">=</span> func<span class="op">(</span>a<span class="op">,</span> b<span class="op">);</span></span>
<span id="cb841-21"><a aria-hidden="true" href="#cb841-21" tabindex="-1"></a></span>
<span id="cb841-22"><a aria-hidden="true" href="#cb841-22" tabindex="-1"></a><span class="co">/* Comments (later) */</span></span>
<span id="cb841-23"><a aria-hidden="true" href="#cb841-23" tabindex="-1"></a><span class="co">/* This is a comment */</span></span></code></pre></div>
<p><strong>What Changed:</strong></p>
<pre><code>B                          C
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
auto x;                    int x;
extrn func;                extern int func();
'*n'                       '\n'
&lt;ab&gt;                       Not needed (byte chars)
No structures              struct { ... }
No types                   int, char, float, etc.
Interpreted                Compiled
Word pointers              Byte pointers</code></pre>
<hr/>
<h2 data-number="10.9" id="bs-legacy"><span class="header-section-number">10.9</span> 12.9 B‚Äôs Legacy</h2>
<h3 data-number="10.9.1" id="influence-on-c"><span class="header-section-number">10.9.1</span> Influence on C</h3>
<p>B‚Äôs most important contribution was being C‚Äôs direct ancestor. Almost
all of C‚Äôs syntax came from B:</p>
<p><strong>Curly Braces:</strong></p>
<div class="sourceCode" id="cb843"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb843-1"><a aria-hidden="true" href="#cb843-1" tabindex="-1"></a><span class="co">/* B introduced {} for blocks (from BCPL's $( $)) */</span></span>
<span id="cb843-2"><a aria-hidden="true" href="#cb843-2" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>condition<span class="op">)</span> <span class="op">{</span></span>
<span id="cb843-3"><a aria-hidden="true" href="#cb843-3" tabindex="-1"></a>    statement1<span class="op">;</span></span>
<span id="cb843-4"><a aria-hidden="true" href="#cb843-4" tabindex="-1"></a>    statement2<span class="op">;</span></span>
<span id="cb843-5"><a aria-hidden="true" href="#cb843-5" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Pointer Syntax:</strong></p>
<div class="sourceCode" id="cb844"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb844-1"><a aria-hidden="true" href="#cb844-1" tabindex="-1"></a><span class="co">/* B's * and &amp; operators */</span></span>
<span id="cb844-2"><a aria-hidden="true" href="#cb844-2" tabindex="-1"></a>ptr <span class="op">=</span> <span class="op">&amp;</span>variable<span class="op">;</span>    <span class="co">/* Address-of */</span></span>
<span id="cb844-3"><a aria-hidden="true" href="#cb844-3" tabindex="-1"></a>value <span class="op">=</span> <span class="op">*</span>ptr<span class="op">;</span>       <span class="co">/* Dereference */</span></span></code></pre></div>
<p><strong>Increment/Decrement:</strong></p>
<div class="sourceCode" id="cb845"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb845-1"><a aria-hidden="true" href="#cb845-1" tabindex="-1"></a><span class="co">/* B's ++ and -- */</span></span>
<span id="cb845-2"><a aria-hidden="true" href="#cb845-2" tabindex="-1"></a>i<span class="op">++;</span></span>
<span id="cb845-3"><a aria-hidden="true" href="#cb845-3" tabindex="-1"></a><span class="op">--</span>j<span class="op">;</span></span>
<span id="cb845-4"><a aria-hidden="true" href="#cb845-4" tabindex="-1"></a>ptr<span class="op">++;</span></span></code></pre></div>
<p><strong>Compound Assignment:</strong></p>
<div class="sourceCode" id="cb846"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb846-1"><a aria-hidden="true" href="#cb846-1" tabindex="-1"></a><span class="co">/* B introduced +=, -= syntax */</span></span>
<span id="cb846-2"><a aria-hidden="true" href="#cb846-2" tabindex="-1"></a>x <span class="op">+=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb846-3"><a aria-hidden="true" href="#cb846-3" tabindex="-1"></a>count <span class="op">*=</span> <span class="dv">2</span><span class="op">;</span></span></code></pre></div>
<p><strong>Control Flow:</strong></p>
<div class="sourceCode" id="cb847"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb847-1"><a aria-hidden="true" href="#cb847-1" tabindex="-1"></a><span class="co">/* B's while, if, else, goto */</span></span>
<span id="cb847-2"><a aria-hidden="true" href="#cb847-2" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>condition<span class="op">)</span></span>
<span id="cb847-3"><a aria-hidden="true" href="#cb847-3" tabindex="-1"></a>    statement<span class="op">;</span></span>
<span id="cb847-4"><a aria-hidden="true" href="#cb847-4" tabindex="-1"></a></span>
<span id="cb847-5"><a aria-hidden="true" href="#cb847-5" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>test<span class="op">)</span></span>
<span id="cb847-6"><a aria-hidden="true" href="#cb847-6" tabindex="-1"></a>    action1<span class="op">;</span></span>
<span id="cb847-7"><a aria-hidden="true" href="#cb847-7" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb847-8"><a aria-hidden="true" href="#cb847-8" tabindex="-1"></a>    action2<span class="op">;</span></span></code></pre></div>
<p><strong>Comments:</strong></p>
<div class="sourceCode" id="cb848"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb848-1"><a aria-hidden="true" href="#cb848-1" tabindex="-1"></a><span class="co">/* B's /* ... */</span> comments <span class="op">*/</span></span></code></pre></div>
<h3 data-number="10.9.2" id="concepts-that-survived"><span class="header-section-number">10.9.2</span> Concepts That Survived</h3>
<p><strong>1. Simplicity</strong></p>
<p>B philosophy: ‚ÄúKeep the language simple, put complexity in
libraries‚Äù</p>
<p>C inherited this: - Small core language - Rich standard library -
Minimal keywords</p>
<p><strong>2. Close to the Machine</strong></p>
<p>B allowed:</p>
<pre class="b"><code>addr = &amp;variable;
*addr = value;</code></pre>
<p>C retained this power:</p>
<div class="sourceCode" id="cb850"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb850-1"><a aria-hidden="true" href="#cb850-1" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>addr <span class="op">=</span> <span class="op">&amp;</span>variable<span class="op">;</span></span>
<span id="cb850-2"><a aria-hidden="true" href="#cb850-2" tabindex="-1"></a><span class="op">*</span>addr <span class="op">=</span> value<span class="op">;</span></span></code></pre></div>
<p><strong>3. Expression-Oriented</strong></p>
<p>B made assignments and comparisons expressions:</p>
<pre class="b"><code>while ((c = getchar()) != EOF)</code></pre>
<p>C kept this:</p>
<div class="sourceCode" id="cb852"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb852-1"><a aria-hidden="true" href="#cb852-1" tabindex="-1"></a><span class="cf">while</span> <span class="op">((</span>c <span class="op">=</span> getchar<span class="op">())</span> <span class="op">!=</span> EOF<span class="op">)</span></span></code></pre></div>
<p><strong>4. Trust the Programmer</strong></p>
<p>B didn‚Äôt prevent you from shooting yourself in the foot:</p>
<pre class="b"><code>auto ptr;
ptr = ptr + 1000;
*ptr = 42;         /* Might crash, B doesn't care */</code></pre>
<p>C continued this philosophy:</p>
<div class="sourceCode" id="cb854"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb854-1"><a aria-hidden="true" href="#cb854-1" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>ptr <span class="op">=</span> <span class="op">(</span><span class="dt">int</span> <span class="op">*)</span><span class="bn">0x1234</span><span class="op">;</span></span>
<span id="cb854-2"><a aria-hidden="true" href="#cb854-2" tabindex="-1"></a><span class="op">*</span>ptr <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>         <span class="co">/* Dangerous but allowed */</span></span></code></pre></div>
<p><strong>5. Terseness</strong></p>
<p>B favored short identifiers and compact syntax. C inherited this
style.</p>
<h3 data-number="10.9.3" id="what-disappeared"><span class="header-section-number">10.9.3</span> What Disappeared</h3>
<p><strong>1. Interpretation</strong></p>
<p>B: Interpreted bytecode C: Compiled to machine code</p>
<p><strong>Why:</strong> Performance. Compiled C is 10-20x faster.</p>
<p><strong>2. Typelessness</strong></p>
<p>B: Everything is a word C: Strong typing</p>
<p><strong>Why:</strong> Catch errors at compile time, support
byte-oriented machines.</p>
<p><strong>3. Word Orientation</strong></p>
<p>B: Pointers address words C: Pointers address bytes</p>
<p><strong>Why:</strong> Modern machines are byte-addressed (PDP-11
onwards).</p>
<p><strong>4. Character Constants</strong></p>
<p>B: <code>'*n'</code> for newline, <code>&lt;ab&gt;</code> for
two-character constant C: <code>'\n'</code> for newline, no packed
constants needed</p>
<p><strong>Why:</strong> Byte-oriented representation more natural.</p>
<p><strong>5. <code>extrn</code> Keyword</strong></p>
<p>B: <code>extrn func, var;</code> C:
<code>extern int func(); extern int var;</code></p>
<p><strong>Why:</strong> C requires type information.</p>
<p><strong>6. Implicit <code>int</code></strong></p>
<p>B: All variables implicitly ‚Äúword‚Äù type C: Originally implicit
<code>int</code>, now discouraged</p>
<div class="sourceCode" id="cb855"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb855-1"><a aria-hidden="true" href="#cb855-1" tabindex="-1"></a><span class="co">/* Old C (like B): */</span></span>
<span id="cb855-2"><a aria-hidden="true" href="#cb855-2" tabindex="-1"></a>func<span class="op">()</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span>           <span class="co">/* Implicitly returns int */</span></span>
<span id="cb855-3"><a aria-hidden="true" href="#cb855-3" tabindex="-1"></a></span>
<span id="cb855-4"><a aria-hidden="true" href="#cb855-4" tabindex="-1"></a><span class="co">/* Modern C: */</span></span>
<span id="cb855-5"><a aria-hidden="true" href="#cb855-5" tabindex="-1"></a><span class="dt">int</span> func<span class="op">()</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span>       <span class="co">/* Explicit type required */</span></span></code></pre></div>
<h3 data-number="10.9.4" id="historical-significance-1"><span class="header-section-number">10.9.4</span> Historical Significance</h3>
<p><strong>B‚Äôs Place in History:</strong></p>
<ol type="1">
<li><strong>First High-Level Language for Unix</strong>
<ul>
<li>Made Unix usable beyond assembly programmers</li>
<li>Prototyped ideas that became Unix utilities</li>
<li>Proved high-level language viable for systems work</li>
</ul></li>
<li><strong>Bridge from BCPL to C</strong>
<ul>
<li>Simplified BCPL for small machines</li>
<li>Tested ideas that went into C</li>
<li>Evolutionary step, not revolutionary jump</li>
</ul></li>
<li><strong>Enabled Unix‚Äôs Growth</strong>
<ul>
<li>B programs easier to write than assembly</li>
<li>More people could contribute to Unix</li>
<li>Faster development of utilities</li>
</ul></li>
<li><strong>Proved Minimalism Works</strong>
<ul>
<li>Tiny interpreter (~2000 lines)</li>
<li>Small language (~20 keywords)</li>
<li>Yet powerful enough for real programs</li>
</ul></li>
</ol>
<p><strong>B‚Äôs Indirect Influence:</strong></p>
<p>Through C, B influenced: - <strong>C++</strong> (1985) -
Object-oriented C - <strong>Objective-C</strong> (1984) - Apple‚Äôs
language - <strong>Java</strong> (1995) - C-style syntax -
<strong>C#</strong> (2000) - Microsoft‚Äôs C-like language -
<strong>JavaScript</strong> (1995) - C-style syntax despite different
paradigm - <strong>Go</strong> (2009) - Modern systems language, C
heritage - <strong>Rust</strong> (2010) - Systems language, C-style
control flow</p>
<p>Billions of lines of code today use syntax first prototyped in B.</p>
<p><strong>What We Owe to B:</strong></p>
<p>Every time you write:</p>
<div class="sourceCode" id="cb856"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb856-1"><a aria-hidden="true" href="#cb856-1" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>x <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb856-2"><a aria-hidden="true" href="#cb856-2" tabindex="-1"></a>    y<span class="op">++;</span></span>
<span id="cb856-3"><a aria-hidden="true" href="#cb856-3" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>You‚Äôre using syntax invented for B in 1969.</p>
<p>Every time you write:</p>
<div class="sourceCode" id="cb857"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb857-1"><a aria-hidden="true" href="#cb857-1" tabindex="-1"></a>ptr <span class="op">=</span> <span class="op">&amp;</span>var<span class="op">;</span></span>
<span id="cb857-2"><a aria-hidden="true" href="#cb857-2" tabindex="-1"></a><span class="op">*</span>ptr <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span></code></pre></div>
<p>You‚Äôre using pointer notation from B.</p>
<p>Every time you write:</p>
<div class="sourceCode" id="cb858"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb858-1"><a aria-hidden="true" href="#cb858-1" tabindex="-1"></a><span class="cf">while</span> <span class="op">((</span>c <span class="op">=</span> getchar<span class="op">())</span> <span class="op">!=</span> EOF<span class="op">)</span></span></code></pre></div>
<p>You‚Äôre using B‚Äôs expression-oriented style.</p>
<p><strong>B‚Äôs Real Legacy:</strong></p>
<p>B proved that: 1. High-level languages could be practical on small
machines 2. Interpreted languages could be useful for systems work 3.
Simpler is better than more complex 4. Syntax matters - good syntax
survives decades</p>
<p>B was never meant to be permanent. It was a stepping stone. But it
was a crucial stepping stone that led to C, which led to Unix‚Äôs
portability, which led to Unix‚Äôs success, which led to Linux, macOS,
Android, iOS, and the modern computing world.</p>
<p>B is forgotten by most programmers today. But every C programmer is
using B‚Äôs ideas, whether they know it or not.</p>
<hr/>
<h2 data-number="10.10" id="programming-in-b"><span class="header-section-number">10.10</span> 12.10 Programming in B</h2>
<h3 data-number="10.10.1" id="writing-b-programs"><span class="header-section-number">10.10.1</span> Writing B Programs</h3>
<p><strong>Basic Structure:</strong></p>
<pre class="b"><code>/*
 * program.b - Program description
 */

/* External declarations */
extrn printf, getchar, putchar;
extrn buffer, count;

/* Global variables */
total;
flag;

/* Main function */
main(argc, argv) {
    auto i, c, temp;

    /* Initialization */
    total = 0;
    flag = 1;

    /* Main logic */
    i = 0;
    while (i &lt; argc) {
        printf("%s*n", argv[i]);
        i = i + 1;
    }

    return (0);
}

/* Helper functions */
helper(x, y) {
    auto result;
    result = x + y;
    return (result);
}</code></pre>
<p><strong>Key Patterns:</strong></p>
<p><strong>1. Input Loop:</strong></p>
<pre class="b"><code>main() {
    auto c;
    while ((c = getchar()) != '*e') {
        /* Process c */
        putchar(c);
    }
}</code></pre>
<p><strong>2. Array Iteration:</strong></p>
<pre class="b"><code>process_array(arr, count) {
    auto i;
    i = 0;
    while (i &lt; count) {
        printf("%d*n", arr[i]);
        i = i + 1;
    }
}</code></pre>
<p><strong>3. String Processing:</strong></p>
<pre class="b"><code>string_length(s) {
    auto len;
    len = 0;
    while (*s++) {
        len = len + 1;
    }
    return (len);
}</code></pre>
<p><strong>4. Error Handling:</strong></p>
<pre class="b"><code>main() {
    auto fd;

    fd = open("file", 0);
    if (fd &lt; 0) {
        printf("Error opening file*n");
        return (1);
    }

    /* Use fd */

    close(fd);
    return (0);
}</code></pre>
<h3 data-number="10.10.2" id="compilationinterpretation"><span class="header-section-number">10.10.2</span>
Compilation/Interpretation</h3>
<p><strong>Workflow on PDP-7 Unix:</strong></p>
<pre><code>Step 1: Write source
$ ed program.b
a
main() {
    printf("Hello*n");
}
.
w
q

Step 2: Compile to bytecode
$ bc program.b program.bo
$

Step 3: Run with interpreter
$ bi program.bo
Hello
$</code></pre>
<p><strong>What <code>bc</code> Does (B Compiler):</strong></p>
<pre class="assembly"><code>1. Read source file
2. Lexical analysis (tokenize)
3. Parse into syntax tree
4. Generate bytecode
5. Write bytecode to .bo file</code></pre>
<p><strong>What <code>bi</code> Does (B Interpreter):</strong></p>
<pre class="assembly"><code>1. Read bytecode file
2. Initialize virtual machine
3. Execute bytecode instructions
4. Handle library calls
5. Exit when program terminates</code></pre>
<p><strong>Memory Layout During Execution:</strong></p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê 0000
‚îÇ B Interpreter (bi.s)     ‚îÇ
‚îÇ - Fetch/decode/execute   ‚îÇ
‚îÇ - Virtual registers      ‚îÇ
‚îÇ - Builtin functions      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ 2000
‚îÇ B Bytecode (program.bo)  ‚îÇ
‚îÇ - Instructions           ‚îÇ
‚îÇ - Constants              ‚îÇ
‚îÇ - String literals        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ 3000
‚îÇ B Runtime Library (bl.s) ‚îÇ
‚îÇ - printf, getchar, etc   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ 4000
‚îÇ Heap (dynamic alloc)     ‚îÇ
‚îÇ ‚Üì grows down             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Free space               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ‚Üë grows up               ‚îÇ
‚îÇ Stack (local vars)       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò 7777</code></pre>
<h3 data-number="10.10.3" id="debugging"><span class="header-section-number">10.10.3</span> Debugging</h3>
<p><strong>Debugging Techniques in B:</strong></p>
<p><strong>1. Print Statements:</strong></p>
<pre class="b"><code>main() {
    auto x, y;
    x = 10;
    printf("x = %d*n", x);    /* Debug output */
    y = compute(x);
    printf("y = %d*n", y);    /* Debug output */
}</code></pre>
<p><strong>2. Trace Mode:</strong></p>
<p>If B interpreter built with tracing:</p>
<pre><code>$ bi -t program.bo
PC=0100 SP=4000 CONST 10
PC=0101 SP=4001 STORE x
PC=0102 SP=4000 LOAD x
PC=0103 SP=4001 CALL compute
...</code></pre>
<p><strong>3. Core Dump Analysis:</strong></p>
<p>If program crashes:</p>
<pre><code>$ bi program.bo
Segmentation fault (core dumped)

$ db core bi
52
$=
interpret_loop+42</code></pre>
<p><strong>4. Conditional Debugging:</strong></p>
<pre class="b"><code>debug = 1;    /* Set to 0 to disable debugging */

main() {
    auto x;
    x = compute(42);

    if (debug)
        printf("x = %d*n", x);
}</code></pre>
<p><strong>5. Assertion Checks:</strong></p>
<pre class="b"><code>assert(condition, message) {
    if (!condition) {
        printf("Assertion failed: %s*n", message);
        exit(1);
    }
}

main() {
    auto ptr;
    ptr = allocate(100);
    assert(ptr != 0, "allocation failed");
}</code></pre>
<h3 data-number="10.10.4" id="performance"><span class="header-section-number">10.10.4</span> Performance</h3>
<p><strong>B Performance Characteristics:</strong></p>
<p><strong>Interpretation Overhead:</strong></p>
<pre><code>B bytecode:     LOAD x
                LOAD y
                ADD
                STORE z

PDP-7 instructions executed:
                LAC pc          ; Get PC
                DAC 8           ; Save
                LAC i 8         ; Fetch instruction
                ...             ; Decode (20+ instructions)
                LAC dp          ; Get variable address
                ADD offset
                DAC 8
                LAC i 8         ; Load value
                ...             ; (30+ instructions total)</code></pre>
<p>Each B instruction ‚Üí ~30-50 PDP-7 instructions</p>
<p><strong>Assembly equivalent:</strong></p>
<pre class="assembly"><code>LAC x
ADD y
DAC z</code></pre>
<p>3 instructions total</p>
<p><strong>Speed Ratio: Assembly ~15x faster than B</strong></p>
<p><strong>When B is Acceptable:</strong></p>
<ul>
<li>I/O-bound programs (spending time in system calls)</li>
<li>One-time utilities</li>
<li>Prototypes</li>
<li>Small programs (&lt;1000 lines)</li>
</ul>
<p><strong>When B is Too Slow:</strong></p>
<ul>
<li>Tight loops (sorting, searching)</li>
<li>Real-time programs</li>
<li>System daemons</li>
<li>Large computations</li>
</ul>
<p><strong>Optimization Techniques:</strong></p>
<p><strong>1. Hoist Loop-Invariant Code:</strong></p>
<p><strong>Slow:</strong></p>
<pre class="b"><code>i = 0;
while (i &lt; n) {
    array[i] = array[i] + constant_value();
    i = i + 1;
}</code></pre>
<p><strong>Faster:</strong></p>
<pre class="b"><code>temp = constant_value();
i = 0;
while (i &lt; n) {
    array[i] = array[i] + temp;
    i = i + 1;
}</code></pre>
<p><strong>2. Minimize Function Calls:</strong></p>
<p><strong>Slow:</strong></p>
<pre class="b"><code>while (i &lt; get_limit()) {  /* get_limit() called every iteration */
    process(i);
    i = i + 1;
}</code></pre>
<p><strong>Faster:</strong></p>
<pre class="b"><code>limit = get_limit();
while (i &lt; limit) {
    process(i);
    i = i + 1;
}</code></pre>
<p><strong>3. Use Local Variables:</strong></p>
<p><strong>Slow (global):</strong></p>
<pre class="b"><code>global_sum;

add_to_sum(x) {
    global_sum = global_sum + x;
}</code></pre>
<p><strong>Faster (local):</strong></p>
<pre class="b"><code>add_numbers(x, y) {
    auto sum;
    sum = x + y;
    return (sum);
}</code></pre>
<p><strong>4. Pointer Arithmetic:</strong></p>
<p><strong>Slow:</strong></p>
<pre class="b"><code>i = 0;
while (i &lt; 100) {
    total = total + array[i];
    i = i + 1;
}</code></pre>
<p><strong>Faster:</strong></p>
<pre class="b"><code>auto ptr, end;
ptr = array;
end = array + 100;
while (ptr &lt; end) {
    total = total + *ptr;
    ptr = ptr + 1;
}</code></pre>
<p><strong>Real-World Performance:</strong></p>
<pre><code>Program: Word count (wc.b)
Input: 1000-line file

B interpreter: 5.2 seconds
Assembly:      0.3 seconds

Ratio: 17x slower

But:
- B program: 50 lines
- Assembly: 300 lines
- Development time: 1 hour vs 1 day</code></pre>
<p>For many tasks, the development speed advantage of B outweighed its
runtime performance penalty.</p>
<hr/>
<h2 data-number="10.11" id="historical-context-4"><span class="header-section-number">10.11</span> 12.11 Historical Context</h2>
<h3 data-number="10.11.1" id="high-level-languages"><span class="header-section-number">10.11.1</span> 1969 High-Level
Languages</h3>
<p>When Ken Thompson created B in 1969, the high-level language
landscape looked very different from today:</p>
<p><strong>Dominant Languages in 1969:</strong></p>
<table>
<colgroup>
<col style="width: 19%"/>
<col style="width: 11%"/>
<col style="width: 25%"/>
<col style="width: 25%"/>
<col style="width: 17%"/>
</colgroup>
<thead>
<tr>
<th>Language</th>
<th>Year</th>
<th>Primary Use</th>
<th>Compilation</th>
<th>Notable</th>
</tr>
</thead>
<tbody>
<tr>
<td>FORTRAN</td>
<td>1957</td>
<td>Scientific computing</td>
<td>Compiled</td>
<td>First high-level language</td>
</tr>
<tr>
<td>LISP</td>
<td>1958</td>
<td>AI research</td>
<td>Interpreted</td>
<td>Garbage collection</td>
</tr>
<tr>
<td>COBOL</td>
<td>1959</td>
<td>Business data</td>
<td>Compiled</td>
<td>Verbose, English-like</td>
</tr>
<tr>
<td>ALGOL 60</td>
<td>1960</td>
<td>Academic</td>
<td>Compiled</td>
<td>Block structure, lexical scope</td>
</tr>
<tr>
<td>BASIC</td>
<td>1964</td>
<td>Education</td>
<td>Interpreted</td>
<td>Simple for beginners</td>
</tr>
<tr>
<td>PL/I</td>
<td>1964</td>
<td>General purpose</td>
<td>Compiled</td>
<td>IBM‚Äôs ‚Äúeverything‚Äù language</td>
</tr>
<tr>
<td>BCPL</td>
<td>1966</td>
<td>Systems</td>
<td>Compiled</td>
<td>B‚Äôs direct ancestor</td>
</tr>
<tr>
<td>Logo</td>
<td>1967</td>
<td>Education</td>
<td>Interpreted</td>
<td>Turtle graphics</td>
</tr>
</tbody>
</table>
<p><strong>What Was Missing:</strong></p>
<p>Nobody had created a language that was: 1. Simple enough to implement
in 2000 lines 2. Efficient enough for 8K word machines 3. Powerful
enough for systems programming 4. Fast enough to develop with
interpretively</p>
<p>B filled that exact niche.</p>
<h3 data-number="10.11.2" id="bcpl-algol-fortran"><span class="header-section-number">10.11.2</span> BCPL, ALGOL, FORTRAN</h3>
<p><strong>BCPL (Basic Combined Programming Language)</strong></p>
<p>Created by Martin Richards at Cambridge, 1966-1967.</p>
<p><strong>BCPL Example:</strong></p>
<pre class="bcpl"><code>LET START() BE
$(  LET V = VEC 100
    LET COUNT = 0

    WHILE COUNT &lt; 100 DO
    $(  V!COUNT := COUNT * COUNT
        COUNT := COUNT + 1
    $)

    WRITEF("Done*N")
$)</code></pre>
<p><strong>Key Features:</strong> - Typeless (like B) - <code>$(</code>
<code>$)</code> for blocks - <code>:=</code> for assignment -
<code>!</code> for indirection - Compiled to O-code (bytecode) -
Portable via O-code interpreter</p>
<p><strong>What B Took from BCPL:</strong> - Typeless model - Pointer
arithmetic - Systems programming orientation - Block structure</p>
<p><strong>What B Simplified:</strong> - <code>{</code> <code>}</code>
instead of <code>$(</code> <code>$)</code> - <code>=</code> instead of
<code>:=</code> - <code>*</code> instead of <code>!</code> - Simpler
keywords</p>
<hr/>
<p><strong>ALGOL 60</strong></p>
<p>Academic language, very influential on later languages.</p>
<p><strong>ALGOL Example:</strong></p>
<pre class="algol"><code>begin
    integer i, sum;
    sum := 0;
    for i := 1 step 1 until 100 do
        sum := sum + i;
    print(sum)
end</code></pre>
<p><strong>Key Features:</strong> - Strong typing - Block structure -
Lexical scoping - Recursive functions - Call by name/value</p>
<p><strong>Influence on B:</strong> - Block structure (via BCPL) -
Lexical scoping - Recursive functions</p>
<p><strong>What B Rejected:</strong> - Complex syntax - Strong typing -
Formal grammar</p>
<hr/>
<p><strong>FORTRAN (FORmula TRANslation)</strong></p>
<p>The first widely-used high-level language, 1957.</p>
<p><strong>FORTRAN Example:</strong></p>
<div class="sourceCode" id="cb886"><pre class="sourceCode fortran"><code class="sourceCode fortranfixed"><span id="cb886-1"><a aria-hidden="true" href="#cb886-1" tabindex="-1"></a>      <span class="kw">PROGRAM</span> COMPUTE</span>
<span id="cb886-2"><a aria-hidden="true" href="#cb886-2" tabindex="-1"></a>      <span class="dt">REAL</span> X, Y, <span class="kw">RESULT</span></span>
<span id="cb886-3"><a aria-hidden="true" href="#cb886-3" tabindex="-1"></a>      <span class="dt">INTEGER</span> I, N</span>
<span id="cb886-4"><a aria-hidden="true" href="#cb886-4" tabindex="-1"></a></span>
<span id="cb886-5"><a aria-hidden="true" href="#cb886-5" tabindex="-1"></a>      N <span class="kw">=</span> <span class="dv">100</span></span>
<span id="cb886-6"><a aria-hidden="true" href="#cb886-6" tabindex="-1"></a>      <span class="kw">RESULT</span> <span class="kw">=</span> <span class="fl">0.0</span></span>
<span id="cb886-7"><a aria-hidden="true" href="#cb886-7" tabindex="-1"></a></span>
<span id="cb886-8"><a aria-hidden="true" href="#cb886-8" tabindex="-1"></a>      <span class="kw">DO</span> <span class="dv">10</span> I <span class="kw">=</span> <span class="dv">1</span>, N</span>
<span id="cb886-9"><a aria-hidden="true" href="#cb886-9" tabindex="-1"></a>         X <span class="kw">=</span> <span class="dt">REAL(I)</span></span>
<span id="cb886-10"><a aria-hidden="true" href="#cb886-10" tabindex="-1"></a>         Y <span class="kw">=</span> X <span class="kw">*</span> X</span>
<span id="cb886-11"><a aria-hidden="true" href="#cb886-11" tabindex="-1"></a>         <span class="kw">RESULT</span> <span class="kw">=</span> <span class="kw">RESULT</span> <span class="kw">+</span> Y</span>
<span id="cb886-12"><a aria-hidden="true" href="#cb886-12" tabindex="-1"></a>   <span class="dv">10</span> <span class="kw">CONTINUE</span></span>
<span id="cb886-13"><a aria-hidden="true" href="#cb886-13" tabindex="-1"></a></span>
<span id="cb886-14"><a aria-hidden="true" href="#cb886-14" tabindex="-1"></a>      <span class="fu">PRINT</span> <span class="kw">*</span>, <span class="st">'Result:'</span>, <span class="kw">RESULT</span></span>
<span id="cb886-15"><a aria-hidden="true" href="#cb886-15" tabindex="-1"></a>      <span class="kw">END</span></span></code></pre></div>
<p><strong>Key Features:</strong> - Compiled to efficient code - Numeric
focus - Array operations - Fixed format (column-oriented) - No
pointers</p>
<p><strong>Why B Didn‚Äôt Follow FORTRAN:</strong> - FORTRAN too
specialized (scientific) - No pointer support (needed for systems) -
Verbose syntax - Not suitable for text processing</p>
<h3 data-number="10.11.3" id="why-b-was-different"><span class="header-section-number">10.11.3</span> Why B Was Different</h3>
<p><strong>Comparison Matrix:</strong></p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>FORTRAN</th>
<th>ALGOL</th>
<th>LISP</th>
<th>BASIC</th>
<th>BCPL</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr>
<td>Types</td>
<td>Strong</td>
<td>Strong</td>
<td>Dynamic</td>
<td>Weak</td>
<td>None</td>
<td>None</td>
</tr>
<tr>
<td>Compilation</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Pointers</td>
<td>No</td>
<td>Limited</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Size</td>
<td>Large</td>
<td>Large</td>
<td>Large</td>
<td>Medium</td>
<td>Medium</td>
<td>Small</td>
</tr>
<tr>
<td>Speed</td>
<td>Fast</td>
<td>Fast</td>
<td>Slow</td>
<td>Slow</td>
<td>Fast</td>
<td>Medium</td>
</tr>
<tr>
<td>Systems programming</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Learning curve</td>
<td>Medium</td>
<td>Hard</td>
<td>Hard</td>
<td>Easy</td>
<td>Medium</td>
<td>Easy</td>
</tr>
<tr>
<td>Memory required</td>
<td>Large</td>
<td>Large</td>
<td>Large</td>
<td>Small</td>
<td>Medium</td>
<td>Small</td>
</tr>
</tbody>
</table>
<p><strong>B‚Äôs Unique Position:</strong></p>
<ol type="1">
<li><strong>Small enough to run on PDP-7</strong> - Unlike ALGOL,
FORTRAN</li>
<li><strong>Powerful enough for systems work</strong> - Unlike
BASIC</li>
<li><strong>Interpreted for fast development</strong> - Unlike BCPL,
FORTRAN</li>
<li><strong>Pointer support</strong> - Unlike FORTRAN, BASIC, LISP</li>
<li><strong>Untyped for simplicity</strong> - Like BCPL, unlike most
others</li>
<li><strong>C-like syntax</strong> - Prototype for modern languages</li>
</ol>
<h3 data-number="10.11.4" id="impact-on-portability"><span class="header-section-number">10.11.4</span> Impact on Portability</h3>
<p><strong>The Portability Problem (1969):</strong></p>
<p>Most programs were written in assembly language, which was: -
<strong>Specific to one CPU</strong> - PDP-7 assembly won‚Äôt run on
PDP-11 - <strong>Non-portable</strong> - Complete rewrite needed for new
machine - <strong>Difficult to maintain</strong> - Hard to understand,
easy to break - <strong>Slow to develop</strong> - Tedious coding
process</p>
<p><strong>The High-Level Language Promise:</strong></p>
<p>Write once, run anywhere (by recompiling or re-interpreting).</p>
<p><strong>Reality:</strong></p>
<p>Most high-level languages in 1969 had portability problems:</p>
<p><strong>FORTRAN:</strong></p>
<div class="sourceCode" id="cb887"><pre class="sourceCode fortran"><code class="sourceCode fortranfixed"><span id="cb887-1"><a aria-hidden="true" href="#cb887-1" tabindex="-1"></a>      <span class="dt">CHARACTER*10</span> NAME</span>
<span id="cb887-2"><a aria-hidden="true" href="#cb887-2" tabindex="-1"></a>      <span class="dt">INTEGER*4</span> <span class="fu">COUNT</span></span></code></pre></div>
<p>Problem: <code>INTEGER*4</code> size varies by machine - IBM 360: 32
bits - CDC 6600: 60 bits - PDP-11: 16 bits</p>
<p><strong>ALGOL:</strong> Problem: No standard I/O, each implementation
different</p>
<p><strong>BASIC:</strong> Problem: Many dialects, incompatible</p>
<p><strong>B‚Äôs Portability Story:</strong></p>
<p><strong>Theoretical:</strong> - Bytecode portable (interpreter on
each machine) - Source code portable - Abstract machine model</p>
<p><strong>Reality:</strong> - Word size assumptions (18-bit on PDP-7) -
Character packing (2 chars/word on PDP-7) - System call differences -
Not actually ported much before C superseded it</p>
<p><strong>What B Taught:</strong></p>
<ol type="1">
<li><strong>Abstraction helps</strong> - Virtual machine easier to port
than assembly</li>
<li><strong>But assumptions hurt</strong> - Word size assumptions
limited portability</li>
<li><strong>Types matter</strong> - B‚Äôs typelessness caused problems on
byte-addressed machines</li>
<li><strong>Performance matters</strong> - Interpretation too slow for
production use</li>
</ol>
<p><strong>Evolution to C:</strong></p>
<p>C fixed B‚Äôs portability problems: - Byte-oriented (not word-oriented)
- Typed (portable across word sizes) - Compiled (efficient on all
machines) - Standard library (portable I/O)</p>
<p><strong>The Result:</strong></p>
<p>By 1978, C became the first truly portable systems programming
language: - Unix ported to dozens of machines - C compiler available
everywhere - Standard library mostly compatible - Source code portable
(with care)</p>
<p>This portability made Unix successful, which made C successful, which
made Unix more successful (virtuous cycle).</p>
<p><strong>B‚Äôs Role:</strong></p>
<p>B was the experiment that showed: - High-level languages viable for
systems work - Interpretation practical for development - Simple syntax
makes language learnable - But also showed what was needed (types,
compilation, byte orientation)</p>
<p>B was the prototype. C was the production version.</p>
<hr/>
<h2 data-number="10.12" id="conclusion-bs-place-in-computing-history"><span class="header-section-number">10.12</span> Conclusion: B‚Äôs Place in
Computing History</h2>
<p>The B language system on PDP-7 Unix represents a crucial evolutionary
step in programming language design. While B itself is obsolete and
forgotten by most programmers, its influence echoes through every line
of C, C++, Java, JavaScript, C#, and countless other languages that use
curly-brace syntax and C-style operators.</p>
<p><strong>B‚Äôs Achievements:</strong></p>
<ol type="1">
<li><strong>Proved High-Level Languages Viable for Systems Work</strong>
<ul>
<li>Before B: ‚ÄúSystems must be written in assembly‚Äù</li>
<li>After B: ‚ÄúHigh-level languages can work for systems‚Äù</li>
<li>Paved way for C and Unix‚Äôs rewrite</li>
</ul></li>
<li><strong>Demonstrated Minimalist Design</strong>
<ul>
<li>~2000 line interpreter</li>
<li>~20 keywords</li>
<li>Simple syntax</li>
<li>Yet powerful enough for real programs</li>
</ul></li>
<li><strong>Bridged BCPL to C</strong>
<ul>
<li>Simplified BCPL‚Äôs syntax</li>
<li>Tested ideas for C</li>
<li>Provided working model</li>
</ul></li>
<li><strong>Enabled Unix‚Äôs Growth</strong>
<ul>
<li>Made Unix accessible to non-assembly programmers</li>
<li>Allowed rapid prototyping</li>
<li>Utilities written faster than in assembly</li>
</ul></li>
</ol>
<p><strong>B‚Äôs Limitations:</strong></p>
<ol type="1">
<li><strong>Typelessness</strong> - No error checking, bugs hard to
find</li>
<li><strong>Word Orientation</strong> - Didn‚Äôt fit byte-addressed
machines</li>
<li><strong>Interpretation</strong> - Too slow for production use</li>
<li><strong>No Structures</strong> - Complex data awkward to handle</li>
<li><strong>Character Handling</strong> - Packed characters
confusing</li>
</ol>
<p>These limitations drove C‚Äôs creation.</p>
<p><strong>The Evolutionary Chain:</strong></p>
<pre><code>1966: BCPL
  ‚Üì
1969: B (PDP-7 Unix)
  - Simpler syntax
  - Interpreted
  - Untyped
  ‚Üì
1970: NB (New B)
  - Added types (experimental)
  ‚Üì
1972: C
  - Compiled
  - Typed
  - Byte-oriented
  - Structures
  ‚Üì
1973: Unix in C
  - Operating system in high-level language
  - Portable
  ‚Üì
1978: K&amp;R C
  - Standardized
  - Book published
  ‚Üì
1980s: C becomes dominant
  ‚Üì
1990s-2020s: C family languages dominate
  (C++, Java, C#, JavaScript, Go, Rust, Swift, etc.)</code></pre>
<p><strong>What We Owe to B:</strong></p>
<p>Every time modern programmers write:</p>
<div class="sourceCode" id="cb889"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb889-1"><a aria-hidden="true" href="#cb889-1" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>condition<span class="op">)</span> <span class="op">{</span></span>
<span id="cb889-2"><a aria-hidden="true" href="#cb889-2" tabindex="-1"></a>    statement<span class="op">;</span></span>
<span id="cb889-3"><a aria-hidden="true" href="#cb889-3" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb889-4"><a aria-hidden="true" href="#cb889-4" tabindex="-1"></a></span>
<span id="cb889-5"><a aria-hidden="true" href="#cb889-5" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>condition<span class="op">)</span> <span class="op">{</span></span>
<span id="cb889-6"><a aria-hidden="true" href="#cb889-6" tabindex="-1"></a>    statement<span class="op">;</span></span>
<span id="cb889-7"><a aria-hidden="true" href="#cb889-7" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb889-8"><a aria-hidden="true" href="#cb889-8" tabindex="-1"></a></span>
<span id="cb889-9"><a aria-hidden="true" href="#cb889-9" tabindex="-1"></a>ptr<span class="op">++;</span></span>
<span id="cb889-10"><a aria-hidden="true" href="#cb889-10" tabindex="-1"></a><span class="op">*</span>ptr <span class="op">=</span> value<span class="op">;</span></span>
<span id="cb889-11"><a aria-hidden="true" href="#cb889-11" tabindex="-1"></a>x <span class="op">+=</span> <span class="dv">5</span><span class="op">;</span></span></code></pre></div>
<p>They‚Äôre using syntax invented for B in 1969.</p>
<p><strong>B‚Äôs Real Legacy:</strong></p>
<p>B proved that: 1. <strong>Simplicity scales</strong> - Small
languages can be powerful 2. <strong>Syntax matters</strong> - Good
syntax survives decades 3. <strong>Iteration works</strong> - B ‚Üí C ‚Üí
C++ evolution 4. <strong>Tools enable tools</strong> - B helped build
better tools 5. <strong>Portability is valuable</strong> - Even
imperfect portability helps</p>
<p><strong>The Virtuous Cycle:</strong></p>
<pre><code>Better language (B)
    ‚Üì
Better programs
    ‚Üì
Better tools
    ‚Üì
Better language (C)
    ‚Üì
Better programs (Unix in C)
    ‚Üì
Better systems
    ‚Üì
...continues forever...</code></pre>
<p><strong>Why Study B Today?</strong></p>
<ol type="1">
<li><strong>Historical Understanding</strong> - See where C came
from</li>
<li><strong>Language Design</strong> - Learn what works and what
doesn‚Äôt</li>
<li><strong>Minimalism</strong> - Appreciate simple solutions</li>
<li><strong>Evolution</strong> - Understand iterative design</li>
<li><strong>Context</strong> - Appreciate constraints that shaped
Unix</li>
</ol>
<p><strong>The Final Word:</strong></p>
<p>B was never meant to be the final answer. It was a stepping stone, an
experiment, a prototype. But it was a crucial stepping stone that made C
possible, which made portable Unix possible, which made Linux possible,
which powers the modern world.</p>
<p>B is gone. But its ideas live on in billions of devices and trillions
of lines of code.</p>
<p>That is B‚Äôs true legacy: not what it was, but what it became.</p>
<hr/>
<p><strong>Technical Specifications Summary:</strong></p>
<pre><code>B Language System for PDP-7 Unix (1969)

Components:
- bi.s:    B interpreter (~2000 lines)
- bc.s:    B compiler support (~500 lines)
- bl.s:    B runtime library (~300 lines)

Language Features:
- Typeless (all values are words)
- Interpreted (bytecode execution)
- Stack-based virtual machine
- Pointers and arrays
- Recursive functions
- C-like syntax

Performance:
- Interpretation overhead: ~30-50 instructions per B instruction
- Speed: ~15x slower than assembly
- Memory: ~4K words for interpreter + program

Legacy:
- Direct ancestor of C
- Influenced all C-family languages
- Proved high-level languages viable for systems
- Demonstrated minimalist design principles

Historical Significance:
- First high-level language for Unix
- Enabled rapid Unix development
- Bridged BCPL to C
- Established syntax still used today</code></pre>
<p>B was small, simple, and elegant. It did exactly what was needed at
the time. And then, having served its purpose, it stepped aside for
something better.</p>
<p>That is the mark of great design: knowing when to evolve.</p>
<h1 data-number="11" id="chapter-14-legacy-and-impact-how-8000-lines-changed-the-world"><span class="header-section-number">11</span> Chapter 14: Legacy and Impact ‚Äî
How 8,000 Lines Changed the World</h1>
<p><em>‚ÄúUnix is simple and coherent, but it takes a genius (or at any
rate a programmer) to understand and appreciate the simplicity.‚Äù</em> ‚Äî
Dennis Ritchie, 1984</p>
<p>In the summer of 1969, Ken Thompson sat down at an obsolete PDP-7
minicomputer and wrote approximately 8,000 lines of assembly code. That
code became Unix. What happened next is one of the most remarkable
stories in the history of technology‚Äîa tale of how elegant design,
simple principles, and the right ideas at the right time can reshape the
entire world.</p>
<p>Today, more than 55 years later, the descendants of that PDP-7 code
run on billions of devices. They power the servers behind every major
website, the smartphones in our pockets, the supercomputers advancing
science, and the embedded systems controlling everything from cars to
spacecraft. Unix didn‚Äôt just succeed‚Äîit became the invisible foundation
of modern computing.</p>
<p>This chapter traces that extraordinary journey.</p>
<h2 data-number="11.1" id="from-pdp-7-to-world-domination"><span class="header-section-number">11.1</span> 14.1 From PDP-7 to World
Domination</h2>
<h3 data-number="11.1.1" id="the-pdp-11-port-1970-1971"><span class="header-section-number">11.1.1</span> The PDP-11 Port
(1970-1971)</h3>
<h4 data-number="11.1.1.1" id="why-move-to-pdp-11"><span class="header-section-number">11.1.1.1</span> Why Move to PDP-11?</h4>
<p>By late 1970, PDP-7 Unix had proven its worth. The system was
self-hosting, complete, and remarkably productive to use. But the
PDP-7‚Äôs limitations were becoming painful:</p>
<p><strong>PDP-7 Constraints:</strong> - <strong>8K words</strong> (16
KB) of memory‚Äîbarely enough for kernel + one user - <strong>18-bit
architecture</strong>‚Äîincompatible with emerging industry standards -
<strong>DECtape storage</strong>‚Äîslow and limited capacity -
<strong>Obsolete hardware</strong>‚Äîintroduced in 1964, already ancient
by 1970 - <strong>No memory protection</strong>‚Äîdangerous for multi-user
systems</p>
<p>The solution arrived in early 1971: Bell Labs acquired a
<strong>PDP-11/20</strong>, a much more capable machine:</p>
<pre><code>PDP-7 vs. PDP-11 Comparison:

Specification       PDP-7 (1964)      PDP-11/20 (1970)    Improvement
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Word size           18-bit            16-bit              Industry std.
Addressable memory  8K words (16KB)   256KB               16x larger
Memory protection   None              MMU available       Multi-user safe
Mass storage        DECtape (144KB)   RK05 disk (2.4MB)   17x capacity
Character encoding  9-bit/char        8-bit ASCII         Standards-based
Price               $72,000 (1965)    $10,800 (1970)      Much cheaper
Performance         ~1.75Œºs cycle     ~1.2Œºs cycle        Faster</code></pre>
<p>The PDP-11 represented a new generation of minicomputers. With its
orthogonal instruction set, general-purpose registers, and
byte-addressable memory, it was far more programmer-friendly than the
PDP-7.</p>
<h4 data-number="11.1.1.2" id="the-assembly-rewrite"><span class="header-section-number">11.1.1.2</span> The Assembly Rewrite</h4>
<p>In 1971, Thompson and Ritchie rewrote Unix entirely for the PDP-11.
This was not a simple port‚Äîit was a ground-up redesign that preserved
the concepts while improving the implementation.</p>
<p><strong>What Changed:</strong></p>
<ol type="1">
<li><strong>Byte-oriented architecture</strong>: Files measured in
bytes, not 18-bit words</li>
<li><strong>Larger address space</strong>: Full file system, multiple
simultaneous users</li>
<li><strong>Memory protection</strong>: Kernel/user separation via
PDP-11 MMU</li>
<li><strong>Improved I/O</strong>: Better device support, including RK05
disk</li>
<li><strong>Performance</strong>: Faster execution, more responsive
interaction</li>
</ol>
<p><strong>What Stayed the Same:</strong></p>
<ol type="1">
<li><strong>Hierarchical file system</strong>: Still based on inodes and
directory entries</li>
<li><strong>Process model</strong>: Fork/exec paradigm unchanged</li>
<li><strong>System call interface</strong>: Similar API, adapted to new
architecture</li>
<li><strong>Design philosophy</strong>: Simplicity, orthogonality, tool
composition</li>
<li><strong>Development tools</strong>: Editor, assembler, shell
preserved and enhanced</li>
</ol>
<p>The PDP-11 version became <strong>Unix Version 1 (V1)</strong>,
released internally at Bell Labs in November 1971. The famous
<strong>Unix Programmer‚Äôs Manual</strong> accompanied it‚Äîthe first
formal documentation of the system.</p>
<h4 data-number="11.1.1.3" id="industry-context-the-minicomputer-revolution"><span class="header-section-number">11.1.1.3</span> Industry Context: The
Minicomputer Revolution</h4>
<p>The timing was perfect. The early 1970s saw the <strong>minicomputer
revolution</strong>:</p>
<p><strong>The Market Shift:</strong> - <strong>1960s</strong>:
Computing dominated by mainframes (IBM, UNIVAC) -
<strong>1970s</strong>: Minicomputers democratize computing (DEC, Data
General, HP) - <strong>Cost reduction</strong>: From millions to tens of
thousands of dollars - <strong>Direct access</strong>: Interactive use
replacing batch processing - <strong>Departmental computing</strong>:
Each research group could own a computer</p>
<p>DEC‚Äôs PDP series led this revolution. Unix rode that wave, becoming
the operating system of choice for research and development. Where
mainframes ran proprietary operating systems tailored to commercial data
processing, minicomputers needed flexible systems for technical
computing‚Äîexactly Unix‚Äôs strength.</p>
<h3 data-number="11.1.2" id="the-invention-of-c-1972"><span class="header-section-number">11.1.2</span> The Invention of C
(1972)</h3>
<h4 data-number="11.1.2.1" id="why-a-new-language"><span class="header-section-number">11.1.2.1</span> Why a New Language?</h4>
<p>By 1972, Unix was running successfully on the PDP-11, but it had a
problem: it was written entirely in PDP-11 assembly language. Thompson
recognized that:</p>
<ol type="1">
<li><strong>Assembly was non-portable</strong>: Every new architecture
required complete rewrite</li>
<li><strong>Assembly was error-prone</strong>: No type checking, easy to
create bugs</li>
<li><strong>Assembly was hard to maintain</strong>: Difficult to
understand and modify</li>
<li><strong>Assembly was limiting</strong>: High-level abstractions
needed</li>
</ol>
<p>Thompson had already experimented with higher-level languages. In
1969, he had created <strong>B</strong>, an interpreted language based
on Martin Richards‚Äô <strong>BCPL</strong> (Basic Combined Programming
Language). B was elegant but had limitations:</p>
<p><strong>B Language Characteristics:</strong> -
<strong>Typeless</strong>: Everything was a word, no distinction between
pointers and integers - <strong>Interpreted</strong>: Slow execution via
bytecode interpreter - <strong>Word-oriented</strong>: Assumed word
addressing, not byte addressing - <strong>Compact</strong>: Could run in
small memory spaces</p>
<p>B worked on the word-addressed PDP-7 but struggled with the
byte-addressed PDP-11. The PDP-11 could address individual bytes, but B
treated everything as words.</p>
<h4 data-number="11.1.2.2" id="how-pdp-7-unix-influenced-cs-design"><span class="header-section-number">11.1.2.2</span> How PDP-7 Unix Influenced
C‚Äôs Design</h4>
<p>Dennis Ritchie took over B‚Äôs evolution, creating <strong>NB</strong>
(New B) and eventually <strong>C</strong>. The language was designed
specifically to write Unix:</p>
<p><strong>C‚Äôs Design Principles (Derived from Unix
Experience):</strong></p>
<ol type="1">
<li><strong>Close to the machine</strong>: Direct hardware access when
needed</li>
<li><strong>Efficient</strong>: Performance comparable to assembly</li>
<li><strong>Portable</strong>: Abstract enough to move between
architectures</li>
<li><strong>Systems-oriented</strong>: Support for low-level
operations</li>
<li><strong>Simple</strong>: Small language, easy to implement
compiler</li>
</ol>
<p><strong>Key C Features Driven by Unix Needs:</strong></p>
<div class="sourceCode" id="cb893"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb893-1"><a aria-hidden="true" href="#cb893-1" tabindex="-1"></a><span class="co">/* Pointers - direct memory access like assembly */</span></span>
<span id="cb893-2"><a aria-hidden="true" href="#cb893-2" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>ptr <span class="op">=</span> <span class="op">&amp;</span>buffer<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb893-3"><a aria-hidden="true" href="#cb893-3" tabindex="-1"></a><span class="op">*</span>ptr <span class="op">=</span> <span class="ch">'A'</span><span class="op">;</span></span>
<span id="cb893-4"><a aria-hidden="true" href="#cb893-4" tabindex="-1"></a></span>
<span id="cb893-5"><a aria-hidden="true" href="#cb893-5" tabindex="-1"></a><span class="co">/* Structures - organize kernel data structures */</span></span>
<span id="cb893-6"><a aria-hidden="true" href="#cb893-6" tabindex="-1"></a><span class="kw">struct</span> inode <span class="op">{</span></span>
<span id="cb893-7"><a aria-hidden="true" href="#cb893-7" tabindex="-1"></a>    <span class="dt">int</span> i_mode<span class="op">;</span>      <span class="co">/* file type and permissions */</span></span>
<span id="cb893-8"><a aria-hidden="true" href="#cb893-8" tabindex="-1"></a>    <span class="dt">char</span> i_nlink<span class="op">;</span>    <span class="co">/* number of links */</span></span>
<span id="cb893-9"><a aria-hidden="true" href="#cb893-9" tabindex="-1"></a>    <span class="dt">char</span> i_uid<span class="op">;</span>      <span class="co">/* user ID */</span></span>
<span id="cb893-10"><a aria-hidden="true" href="#cb893-10" tabindex="-1"></a>    <span class="dt">char</span> i_gid<span class="op">;</span>      <span class="co">/* group ID */</span></span>
<span id="cb893-11"><a aria-hidden="true" href="#cb893-11" tabindex="-1"></a>    <span class="dt">int</span> i_size0<span class="op">;</span>     <span class="co">/* size (high byte) */</span></span>
<span id="cb893-12"><a aria-hidden="true" href="#cb893-12" tabindex="-1"></a>    <span class="dt">int</span> i_size1<span class="op">;</span>     <span class="co">/* size (low bytes) */</span></span>
<span id="cb893-13"><a aria-hidden="true" href="#cb893-13" tabindex="-1"></a>    <span class="dt">int</span> i_addr<span class="op">[</span><span class="dv">8</span><span class="op">];</span>   <span class="co">/* block addresses */</span></span>
<span id="cb893-14"><a aria-hidden="true" href="#cb893-14" tabindex="-1"></a>    <span class="dt">int</span> i_atime<span class="op">[</span><span class="dv">2</span><span class="op">];</span>  <span class="co">/* access time */</span></span>
<span id="cb893-15"><a aria-hidden="true" href="#cb893-15" tabindex="-1"></a>    <span class="dt">int</span> i_mtime<span class="op">[</span><span class="dv">2</span><span class="op">];</span>  <span class="co">/* modification time */</span></span>
<span id="cb893-16"><a aria-hidden="true" href="#cb893-16" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb893-17"><a aria-hidden="true" href="#cb893-17" tabindex="-1"></a></span>
<span id="cb893-18"><a aria-hidden="true" href="#cb893-18" tabindex="-1"></a><span class="co">/* Bit manipulation - device register access */</span></span>
<span id="cb893-19"><a aria-hidden="true" href="#cb893-19" tabindex="-1"></a><span class="pp">#define DONE </span><span class="bn">0200</span><span class="pp">    </span><span class="co">/* device done bit */</span></span>
<span id="cb893-20"><a aria-hidden="true" href="#cb893-20" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>status <span class="op">&amp;</span> DONE<span class="op">)</span> <span class="op">{</span></span>
<span id="cb893-21"><a aria-hidden="true" href="#cb893-21" tabindex="-1"></a>    <span class="co">/* device ready */</span></span>
<span id="cb893-22"><a aria-hidden="true" href="#cb893-22" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb893-23"><a aria-hidden="true" href="#cb893-23" tabindex="-1"></a></span>
<span id="cb893-24"><a aria-hidden="true" href="#cb893-24" tabindex="-1"></a><span class="co">/* Low-level I/O - system call interface */</span></span>
<span id="cb893-25"><a aria-hidden="true" href="#cb893-25" tabindex="-1"></a><span class="dt">int</span> fd <span class="op">=</span> open<span class="op">(</span><span class="st">"/tmp/file"</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb893-26"><a aria-hidden="true" href="#cb893-26" tabindex="-1"></a>read<span class="op">(</span>fd<span class="op">,</span> buffer<span class="op">,</span> <span class="dv">512</span><span class="op">);</span></span>
<span id="cb893-27"><a aria-hidden="true" href="#cb893-27" tabindex="-1"></a>close<span class="op">(</span>fd<span class="op">);</span></span></code></pre></div>
<p>C gave programmers the <strong>power of assembly</strong> with the
<strong>abstraction of high-level languages</strong>. It was
revolutionary.</p>
<h4 data-number="11.1.2.3" id="the-portable-unix-rewrite-1973"><span class="header-section-number">11.1.2.3</span> The Portable Unix Rewrite
(1973)</h4>
<p>In 1973, Ritchie and Thompson made a bold decision: <strong>rewrite
Unix in C</strong>. This was unprecedented. Operating systems were
always written in assembly language. High-level languages were for
applications, not kernels.</p>
<p><strong>The Skeptics Said:</strong> - ‚ÄúToo slow‚Äîsystems need assembly
for performance‚Äù - ‚ÄúToo large‚Äîcompiled code will bloat the kernel‚Äù -
‚ÄúToo risky‚Äîunproven for systems programming‚Äù - ‚ÄúToo abstract‚Äîcan‚Äôt
access hardware from high-level language‚Äù</p>
<p><strong>Thompson and Ritchie Proved Them Wrong:</strong></p>
<p>The C rewrite succeeded brilliantly. By late 1973, <strong>Unix
Version 4</strong> was running in C. About 90% of the kernel was C, with
only the most hardware-dependent parts in assembly.</p>
<p><strong>The Results:</strong> - <strong>Performance</strong>: Nearly
as fast as assembly (clever compiler, efficient design) -
<strong>Size</strong>: Slightly larger but still compact -
<strong>Portability</strong>: Unix could move to new machines in months,
not years - <strong>Maintainability</strong>: Much easier to understand
and modify - <strong>Influence</strong>: Proved high-level languages
viable for systems programming</p>
<p><strong>Code Comparison - Same Function in Assembly
vs.¬†C:</strong></p>
<p>PDP-7 Assembly (from s8.s):</p>
<pre class="assembly"><code>" namei - convert pathname to inode
namei: 0
   lac u.namep
   dac t
   law dbuf
   dac t+1
1:
   lac t i
   sna
   jmp 2f
   lmq
   lac t i
   dac t+1 i
   isz t+1
   lac t i
   dac t+1 i
   isz t+1
   -3
   tad t+1
   dac t+1
   jmp 1b
2:
   " ... continued for many more lines</code></pre>
<p>Unix V6 C (1975):</p>
<div class="sourceCode" id="cb895"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb895-1"><a aria-hidden="true" href="#cb895-1" tabindex="-1"></a><span class="co">/* namei - convert pathname to inode */</span></span>
<span id="cb895-2"><a aria-hidden="true" href="#cb895-2" tabindex="-1"></a><span class="kw">struct</span> inode <span class="op">*</span>namei<span class="op">(</span>path<span class="op">)</span></span>
<span id="cb895-3"><a aria-hidden="true" href="#cb895-3" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>path<span class="op">;</span></span>
<span id="cb895-4"><a aria-hidden="true" href="#cb895-4" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb895-5"><a aria-hidden="true" href="#cb895-5" tabindex="-1"></a>    <span class="kw">struct</span> inode <span class="op">*</span>dp<span class="op">;</span></span>
<span id="cb895-6"><a aria-hidden="true" href="#cb895-6" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>cp<span class="op">;</span></span>
<span id="cb895-7"><a aria-hidden="true" href="#cb895-7" tabindex="-1"></a>    <span class="dt">int</span> c<span class="op">;</span></span>
<span id="cb895-8"><a aria-hidden="true" href="#cb895-8" tabindex="-1"></a></span>
<span id="cb895-9"><a aria-hidden="true" href="#cb895-9" tabindex="-1"></a>    dp <span class="op">=</span> rootdir<span class="op">;</span></span>
<span id="cb895-10"><a aria-hidden="true" href="#cb895-10" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>c <span class="op">=</span> <span class="op">*</span>path<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb895-11"><a aria-hidden="true" href="#cb895-11" tabindex="-1"></a>        <span class="co">/* search directory for component */</span></span>
<span id="cb895-12"><a aria-hidden="true" href="#cb895-12" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">((</span>c <span class="op">=</span> dirlook<span class="op">(</span>dp<span class="op">,</span> path<span class="op">))</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb895-13"><a aria-hidden="true" href="#cb895-13" tabindex="-1"></a>            <span class="cf">return</span> NULL<span class="op">;</span></span>
<span id="cb895-14"><a aria-hidden="true" href="#cb895-14" tabindex="-1"></a>        dp <span class="op">=</span> iget<span class="op">(</span>c<span class="op">);</span></span>
<span id="cb895-15"><a aria-hidden="true" href="#cb895-15" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb895-16"><a aria-hidden="true" href="#cb895-16" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">;</span></span>
<span id="cb895-17"><a aria-hidden="true" href="#cb895-17" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The difference is striking. The C version is <strong>readable,
maintainable, and portable</strong>. This single decision‚Äîwriting an OS
in a high-level language‚Äîchanged the industry forever.</p>
<h4 data-number="11.1.2.4" id="revolutionary-os-in-high-level-language"><span class="header-section-number">11.1.2.4</span> Revolutionary: OS in
High-Level Language</h4>
<p>The C rewrite made Unix <strong>portable</strong>. Instead of
supporting only PDP-11, Unix could run on:</p>
<p><strong>Early Ports:</strong> - <strong>Interdata 8/32</strong>
(1977) - First port to non-DEC hardware - <strong>IBM 360</strong>
(1977) - Mainframe Unix - <strong>VAX-11/780</strong> (1978) - 32-bit
Unix (Unix/32V)</p>
<p>Each port took months instead of years. The pattern was: 1. Port the
C compiler to new architecture 2. Recompile Unix kernel with new
compiler 3. Port small amount of assembly-language code 4. Debug and
optimize</p>
<p>This portability made Unix <strong>inevitable</strong>. Any computer
manufacturer wanting a modern OS could license Unix and have it running
quickly. The alternative‚Äîwriting an OS from scratch‚Äîtook years and cost
millions.</p>
<h3 data-number="11.1.3" id="research-unix-evolution-1971-1979"><span class="header-section-number">11.1.3</span> Research Unix Evolution
(1971-1979)</h3>
<p>The 1970s saw rapid Unix evolution at Bell Labs. Each
<strong>Research Unix</strong> version added features while maintaining
the core simplicity:</p>
<pre><code>Unix Version Timeline (Research Editions):

Version   Date      Key Features
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
V1        1971-11   First PDP-11 Unix
                    - Hierarchical file system
                    - fork() and exec()
                    - Basic shell
                    - ~4,500 lines of assembly

V2        1972-06   Multiple processes
                    - Improved file system
                    - Pipes (!!)
                    - More utilities

V3        1973-02   Mostly C rewrite begins
                    - C compiler included
                    - Improved shell (glob patterns)

V4        1973-11   First C-based Unix
                    - ~90% written in C
                    - Performance equal to assembly
                    - Pipes fully integrated

V5        1974-06   Widespread distribution begins
                    - Improved reliability
                    - More utilities
                    - Documentation improved

V6        1975-05   First widely distributed version
                    - ~9,000 lines of C kernel code
                    - "Lions' Commentary" based on V6
                    - Academic licenses available
                    - Source code to universities: $200

V7        1979-01   The classic Unix
                    - Bourne shell (sh)
                    - Awk, sed, make
                    - Improved file system
                    - Port to VAX (32-bit)
                    - "The Unix Programming Environment"
                    - Influenced POSIX standard</code></pre>
<h4 data-number="11.1.3.1" id="the-pipe-unixs-killer-feature"><span class="header-section-number">11.1.3.1</span> The Pipe: Unix‚Äôs Killer
Feature</h4>
<p><strong>Unix Version 2 (1972)</strong> introduced
<strong>pipes</strong>, one of the most influential features in
computing history:</p>
<div class="sourceCode" id="cb897"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb897-1"><a aria-hidden="true" href="#cb897-1" tabindex="-1"></a><span class="co"># List all .txt files, sort by name, show first 10</span></span>
<span id="cb897-2"><a aria-hidden="true" href="#cb897-2" tabindex="-1"></a><span class="fu">ls</span> <span class="pp">*</span>.txt <span class="kw">|</span> <span class="fu">sort</span> <span class="kw">|</span> <span class="fu">head</span> <span class="at">-10</span></span>
<span id="cb897-3"><a aria-hidden="true" href="#cb897-3" tabindex="-1"></a></span>
<span id="cb897-4"><a aria-hidden="true" href="#cb897-4" tabindex="-1"></a><span class="co"># Count unique error messages in log</span></span>
<span id="cb897-5"><a aria-hidden="true" href="#cb897-5" tabindex="-1"></a><span class="fu">grep</span> ERROR logfile <span class="kw">|</span> <span class="fu">sort</span> <span class="kw">|</span> <span class="fu">uniq</span> <span class="at">-c</span></span>
<span id="cb897-6"><a aria-hidden="true" href="#cb897-6" tabindex="-1"></a></span>
<span id="cb897-7"><a aria-hidden="true" href="#cb897-7" tabindex="-1"></a><span class="co"># Find largest files in directory tree</span></span>
<span id="cb897-8"><a aria-hidden="true" href="#cb897-8" tabindex="-1"></a><span class="fu">du</span> <span class="at">-a</span> <span class="kw">|</span> <span class="fu">sort</span> <span class="at">-n</span> <span class="kw">|</span> <span class="fu">tail</span> <span class="at">-20</span></span></code></pre></div>
<p><strong>Before pipes:</strong></p>
<div class="sourceCode" id="cb898"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb898-1"><a aria-hidden="true" href="#cb898-1" tabindex="-1"></a><span class="co"># Without pipes, you needed temporary files:</span></span>
<span id="cb898-2"><a aria-hidden="true" href="#cb898-2" tabindex="-1"></a><span class="fu">ls</span> <span class="op">&gt;</span> tempfile1</span>
<span id="cb898-3"><a aria-hidden="true" href="#cb898-3" tabindex="-1"></a><span class="fu">sort</span> tempfile1 <span class="op">&gt;</span> tempfile2</span>
<span id="cb898-4"><a aria-hidden="true" href="#cb898-4" tabindex="-1"></a><span class="fu">head</span> <span class="at">-10</span> tempfile2</span>
<span id="cb898-5"><a aria-hidden="true" href="#cb898-5" tabindex="-1"></a><span class="fu">rm</span> tempfile1 tempfile2</span></code></pre></div>
<p><strong>After pipes:</strong></p>
<div class="sourceCode" id="cb899"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb899-1"><a aria-hidden="true" href="#cb899-1" tabindex="-1"></a><span class="fu">ls</span> <span class="kw">|</span> <span class="fu">sort</span> <span class="kw">|</span> <span class="fu">head</span> <span class="at">-10</span></span></code></pre></div>
<p>Pipes embodied the Unix philosophy: <strong>small tools, composed
together, each doing one thing well</strong>. This simple idea
transformed how programmers think about building software.</p>
<p><strong>Pipe Implementation (Unix V6 C code):</strong></p>
<div class="sourceCode" id="cb900"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb900-1"><a aria-hidden="true" href="#cb900-1" tabindex="-1"></a><span class="co">/* Create a pipe - returns two file descriptors */</span></span>
<span id="cb900-2"><a aria-hidden="true" href="#cb900-2" tabindex="-1"></a>pipe<span class="op">()</span></span>
<span id="cb900-3"><a aria-hidden="true" href="#cb900-3" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb900-4"><a aria-hidden="true" href="#cb900-4" tabindex="-1"></a>    <span class="kw">struct</span> inode <span class="op">*</span>ip<span class="op">;</span></span>
<span id="cb900-5"><a aria-hidden="true" href="#cb900-5" tabindex="-1"></a>    <span class="dt">int</span> r<span class="op">[</span><span class="dv">2</span><span class="op">];</span>     <span class="co">/* reader and writer file descriptors */</span></span>
<span id="cb900-6"><a aria-hidden="true" href="#cb900-6" tabindex="-1"></a></span>
<span id="cb900-7"><a aria-hidden="true" href="#cb900-7" tabindex="-1"></a>    ip <span class="op">=</span> ialloc<span class="op">();</span>           <span class="co">/* allocate inode for pipe */</span></span>
<span id="cb900-8"><a aria-hidden="true" href="#cb900-8" tabindex="-1"></a>    ip<span class="op">-&gt;</span>i_mode <span class="op">=</span> IPIPE<span class="op">;</span>      <span class="co">/* mark as pipe */</span></span>
<span id="cb900-9"><a aria-hidden="true" href="#cb900-9" tabindex="-1"></a>    r<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> ufalloc<span class="op">();</span>        <span class="co">/* allocate reader fd */</span></span>
<span id="cb900-10"><a aria-hidden="true" href="#cb900-10" tabindex="-1"></a>    u<span class="op">.</span>u_ofile<span class="op">[</span>r<span class="op">[</span><span class="dv">0</span><span class="op">]]</span> <span class="op">=</span> ip<span class="op">;</span>    <span class="co">/* connect to inode */</span></span>
<span id="cb900-11"><a aria-hidden="true" href="#cb900-11" tabindex="-1"></a>    r<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> ufalloc<span class="op">();</span>        <span class="co">/* allocate writer fd */</span></span>
<span id="cb900-12"><a aria-hidden="true" href="#cb900-12" tabindex="-1"></a>    u<span class="op">.</span>u_ofile<span class="op">[</span>r<span class="op">[</span><span class="dv">1</span><span class="op">]]</span> <span class="op">=</span> ip<span class="op">;</span>    <span class="co">/* connect to inode */</span></span>
<span id="cb900-13"><a aria-hidden="true" href="#cb900-13" tabindex="-1"></a></span>
<span id="cb900-14"><a aria-hidden="true" href="#cb900-14" tabindex="-1"></a>    u<span class="op">.</span>u_ar0<span class="op">[</span>R0<span class="op">]</span> <span class="op">=</span> r<span class="op">[</span><span class="dv">0</span><span class="op">];</span>      <span class="co">/* return reader */</span></span>
<span id="cb900-15"><a aria-hidden="true" href="#cb900-15" tabindex="-1"></a>    u<span class="op">.</span>u_ar0<span class="op">[</span>R1<span class="op">]</span> <span class="op">=</span> r<span class="op">[</span><span class="dv">1</span><span class="op">];</span>      <span class="co">/* return writer */</span></span>
<span id="cb900-16"><a aria-hidden="true" href="#cb900-16" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Compare to PDP-7 Unix, which had <strong>message passing</strong>
(smes/rmes) but not pipes. Pipes were the evolution of that idea into
something more general and powerful.</p>
<h4 data-number="11.1.3.2" id="the-programmers-workbench"><span class="header-section-number">11.1.3.2</span> The Programmer‚Äôs
Workbench</h4>
<p>Unix became the preferred environment for software development. By
the mid-1970s, Bell Labs researchers were using Unix for all their work.
The <strong>Programmer‚Äôs Workbench (PWB)</strong> variant of Unix
added:</p>
<ul>
<li><strong>Source Code Control System (SCCS)</strong>: Version
control</li>
<li><strong>Make</strong>: Automated builds</li>
<li><strong>Lex and Yacc</strong>: Parser generators</li>
<li><strong>Lint</strong>: C code checker</li>
<li><strong>Prof</strong>: Performance profiler</li>
</ul>
<p>These tools set the standard for software development environments
that persists today.</p>
<h4 data-number="11.1.3.3" id="spreading-through-academia"><span class="header-section-number">11.1.3.3</span> Spreading Through
Academia</h4>
<p><strong>Unix Version 6 (1975)</strong> became widely available to
universities through <strong>academic licenses</strong>. For $200, a
university could get: - Complete source code - Documentation - Right to
modify and share among universities</p>
<p>This openness was revolutionary. Students and researchers could: -
<strong>Study the code</strong>: Learn OS internals from real
implementation - <strong>Modify the system</strong>: Experiment with new
ideas - <strong>Share improvements</strong>: Collaborate across
universities</p>
<p><strong>John Lions‚Äô Commentary on Unix V6</strong> (1977) became the
most photocopied computer science text in history. It presented the
entire Unix kernel with line-by-line commentary‚Äîa complete education in
operating systems.</p>
<p><strong>Impact on Computer Science Education:</strong></p>
<p>Universities using Unix by 1979: - University of California, Berkeley
- MIT - Carnegie Mellon - Stanford - Harvard - University of Toronto -
University of New South Wales (Australia) - And hundreds more‚Ä¶</p>
<p>An entire generation of computer scientists learned operating systems
by reading and modifying Unix code. When they graduated, they brought
Unix philosophy to industry.</p>
<h2 data-number="11.2" id="the-unix-family-tree"><span class="header-section-number">11.2</span> 14.2 The Unix Family Tree</h2>
<p>Unix didn‚Äôt evolve linearly‚Äîit branched into a rich family tree. Two
main branches dominated: <strong>BSD Unix</strong> (academic, open) and
<strong>System V</strong> (commercial, standardized).</p>
<pre><code>                        The Unix Family Tree

                    PDP-7 Unix (1969)
                           |
                    PDP-11 Unix (1971)
                           |
                    Research Unix V1-V7
                    /                  \
                   /                    \
          BSD Unix (1977)          System V (1983)
         /    |     \                    |
        /     |      \                   |
   FreeBSD OpenBSD NetBSD           SVR4 (1988)
      |       |       |              /   |   \
   Darwin  Security  Embedded    Solaris AIX HP-UX
      |
   macOS/iOS
      |
   2+ billion                         Linux (1991)
   devices                               |
                                    Everywhere
                                    (servers, Android,
                                     embedded, cloud)</code></pre>
<h3 data-number="11.2.1" id="bsd-unix-1977-1995"><span class="header-section-number">11.2.1</span> BSD Unix (1977-1995)</h3>
<h4 data-number="11.2.1.1" id="uc-berkeleys-contributions"><span class="header-section-number">11.2.1.1</span> UC Berkeley‚Äôs
Contributions</h4>
<p>The <strong>Berkeley Software Distribution</strong> began in 1977
when graduate student <strong>Bill Joy</strong> started distributing
Unix enhancements from UC Berkeley. BSD became the most influential Unix
variant, introducing:</p>
<p><strong>Major BSD Innovations:</strong></p>
<p><strong>1. Networking (1983)</strong> - TCP/IP Implementation</p>
<div class="sourceCode" id="cb902"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb902-1"><a aria-hidden="true" href="#cb902-1" tabindex="-1"></a><span class="co">/* BSD socket API - became the standard for network programming */</span></span>
<span id="cb902-2"><a aria-hidden="true" href="#cb902-2" tabindex="-1"></a><span class="dt">int</span> sockfd <span class="op">=</span> socket<span class="op">(</span>AF_INET<span class="op">,</span> SOCK_STREAM<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb902-3"><a aria-hidden="true" href="#cb902-3" tabindex="-1"></a><span class="kw">struct</span> sockaddr_in addr<span class="op">;</span></span>
<span id="cb902-4"><a aria-hidden="true" href="#cb902-4" tabindex="-1"></a>addr<span class="op">.</span>sin_family <span class="op">=</span> AF_INET<span class="op">;</span></span>
<span id="cb902-5"><a aria-hidden="true" href="#cb902-5" tabindex="-1"></a>addr<span class="op">.</span>sin_port <span class="op">=</span> htons<span class="op">(</span><span class="dv">80</span><span class="op">);</span></span>
<span id="cb902-6"><a aria-hidden="true" href="#cb902-6" tabindex="-1"></a>addr<span class="op">.</span>sin_addr<span class="op">.</span>s_addr <span class="op">=</span> inet_addr<span class="op">(</span><span class="st">"192.168.1.1"</span><span class="op">);</span></span>
<span id="cb902-7"><a aria-hidden="true" href="#cb902-7" tabindex="-1"></a>connect<span class="op">(</span>sockfd<span class="op">,</span> <span class="op">(</span><span class="kw">struct</span> sockaddr<span class="op">*)&amp;</span>addr<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>addr<span class="op">));</span></span></code></pre></div>
<p>The BSD socket API became the universal interface for network
programming, used in every modern OS.</p>
<p><strong>2. Virtual Memory (1980)</strong> - 4.1BSD - Demand paging:
Load code only when needed - Memory-mapped files: Access files as memory
- Copy-on-write fork(): Efficient process creation</p>
<p><strong>3. Job Control (1978)</strong> - Background/foreground
processes</p>
<div class="sourceCode" id="cb903"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb903-1"><a aria-hidden="true" href="#cb903-1" tabindex="-1"></a><span class="co"># Run command in background</span></span>
<span id="cb903-2"><a aria-hidden="true" href="#cb903-2" tabindex="-1"></a><span class="ex">$</span> long_process <span class="kw">&amp;</span></span>
<span id="cb903-3"><a aria-hidden="true" href="#cb903-3" tabindex="-1"></a><span class="ex">[1]</span> 1234</span>
<span id="cb903-4"><a aria-hidden="true" href="#cb903-4" tabindex="-1"></a></span>
<span id="cb903-5"><a aria-hidden="true" href="#cb903-5" tabindex="-1"></a><span class="co"># Suspend current job</span></span>
<span id="cb903-6"><a aria-hidden="true" href="#cb903-6" tabindex="-1"></a><span class="ex">$</span> ^Z</span>
<span id="cb903-7"><a aria-hidden="true" href="#cb903-7" tabindex="-1"></a><span class="ex">[1]+</span>  Stopped    long_process</span>
<span id="cb903-8"><a aria-hidden="true" href="#cb903-8" tabindex="-1"></a></span>
<span id="cb903-9"><a aria-hidden="true" href="#cb903-9" tabindex="-1"></a><span class="co"># Resume in foreground</span></span>
<span id="cb903-10"><a aria-hidden="true" href="#cb903-10" tabindex="-1"></a><span class="ex">$</span> fg</span>
<span id="cb903-11"><a aria-hidden="true" href="#cb903-11" tabindex="-1"></a><span class="ex">long_process</span></span></code></pre></div>
<p><strong>4. C Shell (csh)</strong> - Bill Joy, 1978 - History
mechanism: <code>!command</code> - Aliases:
<code>alias ll='ls -l'</code> - Job control built-in - C-like syntax</p>
<p><strong>5. Vi Editor</strong> - Bill Joy, 1976</p>
<pre><code>Still used today (vim, neovim)
Influenced: Emacs keybindings, modern editors</code></pre>
<p><strong>6. Fast File System</strong> - McKusick, 1983 - Cylinder
groups: Cluster related data - Larger block sizes: Better performance -
Symbolic links: Flexible file references</p>
<h4 data-number="11.2.1.2" id="the-berkeley-software-distribution-legacy"><span class="header-section-number">11.2.1.2</span> The Berkeley Software
Distribution Legacy</h4>
<p>BSD releases transformed Unix from research project to production
system:</p>
<pre><code>BSD Release History:

Version   Date      Significance
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1BSD      1977      Pascal system, ex editor
2BSD      1978      C shell, vi editor, job control
3BSD      1979      Virtual memory support
4.0BSD    1980      Rewritten virtual memory system
4.1BSD    1981      Performance improvements
4.2BSD    1983      TCP/IP networking, Fast File System
4.3BSD    1986      Improved performance, stability
4.4BSD    1993      Final release, fully free code</code></pre>
<p><strong>BSD‚Äôs Commercial Impact:</strong></p>
<p>Companies built on BSD: - <strong>Sun Microsystems</strong> (SunOS):
Workstation revolution - <strong>DEC</strong> (Ultrix): VAX Unix -
<strong>Microsoft</strong> (Xenix): Yes, Microsoft sold Unix! -
<strong>NeXT</strong> (NeXTSTEP): Steve Jobs‚Äô company -
<strong>Apple</strong> (Darwin/macOS): BSD-based OS</p>
<h3 data-number="11.2.2" id="system-v-1983-1992"><span class="header-section-number">11.2.2</span> System V (1983-1992)</h3>
<h4 data-number="11.2.2.1" id="atts-commercial-unix"><span class="header-section-number">11.2.2.1</span> AT&amp;T‚Äôs Commercial
Unix</h4>
<p>While BSD flourished in academia, AT&amp;T developed <strong>Unix
System V</strong> as a commercial product:</p>
<p><strong>System V Release History:</strong></p>
<pre><code>SVR1    1983    First commercial release
SVR2    1984    Improved utilities, security
SVR3    1987    STREAMS, TLI networking
SVR4    1988    Unified BSD + System V features
                (Solaris, AIX, HP-UX based on SVR4)</code></pre>
<p><strong>System V Contributions:</strong></p>
<ol type="1">
<li><strong>STREAMS</strong>: Modular I/O system</li>
<li><strong>Shared libraries</strong>: Reduce memory usage</li>
<li><strong>TLI (Transport Layer Interface)</strong>: Alternative to
sockets</li>
<li><strong>Vi improvements</strong>: Enhanced vi editor</li>
<li><strong>System administration</strong>: sysadm, admin tools</li>
</ol>
<h4 data-number="11.2.2.2" id="the-unix-wars-1988-1993"><span class="header-section-number">11.2.2.2</span> The ‚ÄúUnix Wars‚Äù
(1988-1993)</h4>
<p>The late 1980s saw the <strong>Unix Wars</strong>‚Äîcompeting
standards, incompatible versions, fragmentation:</p>
<p><strong>The Conflict:</strong> - <strong>AT&amp;T</strong>: System V,
commercial licensing - <strong>Berkeley</strong>: BSD, academic/free -
<strong>Vendors</strong>: Each with proprietary extensions -
<strong>Result</strong>: Incompatible Unix versions, customer
confusion</p>
<p><strong>Standard Battles:</strong> - <strong>POSIX</strong> (IEEE):
Attempted portable OS interface - <strong>X/Open</strong>: Vendor
consortium for standards - <strong>OSF/1</strong> (Open Software
Foundation): Anti-AT&amp;T consortium - <strong>UI</strong> (Unix
International): Pro-AT&amp;T consortium</p>
<p>The wars hurt Unix commercially. Customers didn‚Äôt know which Unix to
choose. Microsoft capitalized on this confusion, promoting Windows NT as
a stable alternative.</p>
<h4 data-number="11.2.2.3" id="svr4-the-unification-1988"><span class="header-section-number">11.2.2.3</span> SVR4: The Unification
(1988)</h4>
<p><strong>System V Release 4</strong> attempted to end the wars by
unifying BSD and System V:</p>
<p><strong>SVR4 Merged:</strong> - System V base - BSD networking
(TCP/IP, sockets) - BSD file system features - SunOS features - Xenix
features</p>
<p><strong>Major SVR4 Descendants:</strong> - <strong>Solaris</strong>
(Sun Microsystems): Dominant commercial Unix - <strong>AIX</strong>
(IBM): Mainframe and server Unix - <strong>HP-UX</strong>
(Hewlett-Packard): Enterprise Unix - <strong>IRIX</strong> (Silicon
Graphics): Graphics workstation OS</p>
<p>These commercial Unix systems powered the internet boom of the 1990s
and still run critical enterprise systems today.</p>
<h3 data-number="11.2.3" id="the-open-source-revolution"><span class="header-section-number">11.2.3</span> The Open Source
Revolution</h3>
<p>While commercial Unix fragmented, a new movement emerged:
<strong>free, open-source Unix</strong>.</p>
<h4 data-number="11.2.3.1" id="linux-1991-present"><span class="header-section-number">11.2.3.1</span> Linux (1991-present)</h4>
<p>In 1991, a Finnish computer science student named <strong>Linus
Torvalds</strong> posted to comp.os.minix newsgroup:</p>
<blockquote>
<p><em>‚ÄúI‚Äôm doing a (free) operating system (just a hobby, won‚Äôt be big
and professional like gnu) for 386(486) AT clones.‚Äù</em></p>
</blockquote>
<p>That ‚Äúhobby‚Äù became <strong>Linux</strong>, the most successful
software project in history.</p>
<p><strong>Linux Timeline:</strong></p>
<pre><code>1991-08   Linus announces Linux 0.01
          - 10,000 lines of C code
          - Runs on i386
          - Basic process management, file system

1991-10   Linux 0.02 released
          - Can run bash and gcc
          - GPL licensed

1992      First Linux distributions
          - MCC Interim
          - Softlanding Linux System (SLS)

1993      Slackware, Debian founded
          - Package management
          - Easier installation

1994      Linux 1.0 released
          - 176,250 lines of code
          - Stable, production-ready

1996      Linux 2.0
          - SMP (multiple CPUs)
          - 64-bit architectures

1998      Enterprise adoption begins
          - Oracle, IBM support Linux
          - Major companies migrate

2001      Linux 2.4
          - Enterprise features
          - Improved scalability

2011      Linux 3.0
          - ~15 million lines of code

2025      Linux 6.x
          - ~30+ million lines of code
          - Powers most of the internet</code></pre>
<p><strong>Why Linux Succeeded:</strong></p>
<ol type="1">
<li><strong>Free</strong>: $0 cost, no licensing restrictions</li>
<li><strong>Open source</strong>: Complete source code available</li>
<li><strong>Unix-compatible</strong>: Familiar to Unix users</li>
<li><strong>PC-based</strong>: Ran on inexpensive x86 hardware</li>
<li><strong>Internet-ready</strong>: Perfect timing for web era</li>
<li><strong>Community-driven</strong>: Thousands of contributors</li>
<li><strong>Vendor-neutral</strong>: Not controlled by one company</li>
</ol>
<h4 data-number="11.2.3.2" id="how-pdp-7-concepts-survive-in-linux"><span class="header-section-number">11.2.3.2</span> How PDP-7 Concepts Survive
in Linux</h4>
<p>Despite 30+ million lines of modern code, Linux preserves PDP-7
Unix‚Äôs core concepts:</p>
<p><strong>1. File System Structure</strong></p>
<p>PDP-7 Unix (1969):</p>
<pre class="assembly"><code>" inode structure (from s8.s)
" i.flgs:  flags (directory, special file, etc.)
" i.nlks:  number of links
" i.uid:   user id
" i.size:  size in words
" i.addr:  block addresses (8 words)
" i.actime: access time
" i.modtime: modification time</code></pre>
<p>Linux (2025):</p>
<div class="sourceCode" id="cb909"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb909-1"><a aria-hidden="true" href="#cb909-1" tabindex="-1"></a><span class="co">/* include/linux/fs.h */</span></span>
<span id="cb909-2"><a aria-hidden="true" href="#cb909-2" tabindex="-1"></a><span class="kw">struct</span> inode <span class="op">{</span></span>
<span id="cb909-3"><a aria-hidden="true" href="#cb909-3" tabindex="-1"></a>    umode_t         i_mode<span class="op">;</span>      <span class="co">/* file type and permissions */</span></span>
<span id="cb909-4"><a aria-hidden="true" href="#cb909-4" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">short</span>  i_opflags<span class="op">;</span>   <span class="co">/* flags */</span></span>
<span id="cb909-5"><a aria-hidden="true" href="#cb909-5" tabindex="-1"></a>    kuid_t          i_uid<span class="op">;</span>       <span class="co">/* user id */</span></span>
<span id="cb909-6"><a aria-hidden="true" href="#cb909-6" tabindex="-1"></a>    kgid_t          i_gid<span class="op">;</span>       <span class="co">/* group id */</span></span>
<span id="cb909-7"><a aria-hidden="true" href="#cb909-7" tabindex="-1"></a>    <span class="dt">unsigned</span> <span class="dt">int</span>    i_flags<span class="op">;</span>     <span class="co">/* filesystem flags */</span></span>
<span id="cb909-8"><a aria-hidden="true" href="#cb909-8" tabindex="-1"></a>    loff_t          i_size<span class="op">;</span>      <span class="co">/* file size in bytes */</span></span>
<span id="cb909-9"><a aria-hidden="true" href="#cb909-9" tabindex="-1"></a>    <span class="kw">struct</span> timespec i_atime<span class="op">;</span>     <span class="co">/* access time */</span></span>
<span id="cb909-10"><a aria-hidden="true" href="#cb909-10" tabindex="-1"></a>    <span class="kw">struct</span> timespec i_mtime<span class="op">;</span>     <span class="co">/* modification time */</span></span>
<span id="cb909-11"><a aria-hidden="true" href="#cb909-11" tabindex="-1"></a>    <span class="kw">struct</span> timespec i_ctime<span class="op">;</span>     <span class="co">/* change time */</span></span>
<span id="cb909-12"><a aria-hidden="true" href="#cb909-12" tabindex="-1"></a>    <span class="kw">union</span> <span class="op">{</span></span>
<span id="cb909-13"><a aria-hidden="true" href="#cb909-13" tabindex="-1"></a>        <span class="kw">struct</span> block_device <span class="op">*</span>i_bdev<span class="op">;</span>  <span class="co">/* block device */</span></span>
<span id="cb909-14"><a aria-hidden="true" href="#cb909-14" tabindex="-1"></a>        <span class="kw">struct</span> cdev <span class="op">*</span>i_cdev<span class="op">;</span>          <span class="co">/* character device */</span></span>
<span id="cb909-15"><a aria-hidden="true" href="#cb909-15" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb909-16"><a aria-hidden="true" href="#cb909-16" tabindex="-1"></a>    <span class="co">/* ... many more fields for modern features */</span></span>
<span id="cb909-17"><a aria-hidden="true" href="#cb909-17" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p><strong>The continuity is remarkable</strong>: 55+ years later, Linux
still uses inodes with user IDs, sizes, timestamps, and block addresses.
The structure grew larger, but the core concept is Thompson‚Äôs PDP-7
design.</p>
<p><strong>2. Process Fork Model</strong></p>
<p>PDP-7 Unix (1969):</p>
<pre class="assembly"><code>.fork:
   jms lookfor; 0      " find empty process slot
      skp
      jms error         " error if no slot
   dac 9f+t
   isz uniqpid          " increment unique process ID
   lac uniqpid
   dac u.ac             " store as child's PID
   " ... copy parent's memory
   " ... set up child's state</code></pre>
<p>Linux (2025):</p>
<div class="sourceCode" id="cb911"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb911-1"><a aria-hidden="true" href="#cb911-1" tabindex="-1"></a><span class="co">/* kernel/fork.c - simplified */</span></span>
<span id="cb911-2"><a aria-hidden="true" href="#cb911-2" tabindex="-1"></a><span class="dt">long</span> do_fork<span class="op">(</span><span class="dt">unsigned</span> <span class="dt">long</span> clone_flags<span class="op">,</span></span>
<span id="cb911-3"><a aria-hidden="true" href="#cb911-3" tabindex="-1"></a>             <span class="dt">unsigned</span> <span class="dt">long</span> stack_start<span class="op">,</span></span>
<span id="cb911-4"><a aria-hidden="true" href="#cb911-4" tabindex="-1"></a>             <span class="dt">unsigned</span> <span class="dt">long</span> stack_size<span class="op">,</span></span>
<span id="cb911-5"><a aria-hidden="true" href="#cb911-5" tabindex="-1"></a>             <span class="dt">int</span> __user <span class="op">*</span>parent_tidptr<span class="op">,</span></span>
<span id="cb911-6"><a aria-hidden="true" href="#cb911-6" tabindex="-1"></a>             <span class="dt">int</span> __user <span class="op">*</span>child_tidptr<span class="op">)</span></span>
<span id="cb911-7"><a aria-hidden="true" href="#cb911-7" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb911-8"><a aria-hidden="true" href="#cb911-8" tabindex="-1"></a>    <span class="kw">struct</span> task_struct <span class="op">*</span>p<span class="op">;</span></span>
<span id="cb911-9"><a aria-hidden="true" href="#cb911-9" tabindex="-1"></a>    <span class="dt">int</span> pid<span class="op">;</span></span>
<span id="cb911-10"><a aria-hidden="true" href="#cb911-10" tabindex="-1"></a></span>
<span id="cb911-11"><a aria-hidden="true" href="#cb911-11" tabindex="-1"></a>    <span class="co">/* Allocate new process descriptor */</span></span>
<span id="cb911-12"><a aria-hidden="true" href="#cb911-12" tabindex="-1"></a>    p <span class="op">=</span> copy_process<span class="op">(</span>clone_flags<span class="op">,</span> stack_start<span class="op">,</span> stack_size<span class="op">,</span></span>
<span id="cb911-13"><a aria-hidden="true" href="#cb911-13" tabindex="-1"></a>                     parent_tidptr<span class="op">,</span> child_tidptr<span class="op">);</span></span>
<span id="cb911-14"><a aria-hidden="true" href="#cb911-14" tabindex="-1"></a></span>
<span id="cb911-15"><a aria-hidden="true" href="#cb911-15" tabindex="-1"></a>    <span class="co">/* Assign PID */</span></span>
<span id="cb911-16"><a aria-hidden="true" href="#cb911-16" tabindex="-1"></a>    pid <span class="op">=</span> get_task_pid<span class="op">(</span>p<span class="op">,</span> PIDTYPE_PID<span class="op">);</span></span>
<span id="cb911-17"><a aria-hidden="true" href="#cb911-17" tabindex="-1"></a></span>
<span id="cb911-18"><a aria-hidden="true" href="#cb911-18" tabindex="-1"></a>    <span class="co">/* Wake up new process */</span></span>
<span id="cb911-19"><a aria-hidden="true" href="#cb911-19" tabindex="-1"></a>    wake_up_new_task<span class="op">(</span>p<span class="op">);</span></span>
<span id="cb911-20"><a aria-hidden="true" href="#cb911-20" tabindex="-1"></a></span>
<span id="cb911-21"><a aria-hidden="true" href="#cb911-21" tabindex="-1"></a>    <span class="cf">return</span> pid<span class="op">;</span></span>
<span id="cb911-22"><a aria-hidden="true" href="#cb911-22" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Same fundamental idea: allocate process structure, assign PID, copy
parent state, return to both parent and child. Linux‚Äôs version handles
threads, namespaces, and modern features, but the core fork() model is
unchanged from 1969.</p>
<p><strong>3. System Calls</strong></p>
<p>PDP-7 Unix had 26 system calls:</p>
<pre><code>0 = rele (release held core)
1 = fork (create process)
2 = read (read file)
3 = write (write file)
4 = open (open file)
5 = close (close file)
6 = wait (wait for child)
7 = creat (create file)
... (18 more)</code></pre>
<p>Linux (2025) has 300+ system calls, but the original 26 are still
there:</p>
<div class="sourceCode" id="cb913"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb913-1"><a aria-hidden="true" href="#cb913-1" tabindex="-1"></a><span class="co">/* arch/x86/entry/syscalls/syscall_64.tbl */</span></span>
<span id="cb913-2"><a aria-hidden="true" href="#cb913-2" tabindex="-1"></a><span class="dv">0</span>   read    sys_read           <span class="co">/* PDP-7: sys read */</span></span>
<span id="cb913-3"><a aria-hidden="true" href="#cb913-3" tabindex="-1"></a><span class="dv">1</span>   write   sys_write          <span class="co">/* PDP-7: sys write */</span></span>
<span id="cb913-4"><a aria-hidden="true" href="#cb913-4" tabindex="-1"></a><span class="dv">2</span>   open    sys_open           <span class="co">/* PDP-7: sys open */</span></span>
<span id="cb913-5"><a aria-hidden="true" href="#cb913-5" tabindex="-1"></a><span class="dv">3</span>   close   sys_close          <span class="co">/* PDP-7: sys close */</span></span>
<span id="cb913-6"><a aria-hidden="true" href="#cb913-6" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb913-7"><a aria-hidden="true" href="#cb913-7" tabindex="-1"></a><span class="dv">57</span>  fork    sys_fork           <span class="co">/* PDP-7: sys fork */</span></span></code></pre></div>
<p><strong>Same names, same numbers (mostly), same behavior</strong>.
Code written for Unix V6 (1975) can still compile and run on Linux
(2025) with minimal changes.</p>
<p><strong>4. ‚ÄúEverything is a File‚Äù</strong></p>
<p>PDP-7 Unix treated devices as files:</p>
<pre class="assembly"><code>" Read from file or device - same interface
lac u.fofp      " get file descriptor
" ... read from file or device based on inode flags</code></pre>
<p>Linux (2025):</p>
<div class="sourceCode" id="cb915"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb915-1"><a aria-hidden="true" href="#cb915-1" tabindex="-1"></a><span class="co"># Still true 55+ years later:</span></span>
<span id="cb915-2"><a aria-hidden="true" href="#cb915-2" tabindex="-1"></a><span class="ex">$</span> cat /dev/urandom <span class="kw">|</span> <span class="fu">head</span> <span class="at">-c</span> 16 <span class="kw">|</span> <span class="ex">xxd</span></span>
<span id="cb915-3"><a aria-hidden="true" href="#cb915-3" tabindex="-1"></a><span class="ex">00000000:</span> 8f3a 2e91 c872 b54a 9c0d e8f3 2a11 5ac7  .:...r.J....<span class="pp">*</span>.Z.</span>
<span id="cb915-4"><a aria-hidden="true" href="#cb915-4" tabindex="-1"></a></span>
<span id="cb915-5"><a aria-hidden="true" href="#cb915-5" tabindex="-1"></a><span class="ex">$</span> echo <span class="st">"test"</span> <span class="op">&gt;</span> /dev/null   <span class="co"># Null device, like PDP-7</span></span>
<span id="cb915-6"><a aria-hidden="true" href="#cb915-6" tabindex="-1"></a></span>
<span id="cb915-7"><a aria-hidden="true" href="#cb915-7" tabindex="-1"></a><span class="ex">$</span> cat /proc/cpuinfo          <span class="co"># Even /proc is a file!</span></span></code></pre></div>
<h4 data-number="11.2.3.3" id="bsd-descendants-the-bsd-license-legacy"><span class="header-section-number">11.2.3.3</span> BSD Descendants: The BSD
License Legacy</h4>
<p>While Linux used GPL, the BSD family used the <strong>BSD
license</strong> (later ISC, MIT-style licenses):</p>
<p><strong>BSD License:</strong></p>
<pre><code>Permission is granted to use, copy, modify, and distribute this software
for any purpose with or without fee, provided that the above copyright
notice and this permission notice appear in all copies.</code></pre>
<p>This permissive license allowed <strong>commercial use without
restrictions</strong>. Companies could take BSD code, modify it, and
ship proprietary products. This strategy led to massive BSD
adoption:</p>
<p><strong>FreeBSD (1993-present)</strong> - Focus: Performance,
advanced networking - Users: Netflix, WhatsApp, Sony PlayStation -
Impact: Powers massive CDN infrastructure</p>
<p><strong>OpenBSD (1996-present)</strong> - Focus: Security, code
correctness - Contributions: OpenSSH (universal), LibreSSL, httpd -
Philosophy: ‚ÄúOnly two remote holes in the default install, in a heck of
a long time!‚Äù</p>
<p><strong>NetBSD (1993-present)</strong> - Focus: Portability -
Platforms: 57+ different architectures - Motto: ‚ÄúOf course it runs
NetBSD‚Äù</p>
<p><strong>Darwin/macOS (2000-present)</strong> - Apple‚Äôs BSD-based OS -
XNU kernel: Mach + BSD - Unified iOS, macOS, tvOS, watchOS - <strong>2+
billion active devices</strong></p>
<h3 data-number="11.2.4" id="the-mobile-era-unix-in-your-pocket"><span class="header-section-number">11.2.4</span> The Mobile Era: Unix in Your
Pocket</h3>
<p>The 2000s brought Unix to mobile devices:</p>
<p><strong>iOS (2007)</strong></p>
<pre><code>Based on: Darwin (BSD-derived)
Kernel: XNU (Mach microkernel + BSD)
Devices: iPhone, iPad, Apple Watch, Apple TV
Market: 2+ billion active devices
Unix concepts: Processes, file system, security model</code></pre>
<p><strong>Android (2008)</strong></p>
<pre><code>Based on: Linux kernel
Userland: Modified GNU/Linux tools + Dalvik/ART
Devices: Smartphones, tablets, TVs, cars
Market: 3+ billion active devices
Unix concepts: Full Linux kernel with mobile optimizations</code></pre>
<p><strong>The Numbers:</strong> - <strong>5+ billion
smartphones</strong> run Unix-derived operating systems - Every iPhone
traces ancestry to PDP-7 Unix via BSD - Every Android traces ancestry to
PDP-7 Unix via Linux - <strong>Every smartphone user is a Unix
user</strong></p>
<h2 data-number="11.3" id="unix-concepts-in-modern-systems"><span class="header-section-number">11.3</span> 14.3 Unix Concepts in Modern
Systems</h2>
<h3 data-number="11.3.1" id="ubiquitous-ideas-from-pdp-7-unix"><span class="header-section-number">11.3.1</span> Ubiquitous Ideas from PDP-7
Unix</h3>
<p>Some PDP-7 concepts are so fundamental they appear in every modern
OS:</p>
<h4 data-number="11.3.1.1" id="hierarchical-file-system-1"><span class="header-section-number">11.3.1.1</span> 1. Hierarchical File
System</h4>
<p><strong>PDP-7 Unix (1969):</strong></p>
<pre><code>/
‚îú‚îÄ‚îÄ bin/      (binaries)
‚îú‚îÄ‚îÄ dev/      (devices)
‚îú‚îÄ‚îÄ etc/      (configuration)
‚îú‚îÄ‚îÄ tmp/      (temporary)
‚îî‚îÄ‚îÄ usr/      (user files)</code></pre>
<p><strong>Linux/macOS (2025):</strong></p>
<pre><code>/
‚îú‚îÄ‚îÄ bin/      (binaries)
‚îú‚îÄ‚îÄ dev/      (devices)
‚îú‚îÄ‚îÄ etc/      (configuration)
‚îú‚îÄ‚îÄ home/     (user directories)
‚îú‚îÄ‚îÄ proc/     (process info)
‚îú‚îÄ‚îÄ sys/      (system info)
‚îú‚îÄ‚îÄ tmp/      (temporary)
‚îú‚îÄ‚îÄ usr/      (user programs)
‚îî‚îÄ‚îÄ var/      (variable data)</code></pre>
<p><strong>Windows</strong> even adopted this (sort of):</p>
<pre><code>C:\
‚îú‚îÄ‚îÄ Program Files\
‚îú‚îÄ‚îÄ Users\
‚îú‚îÄ‚îÄ Windows\
‚îî‚îÄ‚îÄ ...</code></pre>
<h4 data-number="11.3.1.2" id="process-forkexec-model"><span class="header-section-number">11.3.1.2</span> 2. Process Fork/Exec
Model</h4>
<p>Every modern OS uses fork/exec or equivalent:</p>
<p><strong>PDP-7 Pattern:</strong></p>
<pre class="assembly"><code>" Fork child, exec new program
sys fork
   br parentcode   " parent continues here
   " child continues here
   sys exec; program; args</code></pre>
<p><strong>Linux C (2025):</strong></p>
<div class="sourceCode" id="cb923"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb923-1"><a aria-hidden="true" href="#cb923-1" tabindex="-1"></a><span class="co">/* Same pattern, 55 years later */</span></span>
<span id="cb923-2"><a aria-hidden="true" href="#cb923-2" tabindex="-1"></a>pid_t pid <span class="op">=</span> fork<span class="op">();</span></span>
<span id="cb923-3"><a aria-hidden="true" href="#cb923-3" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>pid <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb923-4"><a aria-hidden="true" href="#cb923-4" tabindex="-1"></a>    <span class="co">/* child */</span></span>
<span id="cb923-5"><a aria-hidden="true" href="#cb923-5" tabindex="-1"></a>    execve<span class="op">(</span><span class="st">"/bin/program"</span><span class="op">,</span> argv<span class="op">,</span> envp<span class="op">);</span></span>
<span id="cb923-6"><a aria-hidden="true" href="#cb923-6" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb923-7"><a aria-hidden="true" href="#cb923-7" tabindex="-1"></a>    <span class="co">/* parent */</span></span>
<span id="cb923-8"><a aria-hidden="true" href="#cb923-8" tabindex="-1"></a>    wait<span class="op">(&amp;</span>status<span class="op">);</span></span>
<span id="cb923-9"><a aria-hidden="true" href="#cb923-9" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Windows</strong> uses different API but same concept:</p>
<div class="sourceCode" id="cb924"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb924-1"><a aria-hidden="true" href="#cb924-1" tabindex="-1"></a>CreateProcess<span class="op">(</span><span class="st">"program.exe"</span><span class="op">,</span> args<span class="op">,</span> <span class="op">...);</span>  <span class="co">/* fork + exec combined */</span></span>
<span id="cb924-2"><a aria-hidden="true" href="#cb924-2" tabindex="-1"></a>WaitForSingleObject<span class="op">(</span>hProcess<span class="op">,</span> INFINITE<span class="op">);</span>  <span class="co">/* wait */</span></span></code></pre></div>
<h4 data-number="11.3.1.3" id="shell-as-separate-program"><span class="header-section-number">11.3.1.3</span> 3. Shell as Separate
Program</h4>
<p><strong>PDP-7 Philosophy:</strong> - Shell is just a user program -
Not part of kernel - Can be replaced with custom shell</p>
<p><strong>Modern Reality:</strong> - bash, zsh, fish, PowerShell‚Äîall
user programs - Kernel doesn‚Äôt care which shell you use - Multiple
shells can coexist</p>
<h4 data-number="11.3.1.4" id="text-based-tools"><span class="header-section-number">11.3.1.4</span> 4. Text-Based Tools</h4>
<p><strong>PDP-7 Unix Tools:</strong></p>
<pre><code>cat, cp, mv, rm, ls, ed, as, chmod, chown</code></pre>
<p><strong>Modern Unix Tools (virtually identical):</strong></p>
<div class="sourceCode" id="cb926"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb926-1"><a aria-hidden="true" href="#cb926-1" tabindex="-1"></a><span class="ex">$</span> cat file.txt           <span class="co"># Same command, 55 years later</span></span>
<span id="cb926-2"><a aria-hidden="true" href="#cb926-2" tabindex="-1"></a><span class="ex">$</span> cp source dest         <span class="co"># Same command</span></span>
<span id="cb926-3"><a aria-hidden="true" href="#cb926-3" tabindex="-1"></a><span class="ex">$</span> ls <span class="at">-l</span>                  <span class="co"># Same command</span></span>
<span id="cb926-4"><a aria-hidden="true" href="#cb926-4" tabindex="-1"></a><span class="ex">$</span> chmod 755 script.sh    <span class="co"># Same command</span></span></code></pre></div>
<p><strong>Tool Composition:</strong></p>
<p>PDP-7 concept (realized in V2 with pipes):</p>
<pre><code>Small tools ‚Üí compose via pipes ‚Üí complex operations</code></pre>
<p>Modern reality:</p>
<div class="sourceCode" id="cb928"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb928-1"><a aria-hidden="true" href="#cb928-1" tabindex="-1"></a><span class="co"># Process web server logs</span></span>
<span id="cb928-2"><a aria-hidden="true" href="#cb928-2" tabindex="-1"></a><span class="fu">cat</span> access.log <span class="kw">|</span></span>
<span id="cb928-3"><a aria-hidden="true" href="#cb928-3" tabindex="-1"></a>    <span class="fu">grep</span> <span class="st">"404"</span> <span class="kw">|</span></span>
<span id="cb928-4"><a aria-hidden="true" href="#cb928-4" tabindex="-1"></a>    <span class="fu">awk</span> <span class="st">'{print $7}'</span> <span class="kw">|</span></span>
<span id="cb928-5"><a aria-hidden="true" href="#cb928-5" tabindex="-1"></a>    <span class="fu">sort</span> <span class="kw">|</span></span>
<span id="cb928-6"><a aria-hidden="true" href="#cb928-6" tabindex="-1"></a>    <span class="fu">uniq</span> <span class="at">-c</span> <span class="kw">|</span></span>
<span id="cb928-7"><a aria-hidden="true" href="#cb928-7" tabindex="-1"></a>    <span class="fu">sort</span> <span class="at">-nr</span> <span class="kw">|</span></span>
<span id="cb928-8"><a aria-hidden="true" href="#cb928-8" tabindex="-1"></a>    <span class="fu">head</span> <span class="at">-10</span></span></code></pre></div>
<h3 data-number="11.3.2" id="modern-implementations-whats-the-same-what-evolved"><span class="header-section-number">11.3.2</span> Modern Implementations:
What‚Äôs the Same, What Evolved</h3>
<h4 data-number="11.3.2.1" id="how-linux-implements-fork-today"><span class="header-section-number">11.3.2.1</span> How Linux Implements
fork() Today</h4>
<p><strong>PDP-7 fork() (simplified):</strong></p>
<pre class="assembly"><code>.fork:
   " 1. Find empty process slot
   jms lookfor; 0

   " 2. Assign new PID
   isz uniqpid
   lac uniqpid
   dac u.ac

   " 3. Copy parent memory to disk
   jms save

   " 4. Set up child state
   " (child starts after fork instruction)

   " 5. Return to parent (child PID in AC)
   "    and to child (0 in AC)</code></pre>
<p><strong>Linux fork() (simplified):</strong></p>
<div class="sourceCode" id="cb930"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb930-1"><a aria-hidden="true" href="#cb930-1" tabindex="-1"></a><span class="dt">long</span> do_fork<span class="op">(</span><span class="dt">unsigned</span> <span class="dt">long</span> clone_flags<span class="op">,</span> <span class="op">...)</span></span>
<span id="cb930-2"><a aria-hidden="true" href="#cb930-2" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb930-3"><a aria-hidden="true" href="#cb930-3" tabindex="-1"></a>    <span class="kw">struct</span> task_struct <span class="op">*</span>p<span class="op">;</span></span>
<span id="cb930-4"><a aria-hidden="true" href="#cb930-4" tabindex="-1"></a>    <span class="dt">int</span> pid<span class="op">;</span></span>
<span id="cb930-5"><a aria-hidden="true" href="#cb930-5" tabindex="-1"></a></span>
<span id="cb930-6"><a aria-hidden="true" href="#cb930-6" tabindex="-1"></a>    <span class="co">/* 1. Allocate child process descriptor */</span></span>
<span id="cb930-7"><a aria-hidden="true" href="#cb930-7" tabindex="-1"></a>    p <span class="op">=</span> alloc_task_struct<span class="op">();</span></span>
<span id="cb930-8"><a aria-hidden="true" href="#cb930-8" tabindex="-1"></a></span>
<span id="cb930-9"><a aria-hidden="true" href="#cb930-9" tabindex="-1"></a>    <span class="co">/* 2. Copy parent's task_struct to child */</span></span>
<span id="cb930-10"><a aria-hidden="true" href="#cb930-10" tabindex="-1"></a>    copy_process<span class="op">(</span>current<span class="op">,</span> p<span class="op">);</span></span>
<span id="cb930-11"><a aria-hidden="true" href="#cb930-11" tabindex="-1"></a></span>
<span id="cb930-12"><a aria-hidden="true" href="#cb930-12" tabindex="-1"></a>    <span class="co">/* 3. Allocate new PID */</span></span>
<span id="cb930-13"><a aria-hidden="true" href="#cb930-13" tabindex="-1"></a>    pid <span class="op">=</span> alloc_pidmap<span class="op">();</span></span>
<span id="cb930-14"><a aria-hidden="true" href="#cb930-14" tabindex="-1"></a></span>
<span id="cb930-15"><a aria-hidden="true" href="#cb930-15" tabindex="-1"></a>    <span class="co">/* 4. Copy-on-write memory setup */</span></span>
<span id="cb930-16"><a aria-hidden="true" href="#cb930-16" tabindex="-1"></a>    <span class="co">/*    DON'T actually copy - share pages,</span></span>
<span id="cb930-17"><a aria-hidden="true" href="#cb930-17" tabindex="-1"></a><span class="co">          mark read-only, copy on first write */</span></span>
<span id="cb930-18"><a aria-hidden="true" href="#cb930-18" tabindex="-1"></a>    copy_mm<span class="op">(</span>clone_flags<span class="op">,</span> p<span class="op">);</span></span>
<span id="cb930-19"><a aria-hidden="true" href="#cb930-19" tabindex="-1"></a></span>
<span id="cb930-20"><a aria-hidden="true" href="#cb930-20" tabindex="-1"></a>    <span class="co">/* 5. Set child's return value to 0 */</span></span>
<span id="cb930-21"><a aria-hidden="true" href="#cb930-21" tabindex="-1"></a>    <span class="co">/*    Parent's return value is child PID */</span></span>
<span id="cb930-22"><a aria-hidden="true" href="#cb930-22" tabindex="-1"></a>    p<span class="op">-&gt;</span>thread<span class="op">.</span>ax <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>  <span class="co">/* child returns 0 */</span></span>
<span id="cb930-23"><a aria-hidden="true" href="#cb930-23" tabindex="-1"></a></span>
<span id="cb930-24"><a aria-hidden="true" href="#cb930-24" tabindex="-1"></a>    <span class="co">/* 6. Add to scheduler */</span></span>
<span id="cb930-25"><a aria-hidden="true" href="#cb930-25" tabindex="-1"></a>    wake_up_new_task<span class="op">(</span>p<span class="op">);</span></span>
<span id="cb930-26"><a aria-hidden="true" href="#cb930-26" tabindex="-1"></a></span>
<span id="cb930-27"><a aria-hidden="true" href="#cb930-27" tabindex="-1"></a>    <span class="cf">return</span> pid<span class="op">;</span>  <span class="co">/* parent returns child PID */</span></span>
<span id="cb930-28"><a aria-hidden="true" href="#cb930-28" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Key Evolution:</strong> - <strong>Copy-on-write</strong>:
Don‚Äôt copy memory until needed (PDP-7 copied everything) -
<strong>Threads</strong>: clone() supports threads (shared memory) -
<strong>Namespaces</strong>: Isolated process trees (containers) -
<strong>cgroups</strong>: Resource limits per process group</p>
<p>But the <strong>fundamental model is identical</strong>: fork creates
child as copy of parent, returns twice (parent gets child PID, child
gets 0).</p>
<h4 data-number="11.3.2.2" id="modern-file-systems-vs.-pdp-7"><span class="header-section-number">11.3.2.2</span> Modern File Systems
vs.¬†PDP-7</h4>
<p><strong>PDP-7 File System:</strong></p>
<pre><code>- 16-bit inode numbers (65,536 max files)
- 8 direct block pointers per inode
- No indirect blocks
- No symbolic links
- Simple directory structure (name ‚Üí inode)
- 512-word blocks (1,152 bytes)</code></pre>
<p><strong>ext4 (Linux) File System:</strong></p>
<pre><code>- 32-bit inode numbers (4 billion+ files)
- 12 direct blocks + indirect + double indirect + triple indirect
- Extents (ranges of blocks) for large files
- Symbolic links, hard links
- Directory indexing (htree) for fast lookup
- Variable block sizes (1KB to 64KB)
- Journaling for crash recovery
- Extended attributes (metadata)</code></pre>
<p><strong>APFS (Apple) File System:</strong></p>
<pre><code>- 64-bit inode numbers
- Copy-on-write (never modify in place)
- Snapshots (instant backups)
- Encryption built-in
- Space sharing between volumes
- Atomic operations</code></pre>
<p><strong>What Stayed the Same:</strong> - <strong>Inode
concept</strong>: Metadata separate from data - <strong>Directory
structure</strong>: Name ‚Üí inode mapping - <strong>Hierarchical
organization</strong>: Tree of directories - <strong>Permissions
model</strong>: User/group/other (evolved)</p>
<h4 data-number="11.3.2.3" id="system-calls-evolution-from-26-to-300"><span class="header-section-number">11.3.2.3</span> System Calls: Evolution
from 26 to 300+</h4>
<p><strong>PDP-7 Unix: 26 System Calls</strong></p>
<pre><code>Core I/O:     open, close, read, write, seek, creat
Process:      fork, exec, exit, wait
File system:  link, unlink, chdir, mkdir, mknod
Permissions:  chmod, chown
Special:      rele, smdate, wait, smes, rmes</code></pre>
<p><strong>Linux: 300+ System Calls</strong></p>
<pre><code>Original 26:  Still present (mostly compatible)

Networking:   socket, bind, listen, accept, connect, send, recv
              (50+ network-related calls)

Memory:       mmap, munmap, mprotect, madvise
              brk, sbrk (memory allocation)

Threads:      clone, futex, set_tid_address
              (20+ thread-related calls)

Timers:       nanosleep, timer_create, timer_settime
              (15+ time-related calls)

Security:     setuid, setgid, capabilities, seccomp
              (30+ security calls)

Modern I/O:   epoll, select, poll, io_uring
              sendfile, splice (zero-copy I/O)

Containers:   unshare, setns (namespace management)

And 150+ more...</code></pre>
<p><strong>Backward Compatibility:</strong></p>
<p>PDP-7-era code concepts still work:</p>
<div class="sourceCode" id="cb936"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb936-1"><a aria-hidden="true" href="#cb936-1" tabindex="-1"></a><span class="co">/* This 1970s-style code still compiles and runs */</span></span>
<span id="cb936-2"><a aria-hidden="true" href="#cb936-2" tabindex="-1"></a><span class="dt">int</span> fd <span class="op">=</span> open<span class="op">(</span><span class="st">"file.txt"</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb936-3"><a aria-hidden="true" href="#cb936-3" tabindex="-1"></a><span class="dt">char</span> buf<span class="op">[</span><span class="dv">512</span><span class="op">];</span></span>
<span id="cb936-4"><a aria-hidden="true" href="#cb936-4" tabindex="-1"></a><span class="dt">int</span> n <span class="op">=</span> read<span class="op">(</span>fd<span class="op">,</span> buf<span class="op">,</span> <span class="dv">512</span><span class="op">);</span></span>
<span id="cb936-5"><a aria-hidden="true" href="#cb936-5" tabindex="-1"></a>write<span class="op">(</span><span class="dv">1</span><span class="op">,</span> buf<span class="op">,</span> n<span class="op">);</span>  <span class="co">/* fd 1 = stdout */</span></span>
<span id="cb936-6"><a aria-hidden="true" href="#cb936-6" tabindex="-1"></a>close<span class="op">(</span>fd<span class="op">);</span></span></code></pre></div>
<h2 data-number="11.4" id="cultural-impact-1"><span class="header-section-number">11.4</span> 14.4 Cultural Impact</h2>
<p>Unix didn‚Äôt just change technology‚Äîit changed how we think about
software.</p>
<h3 data-number="11.4.1" id="the-unix-philosophy"><span class="header-section-number">11.4.1</span> The Unix Philosophy</h3>
<p><strong>Articulated by Doug McIlroy (Bell Labs, 1978):</strong></p>
<blockquote>
<ol type="1">
<li><p><strong>Make each program do one thing well.</strong> To do a new
job, build afresh rather than complicate old programs by adding new
features.</p></li>
<li><p><strong>Expect the output of every program to become the input to
another</strong>, as yet unknown, program. Don‚Äôt clutter output with
extraneous information. Avoid stringently columnar or binary input
formats. Don‚Äôt insist on interactive input.</p></li>
<li><p><strong>Design and build software, even operating systems, to be
tried early</strong>, ideally within weeks. Don‚Äôt hesitate to throw away
the clumsy parts and rebuild them.</p></li>
<li><p><strong>Use tools in preference to unskilled help</strong> to
lighten a programming task, even if you have to detour to build the
tools and expect to throw some of them out after you‚Äôve finished using
them.</p></li>
</ol>
</blockquote>
<p><strong>In Practice:</strong></p>
<div class="sourceCode" id="cb937"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb937-1"><a aria-hidden="true" href="#cb937-1" tabindex="-1"></a><span class="co"># Each tool does one thing well</span></span>
<span id="cb937-2"><a aria-hidden="true" href="#cb937-2" tabindex="-1"></a><span class="ex">$</span> ls          <span class="co"># List files (that's all)</span></span>
<span id="cb937-3"><a aria-hidden="true" href="#cb937-3" tabindex="-1"></a><span class="ex">$</span> grep        <span class="co"># Search text (that's all)</span></span>
<span id="cb937-4"><a aria-hidden="true" href="#cb937-4" tabindex="-1"></a><span class="ex">$</span> sort        <span class="co"># Sort lines (that's all)</span></span>
<span id="cb937-5"><a aria-hidden="true" href="#cb937-5" tabindex="-1"></a><span class="ex">$</span> uniq        <span class="co"># Remove duplicates (that's all)</span></span>
<span id="cb937-6"><a aria-hidden="true" href="#cb937-6" tabindex="-1"></a><span class="ex">$</span> wc          <span class="co"># Count lines/words/bytes (that's all)</span></span>
<span id="cb937-7"><a aria-hidden="true" href="#cb937-7" tabindex="-1"></a></span>
<span id="cb937-8"><a aria-hidden="true" href="#cb937-8" tabindex="-1"></a><span class="co"># Compose together for complex operations</span></span>
<span id="cb937-9"><a aria-hidden="true" href="#cb937-9" tabindex="-1"></a><span class="ex">$</span> ls <span class="at">-l</span> <span class="kw">|</span> <span class="fu">grep</span> <span class="st">"\.txt$"</span> <span class="kw">|</span> <span class="fu">wc</span> <span class="at">-l</span></span>
<span id="cb937-10"><a aria-hidden="true" href="#cb937-10" tabindex="-1"></a><span class="co"># How many .txt files?</span></span>
<span id="cb937-11"><a aria-hidden="true" href="#cb937-11" tabindex="-1"></a></span>
<span id="cb937-12"><a aria-hidden="true" href="#cb937-12" tabindex="-1"></a><span class="ex">$</span> cat logfile <span class="kw">|</span> <span class="fu">grep</span> ERROR <span class="kw">|</span> <span class="fu">sort</span> <span class="kw">|</span> <span class="fu">uniq</span> <span class="at">-c</span> <span class="kw">|</span> <span class="fu">sort</span> <span class="at">-nr</span></span>
<span id="cb937-13"><a aria-hidden="true" href="#cb937-13" tabindex="-1"></a><span class="co"># Count and rank error messages</span></span></code></pre></div>
<p>Compare to <strong>monolithic approach</strong>:</p>
<div class="sourceCode" id="cb938"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb938-1"><a aria-hidden="true" href="#cb938-1" tabindex="-1"></a><span class="co"># Hypothetical monolithic tool</span></span>
<span id="cb938-2"><a aria-hidden="true" href="#cb938-2" tabindex="-1"></a><span class="ex">$</span> super-log-analyzer <span class="at">--file</span><span class="op">=</span>logfile <span class="at">--filter</span><span class="op">=</span>ERROR <span class="at">--unique</span> <span class="at">--count</span> <span class="at">--sort</span><span class="op">=</span>descending</span></code></pre></div>
<p>The Unix approach is more flexible: you can combine tools in infinite
ways.</p>
<h3 data-number="11.4.2" id="worse-is-better-vs.-the-right-thing"><span class="header-section-number">11.4.2</span> ‚ÄúWorse is Better‚Äù vs.¬†‚ÄúThe
Right Thing‚Äù</h3>
<p><strong>Richard Gabriel (1991)</strong> contrasted Unix‚Äôs design
philosophy with MIT‚Äôs:</p>
<p><strong>MIT/Lisp ‚ÄúThe Right Thing‚Äù:</strong> - Completeness: System
must be complete and correct - Consistency: Design must be consistent
above all - Correctness: Never sacrifice correctness for simplicity -
Perfection: Get it right, even if it takes years</p>
<p><strong>Unix ‚ÄúWorse is Better‚Äù:</strong> - Simplicity: Implementation
should be simple - Get it working: Ship something that works, even if
incomplete - Iterate: Improve based on real-world use - Pragmatism:
Practical solutions over theoretical perfection</p>
<p><strong>Example:</strong></p>
<p>MIT approach (Multics):</p>
<pre><code>- Comprehensive security model (rings of protection)
- Full virtual memory (segments)
- Dynamic linking
- Built-in database (file system as database)
- Took years to develop
- Very complex</code></pre>
<p>Unix approach:</p>
<pre><code>- Simple security (user/group/other)
- Basic file system (inodes + data)
- Static linking initially
- Plain files, not database
- Working system in months
- Very simple</code></pre>
<p><strong>Result</strong>: Unix shipped and iterated. Multics never
achieved widespread adoption. ‚ÄúWorse is better‚Äù
<strong>won</strong>.</p>
<p>But Unix <strong>evolved</strong> toward ‚Äúthe right thing‚Äù over time:
- Added virtual memory (BSD) - Added networking (BSD) - Added dynamic
linking (System V) - Added sophisticated security (SELinux)</p>
<p>The key: <strong>ship early, iterate, improve based on real
use</strong>.</p>
<h3 data-number="11.4.3" id="how-this-shaped-software-engineering"><span class="header-section-number">11.4.3</span> How This Shaped Software
Engineering</h3>
<p><strong>Unix Philosophy Influenced:</strong></p>
<p><strong>Python (1991):</strong></p>
<div class="sourceCode" id="cb941"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb941-1"><a aria-hidden="true" href="#cb941-1" tabindex="-1"></a><span class="co"># "There should be one-- and preferably only one --obvious way to do it"</span></span>
<span id="cb941-2"><a aria-hidden="true" href="#cb941-2" tabindex="-1"></a><span class="co"># Simple, readable, composable</span></span>
<span id="cb941-3"><a aria-hidden="true" href="#cb941-3" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb941-4"><a aria-hidden="true" href="#cb941-4" tabindex="-1"></a><span class="cf">for</span> line <span class="kw">in</span> sys.stdin:</span>
<span id="cb941-5"><a aria-hidden="true" href="#cb941-5" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">"ERROR"</span> <span class="kw">in</span> line:</span>
<span id="cb941-6"><a aria-hidden="true" href="#cb941-6" tabindex="-1"></a>        <span class="bu">print</span>(line)</span></code></pre></div>
<p><strong>Go (2009):</strong></p>
<div class="sourceCode" id="cb942"><pre class="sourceCode go"><code class="sourceCode go"><span id="cb942-1"><a aria-hidden="true" href="#cb942-1" tabindex="-1"></a><span class="co">// Simple, orthogonal features</span></span>
<span id="cb942-2"><a aria-hidden="true" href="#cb942-2" tabindex="-1"></a><span class="co">// Composition over inheritance</span></span>
<span id="cb942-3"><a aria-hidden="true" href="#cb942-3" tabindex="-1"></a><span class="co">// Tools for specific jobs (gofmt, govet)</span></span></code></pre></div>
<p><strong>Rust (2010):</strong></p>
<div class="sourceCode" id="cb943"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb943-1"><a aria-hidden="true" href="#cb943-1" tabindex="-1"></a><span class="co">// Composable traits</span></span>
<span id="cb943-2"><a aria-hidden="true" href="#cb943-2" tabindex="-1"></a><span class="co">// Cargo build tool (like make)</span></span>
<span id="cb943-3"><a aria-hidden="true" href="#cb943-3" tabindex="-1"></a><span class="co">// Small, focused standard library</span></span></code></pre></div>
<p><strong>Modern DevOps:</strong></p>
<div class="sourceCode" id="cb944"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb944-1"><a aria-hidden="true" href="#cb944-1" tabindex="-1"></a><span class="co"># Unix philosophy in containerized world</span></span>
<span id="cb944-2"><a aria-hidden="true" href="#cb944-2" tabindex="-1"></a><span class="ex">$</span> docker run alpine ls    <span class="co"># Container does one thing</span></span>
<span id="cb944-3"><a aria-hidden="true" href="#cb944-3" tabindex="-1"></a><span class="ex">$</span> kubectl apply <span class="at">-f</span> config.yaml <span class="kw">|</span> <span class="fu">grep</span> Running</span>
<span id="cb944-4"><a aria-hidden="true" href="#cb944-4" tabindex="-1"></a><span class="co"># Compose tools via pipes, even in cloud era</span></span></code></pre></div>
<h3 data-number="11.4.4" id="the-open-source-movement"><span class="header-section-number">11.4.4</span> The Open Source
Movement</h3>
<p>Unix‚Äôs openness‚Äîeven partial, academic openness‚Äîset crucial
precedent.</p>
<h4 data-number="11.4.4.1" id="academic-unix-licenses-1970s"><span class="header-section-number">11.4.4.1</span> Academic Unix Licenses
(1970s)</h4>
<p><strong>AT&amp;T Academic License:</strong> - Source code provided -
Can modify for research - Can‚Äôt redistribute commercially - Tiny fee
($200 for universities)</p>
<p>This created: - <strong>Educated programmers</strong>: Generation
learned OS internals - <strong>Collaborative culture</strong>:
Universities shared improvements - <strong>Innovation</strong>: Research
fed back into Unix</p>
<h4 data-number="11.4.4.2" id="bsd-license-1980s"><span class="header-section-number">11.4.4.2</span> BSD License (1980s)</h4>
<p><strong>Berkeley‚Äôs Free Software:</strong> - Use for any purpose -
Modify freely - Redistribute freely - Commercial use allowed - No
copyleft restrictions</p>
<p><strong>Impact:</strong> - TCP/IP stack: Universal - Utilities:
Spread everywhere - Commercial adoption: Companies built businesses on
BSD</p>
<h4 data-number="11.4.4.3" id="gnu-project-1983"><span class="header-section-number">11.4.4.3</span> GNU Project (1983)</h4>
<p><strong>Richard Stallman‚Äôs Vision:</strong> - Unix-like system,
completely free - GNU‚Äôs Not Unix (GNU) - GPL license (copyleft) - Free
software philosophy</p>
<p><strong>GNU Tools:</strong></p>
<pre><code>gcc - C compiler
bash - Bourne Again Shell
emacs - Editor
gdb - Debugger
make, tar, gzip, etc.</code></pre>
<p>Combined with Linux kernel (1991) ‚Üí <strong>GNU/Linux</strong>, the
most successful free software platform.</p>
<h4 data-number="11.4.4.4" id="linux-and-the-gpl-1991"><span class="header-section-number">11.4.4.4</span> Linux and the GPL
(1991)</h4>
<p><strong>Linus Torvalds‚Äô Choice:</strong> - GPL license (not BSD) -
Must share improvements - Prevented proprietary forks - Created
collaborative ecosystem</p>
<p><strong>Result:</strong> - <strong>Thousands of contributors</strong>
- <strong>Hundreds of companies</strong> (Red Hat, IBM, Google, etc.) -
<strong>Millions of lines</strong> of free software - <strong>Powers
most of the internet</strong></p>
<h4 data-number="11.4.4.5" id="how-pdp-7-unixs-openness-set-precedent"><span class="header-section-number">11.4.4.5</span> How PDP-7 Unix‚Äôs Openness
Set Precedent</h4>
<p>Without PDP-7 Unix‚Äôs ‚Äúsemi-openness‚Äù: - No student access to source
code - No university modifications - No collaborative culture - No BSD -
No GNU - No Linux - <strong>Completely different computing
landscape</strong></p>
<p>Thompson and Ritchie‚Äôs decision to share Unix with universities‚Äîeven
under restrictive licenses‚Äîplanted seeds that grew into the open source
movement.</p>
<h3 data-number="11.4.5" id="software-engineering-practices"><span class="header-section-number">11.4.5</span> Software Engineering
Practices</h3>
<p>Unix introduced practices now universal:</p>
<h4 data-number="11.4.5.1" id="man-pages-documentation-culture"><span class="header-section-number">11.4.5.1</span> Man Pages: Documentation
Culture</h4>
<p><strong>Unix Manual (1971):</strong></p>
<pre><code>NAME
     cat - concatenate and print files

SYNOPSIS
     cat file ...

DESCRIPTION
     Cat reads each file in sequence and writes it on the standard output.</code></pre>
<p><strong>Still standard today:</strong></p>
<div class="sourceCode" id="cb947"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb947-1"><a aria-hidden="true" href="#cb947-1" tabindex="-1"></a><span class="ex">$</span> man cat      <span class="co"># Same format, 50+ years later</span></span>
<span id="cb947-2"><a aria-hidden="true" href="#cb947-2" tabindex="-1"></a><span class="ex">$</span> man fork</span>
<span id="cb947-3"><a aria-hidden="true" href="#cb947-3" tabindex="-1"></a><span class="ex">$</span> man anything</span></code></pre></div>
<p><strong>Influence:</strong> - Every Unix command documented -
Standard format (NAME, SYNOPSIS, DESCRIPTION, EXAMPLES) - Always
available - Searchable (man -k keyword)</p>
<p>Modern equivalents: <code>--help</code>, online docs, but <strong>man
pages still dominant in Unix/Linux world</strong>.</p>
<h4 data-number="11.4.5.2" id="version-control-evolution"><span class="header-section-number">11.4.5.2</span> Version Control
Evolution</h4>
<p><strong>SCCS (Source Code Control System, 1972):</strong></p>
<div class="sourceCode" id="cb948"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb948-1"><a aria-hidden="true" href="#cb948-1" tabindex="-1"></a><span class="ex">$</span> sccs create file.c     <span class="co"># Start tracking</span></span>
<span id="cb948-2"><a aria-hidden="true" href="#cb948-2" tabindex="-1"></a><span class="ex">$</span> sccs edit file.c       <span class="co"># Check out for editing</span></span>
<span id="cb948-3"><a aria-hidden="true" href="#cb948-3" tabindex="-1"></a><span class="ex">$</span> sccs delget file.c     <span class="co"># Check in changes</span></span>
<span id="cb948-4"><a aria-hidden="true" href="#cb948-4" tabindex="-1"></a><span class="ex">$</span> sccs prs file.c        <span class="co"># Show history</span></span></code></pre></div>
<p><strong>RCS (Revision Control System, 1982):</strong></p>
<div class="sourceCode" id="cb949"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb949-1"><a aria-hidden="true" href="#cb949-1" tabindex="-1"></a><span class="ex">$</span> ci <span class="at">-l</span> file.c           <span class="co"># Check in, keep lock</span></span>
<span id="cb949-2"><a aria-hidden="true" href="#cb949-2" tabindex="-1"></a><span class="ex">$</span> co <span class="at">-l</span> file.c           <span class="co"># Check out with lock</span></span>
<span id="cb949-3"><a aria-hidden="true" href="#cb949-3" tabindex="-1"></a><span class="ex">$</span> rlog file.c            <span class="co"># Show log</span></span></code></pre></div>
<p><strong>CVS (Concurrent Versions System, 1986):</strong></p>
<div class="sourceCode" id="cb950"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb950-1"><a aria-hidden="true" href="#cb950-1" tabindex="-1"></a><span class="ex">$</span> cvs checkout project   <span class="co"># Get project</span></span>
<span id="cb950-2"><a aria-hidden="true" href="#cb950-2" tabindex="-1"></a><span class="ex">$</span> cvs update            <span class="co"># Get latest</span></span>
<span id="cb950-3"><a aria-hidden="true" href="#cb950-3" tabindex="-1"></a><span class="ex">$</span> cvs commit            <span class="co"># Send changes</span></span></code></pre></div>
<p><strong>Git (2005):</strong></p>
<div class="sourceCode" id="cb951"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb951-1"><a aria-hidden="true" href="#cb951-1" tabindex="-1"></a><span class="ex">$</span> git clone repo        <span class="co"># Get project</span></span>
<span id="cb951-2"><a aria-hidden="true" href="#cb951-2" tabindex="-1"></a><span class="ex">$</span> git pull              <span class="co"># Get latest</span></span>
<span id="cb951-3"><a aria-hidden="true" href="#cb951-3" tabindex="-1"></a><span class="ex">$</span> git commit            <span class="co"># Record changes</span></span>
<span id="cb951-4"><a aria-hidden="true" href="#cb951-4" tabindex="-1"></a><span class="ex">$</span> git push              <span class="co"># Send changes</span></span></code></pre></div>
<p><strong>Progression:</strong> - SCCS: Single file, locked editing -
RCS: Better branching, still locked - CVS: Concurrent editing, merging -
Git: Distributed, branching cheap, offline work</p>
<p>But <strong>core concept from Unix era</strong>: track changes,
review history, collaborate.</p>
<h4 data-number="11.4.5.3" id="collaborative-development"><span class="header-section-number">11.4.5.3</span> Collaborative
Development</h4>
<p><strong>Unix Development Model (1970s Bell Labs):</strong> - Small
team (Thompson, Ritchie, McIlroy, Ossanna, ~10 core people) - Shared
code - Peer review (informal) - Rapid iteration - Meritocracy (best
ideas win)</p>
<p><strong>Modern Open Source:</strong> - Large teams (Linux: 10,000+
contributors) - Shared code (GitHub, GitLab) - Peer review (pull
requests, code review) - Continuous integration - Meritocracy
(maintainer trust)</p>
<p><strong>Same principles, larger scale</strong>.</p>
<h4 data-number="11.4.5.4" id="the-hacker-culture"><span class="header-section-number">11.4.5.4</span> The Hacker Culture</h4>
<p>Unix created <strong>hacker culture</strong> (positive sense):</p>
<p><strong>Values:</strong> - Technical excellence - Cleverness and
elegance - Sharing knowledge - Meritocracy - Hands-on learning -
Question authority - Build cool stuff</p>
<p><strong>Artifacts:</strong> - Jargon File / Hacker Dictionary -
.signature files - Easter eggs in software - Hackers (Steven Levy, 1984)
- The Cathedral and the Bazaar (Eric Raymond, 1997)</p>
<p>Unix was <strong>the hacker‚Äôs operating system</strong>‚Äîpowerful,
flexible, rewarding expertise.</p>
<h2 data-number="11.5" id="market-impact"><span class="header-section-number">11.5</span> 14.5 Market Impact</h2>
<p>Unix transformed entire industries.</p>
<h3 data-number="11.5.1" id="the-minicomputer-era-1970s"><span class="header-section-number">11.5.1</span> The Minicomputer Era
(1970s)</h3>
<p><strong>Market Transformation:</strong></p>
<p><strong>Before Unix (1960s):</strong> - Mainframes: $1-10 million -
Proprietary OSes: Tied to hardware - Batch processing: Submit jobs, wait
hours/days - Specialists: Operators, programmers separate - Vendor
lock-in: Can‚Äôt switch vendors</p>
<p><strong>With Unix (1970s):</strong> - Minicomputers: $10,000-100,000
- Portable OS: Runs on multiple vendors‚Äô hardware - Interactive:
Real-time response - Programmers: Direct access to machine - Some
portability: Move between Unix systems</p>
<p><strong>DEC‚Äôs Dominance:</strong> - PDP-11 series: Best-selling
minicomputer - Unix: Killer app for PDP-11 - VAX series: Scaled Unix to
32-bit - Market share: DEC #2 computer company (after IBM) by 1980</p>
<h3 data-number="11.5.2" id="the-workstation-era-1980s"><span class="header-section-number">11.5.2</span> The Workstation Era
(1980s)</h3>
<p>Unix enabled the <strong>engineering workstation</strong> market:</p>
<h4 data-number="11.5.2.1" id="sun-microsystems-1982-2010"><span class="header-section-number">11.5.2.1</span> Sun Microsystems
(1982-2010)</h4>
<p><strong>‚ÄúThe network is the computer‚Äù</strong></p>
<p>Founded by Bill Joy (BSD), Andreas Bechtolsheim, Vinod Khosla, Scott
McNealy.</p>
<p><strong>Sun‚Äôs Innovation:</strong> - <strong>SunOS
(BSD-based)</strong>: Networked Unix - <strong>NFS (Network File
System)</strong>: Transparent remote files - <strong>SPARC</strong>:
High-performance RISC CPU - <strong>Workstations</strong>: Graphics,
networking, Unix</p>
<p><strong>Market Impact:</strong> - Dominated CAD/CAM: Engineers
designing cars, chips, buildings - Dominated scientific computing - Web
servers: Sun dominated .com era - Peak: $5 billion revenue, 40,000
employees - Acquired by Oracle (2010) for $7.4 billion</p>
<h4 data-number="11.5.2.2" id="silicon-graphics-sgi-1982-2009"><span class="header-section-number">11.5.2.2</span> Silicon Graphics (SGI)
(1982-2009)</h4>
<p><strong>IRIX Unix</strong> + powerful graphics hardware</p>
<p><strong>Markets:</strong> - 3D graphics: Movies (Industrial Light
&amp; Magic used SGI) - Scientific visualization - Virtual reality</p>
<p><strong>Cultural Impact:</strong> - Jurassic Park: ‚ÄúIt‚Äôs a Unix
system! I know this!‚Äù - Every 1990s sci-fi movie: Unix workstations
everywhere - Netscape Navigator: Developed on SGI workstations</p>
<h4 data-number="11.5.2.3" id="next-1985-1996"><span class="header-section-number">11.5.2.3</span> NeXT (1985-1996)</h4>
<p><strong>Steve Jobs‚Äô Unix Workstation Company</strong></p>
<p><strong>NeXTSTEP OS:</strong> - Mach microkernel + BSD Unix -
Objective-C - Display PostScript - Object-oriented frameworks</p>
<p><strong>Legacy:</strong> - World Wide Web: Tim Berners-Lee created
the web on NeXT - macOS: NeXTSTEP became OS X (2001) - iOS: Based on OS
X - <strong>Billions of devices run NeXT‚Äôs Unix descendant</strong></p>
<h3 data-number="11.5.3" id="the-server-era-1990s-present"><span class="header-section-number">11.5.3</span> The Server Era
(1990s-present)</h3>
<h4 data-number="11.5.3.1" id="unix-dominating-servers"><span class="header-section-number">11.5.3.1</span> Unix Dominating
Servers</h4>
<p><strong>1990s Server Market:</strong></p>
<pre><code>Operating System    Market Share (1998)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Unix (various)      ~40%
Windows NT          ~35%
NetWare             ~15%
Other               ~10%</code></pre>
<p><strong>Unix Variants:</strong> - Solaris (Sun): Web servers,
databases - AIX (IBM): Enterprise, mainframe integration - HP-UX (HP):
Business-critical applications - IRIX (SGI): Scientific computing</p>
<p><strong>‚ÄúNo one ever got fired for buying Unix‚Äù</strong>
(paraphrasing IBM saying)</p>
<h4 data-number="11.5.3.2" id="the-dot-com-boom-1995-2000"><span class="header-section-number">11.5.3.2</span> The Dot-Com Boom
(1995-2000)</h4>
<p><strong>Unix powered the internet boom:</strong></p>
<p><strong>Web Servers:</strong> - Apache: Unix/Linux only (initially) -
Netscape servers: Solaris, IRIX - Yahoo: FreeBSD - Google: Linux (from
start)</p>
<p><strong>Databases:</strong> - Oracle: Solaris, AIX, HP-UX - Informix:
Unix only - Sybase: Unix only</p>
<p><strong>E-commerce:</strong> - eBay: Sun Solaris - Amazon: Unix
initially, then Linux</p>
<h4 data-number="11.5.3.3" id="linux-takeover-2000-present"><span class="header-section-number">11.5.3.3</span> Linux Takeover
(2000-present)</h4>
<p><strong>Linux vs.¬†Commercial Unix:</strong></p>
<pre><code>Year    Commercial Unix    Linux        Windows
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
2000    40%               10%          50%
2005    25%               25%          50%
2010    15%               35%          50%
2015     5%               60%          35%
2020     2%               70%          28%
2025    &lt;1%               75%+         &lt;25%</code></pre>
<p><strong>Why Linux Won:</strong> - <strong>Free</strong>: No licensing
costs - <strong>Open source</strong>: Fix bugs yourself - <strong>Vendor
neutral</strong>: Not tied to one company - <strong>Commodity
hardware</strong>: Run on cheap x86 servers -
<strong>Community</strong>: Thousands of developers</p>
<p><strong>Commercial Unix Survivors:</strong> - AIX: IBM mainframe
integration - Solaris: Oracle database optimization - HP-UX: Legacy
enterprise systems</p>
<p><strong>But Linux dominates</strong>: AWS, Google Cloud, Azure all
run mostly Linux.</p>
<h4 data-number="11.5.3.4" id="cloud-computing-built-on-linux"><span class="header-section-number">11.5.3.4</span> Cloud Computing Built on
Linux</h4>
<p><strong>Modern Cloud (2025):</strong></p>
<p><strong>Amazon Web Services (AWS):</strong> - EC2 instances: ~90%
Linux - Amazon Linux: Custom distribution - Lambda: Linux containers</p>
<p><strong>Google Cloud:</strong> - Compute Engine: Mostly Linux - GKE
(Kubernetes): Linux containers - Google‚Äôs internal servers: Custom
Linux</p>
<p><strong>Microsoft Azure:</strong> - ~60% of VMs run Linux - Windows
Server: ~40% - Even Microsoft runs more Linux than Windows in cloud!</p>
<p><strong>Infrastructure:</strong> - Docker containers: Linux -
Kubernetes orchestration: Linux - CI/CD pipelines: Linux - Most web
servers: Linux (Apache, nginx)</p>
<p><strong>The irony</strong>: Microsoft, which fought Unix for decades,
now: - Runs more Linux than Windows in Azure - Contributes to Linux
kernel - Created WSL (Windows Subsystem for Linux) - Owns GitHub (where
Linux is developed)</p>
<h3 data-number="11.5.4" id="the-mobile-era-2000s-present"><span class="header-section-number">11.5.4</span> The Mobile Era
(2000s-present)</h3>
<h4 data-number="11.5.4.1" id="the-numbers"><span class="header-section-number">11.5.4.1</span> The Numbers</h4>
<p><strong>Unix-derived mobile OS market:</strong></p>
<pre><code>Operating System  Market Share (2025)  Unix Ancestry
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Android           ~70%                 Linux kernel
iOS               ~27%                 BSD via Darwin
Other             ~3%                  Various</code></pre>
<p><strong>Total devices:</strong> - Android: ~3 billion active devices
(Linux) - iOS: ~2 billion active devices (BSD) - <strong>5+ billion
Unix-derived devices</strong></p>
<p>Every modern smartphone runs an operating system descended from PDP-7
Unix.</p>
<h4 data-number="11.5.4.2" id="ios-bsd-in-your-pocket"><span class="header-section-number">11.5.4.2</span> iOS: BSD in Your
Pocket</h4>
<p><strong>Darwin ‚Üí iOS:</strong></p>
<pre><code>PDP-7 Unix (1969)
  ‚Üí BSD Unix (1977)
    ‚Üí NeXTSTEP (1989)
      ‚Üí Mac OS X (2001)
        ‚Üí iOS (2007)</code></pre>
<p><strong>iOS Kernel (XNU):</strong></p>
<div class="sourceCode" id="cb956"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb956-1"><a aria-hidden="true" href="#cb956-1" tabindex="-1"></a><span class="co">/* XNU = "X is Not Unix" (but actually, it is) */</span></span>
<span id="cb956-2"><a aria-hidden="true" href="#cb956-2" tabindex="-1"></a><span class="op">-</span> Mach microkernel <span class="op">(</span>CMU<span class="op">,</span> <span class="dv">1985</span><span class="op">)</span></span>
<span id="cb956-3"><a aria-hidden="true" href="#cb956-3" tabindex="-1"></a><span class="op">-</span> BSD subsystem <span class="op">(</span>FreeBSD code<span class="op">)</span></span>
<span id="cb956-4"><a aria-hidden="true" href="#cb956-4" tabindex="-1"></a><span class="op">-</span> I<span class="op">/</span>O Kit <span class="op">(</span>drivers<span class="op">)</span></span></code></pre></div>
<p><strong>Unix Features in iOS:</strong> - File system: HFS+ ‚Üí APFS
(hierarchical) - Processes: fork/exec model (restricted) - Permissions:
User/group (sandboxed) - Networking: BSD sockets - Shell: bash/zsh
(accessible via jailbreak)</p>
<h4 data-number="11.5.4.3" id="android-linux-in-your-pocket"><span class="header-section-number">11.5.4.3</span> Android: Linux in Your
Pocket</h4>
<p><strong>Android Architecture:</strong></p>
<pre><code>Applications (Java/Kotlin)
  ‚Üì
Android Framework
  ‚Üì
Native Libraries (C/C++)
  ‚Üì
Linux Kernel (modified)</code></pre>
<p><strong>Linux Kernel Modifications:</strong> - Binder: IPC mechanism
- Ashmem: Shared memory - Wakelocks: Power management - Low Memory
Killer: OOM handling</p>
<p><strong>But fundamentally Linux:</strong></p>
<div class="sourceCode" id="cb958"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb958-1"><a aria-hidden="true" href="#cb958-1" tabindex="-1"></a><span class="co"># Android Debug Bridge shell</span></span>
<span id="cb958-2"><a aria-hidden="true" href="#cb958-2" tabindex="-1"></a><span class="ex">$</span> adb shell</span>
<span id="cb958-3"><a aria-hidden="true" href="#cb958-3" tabindex="-1"></a><span class="ex">android:/</span> $ uname <span class="at">-a</span></span>
<span id="cb958-4"><a aria-hidden="true" href="#cb958-4" tabindex="-1"></a><span class="ex">Linux</span> localhost 5.10.107-android13 <span class="co">#1 SMP PREEMPT ...</span></span>
<span id="cb958-5"><a aria-hidden="true" href="#cb958-5" tabindex="-1"></a></span>
<span id="cb958-6"><a aria-hidden="true" href="#cb958-6" tabindex="-1"></a><span class="ex">android:/</span> $ ps</span>
<span id="cb958-7"><a aria-hidden="true" href="#cb958-7" tabindex="-1"></a><span class="ex">USER</span>       PID  PPID VSIZE  RSS  WCHAN    PC  NAME</span>
<span id="cb958-8"><a aria-hidden="true" href="#cb958-8" tabindex="-1"></a><span class="ex">root</span>         1     0  14104 2156 SyS_epoll_wait S /init</span>
<span id="cb958-9"><a aria-hidden="true" href="#cb958-9" tabindex="-1"></a><span class="ex">root</span>       123     1  15204 3248 binder_thread_read S /system/bin/servicemanager</span>
<span id="cb958-10"><a aria-hidden="true" href="#cb958-10" tabindex="-1"></a><span class="ex">...</span></span></code></pre></div>
<p><strong>Unix DNA everywhere</strong>: processes, file system,
permissions, sockets, pipes‚Äîall there, just packaged differently.</p>
<h2 data-number="11.6" id="educational-impact"><span class="header-section-number">11.6</span> 14.6 Educational Impact</h2>
<h3 data-number="11.6.1" id="unix-in-computer-science-education"><span class="header-section-number">11.6.1</span> Unix in Computer Science
Education</h3>
<p>Unix became <strong>the teaching OS</strong>:</p>
<p><strong>Why Unix for Education:</strong> 1. <strong>Source code
available</strong>: Study real implementation 2. <strong>Small enough to
understand</strong>: Not millions of lines 3. <strong>Complete
system</strong>: All OS concepts present 4. <strong>Widely
used</strong>: Industry-relevant skill 5. <strong>Free
(eventually)</strong>: No license barriers for students</p>
<h4 data-number="11.6.1.1" id="operating-systems-textbooks"><span class="header-section-number">11.6.1.1</span> Operating Systems
Textbooks</h4>
<p><strong>Classic Texts Using Unix:</strong></p>
<p><strong>‚ÄúOperating System Concepts‚Äù (Silberschatz, Galvin,
Gagne):</strong> - First edition: 1983 - 10+ editions through 2018 -
Standard OS textbook - Uses Unix/Linux examples throughout</p>
<p><strong>‚ÄúModern Operating Systems‚Äù (Andrew Tanenbaum):</strong> -
First edition: 1992 - 4+ editions through 2014 - Created MINIX as
teaching tool - Linus Torvalds learned OS concepts from this book</p>
<p><strong>‚ÄúThe Design of the Unix Operating System‚Äù (Maurice
Bach):</strong> - 1986 - Detailed System V internals - Source code
walkthroughs - Classic reference</p>
<p><strong>‚ÄúLions‚Äô Commentary on UNIX 6th Edition‚Äù (John
Lions):</strong> - 1977 (republished 1996) - Line-by-line kernel
commentary - Most photocopied CS document ever - Educated generation of
OS developers</p>
<h4 data-number="11.6.1.2" id="minix-educational-unix"><span class="header-section-number">11.6.1.2</span> MINIX: Educational
Unix</h4>
<p><strong>Andrew Tanenbaum (1987):</strong></p>
<pre><code>MINIX = Mini-Unix
- Microkernel design
- ~12,000 lines of C
- Included with "Operating Systems" textbook
- Students could modify and experiment
- Source code explained in book</code></pre>
<p><strong>Impact:</strong> - Hundreds of universities used MINIX for OS
courses - Linus Torvalds learned from MINIX - Influenced Linux design
(and famous Tanenbaum-Torvalds debate)</p>
<p><strong>The Debate (1992):</strong></p>
<p>Tanenbaum: &gt; ‚ÄúLinux is obsolete‚Ä¶ a monolithic [kernel] in 1991 is
fundamentally wrong.‚Äù</p>
<p>Torvalds: &gt; ‚ÄúYour job is being a professor and researcher‚Ä¶ My job
is to provide the best OS as possible.‚Äù</p>
<p><strong>Result</strong>: Both were right in their contexts. MINIX was
better for teaching, Linux was better for production. Both descended
from Unix ideas.</p>
<h4 data-number="11.6.1.3" id="linux-as-teaching-tool"><span class="header-section-number">11.6.1.3</span> Linux as Teaching
Tool</h4>
<p><strong>Modern OS Education:</strong> - Most universities: Linux
kernel projects - Students: Build modules, modify scheduler, implement
file systems - Online courses: MIT OCW, Stanford CS140, etc. - Open
source: Students contribute to real projects</p>
<p><strong>Advantages over older Unix:</strong> - Free: No licensing
issues - Modern: Current technology - Active: Real-world development -
Documented: Massive documentation available</p>
<h3 data-number="11.6.2" id="this-pdp-7-code-as-historical-artifact"><span class="header-section-number">11.6.2</span> This PDP-7 Code as
Historical Artifact</h3>
<p><strong>The PDP-7 Unix source represents:</strong></p>
<ol type="1">
<li><strong>Genesis</strong>: Where it all started</li>
<li><strong>Simplicity</strong>: Before decades of feature
additions</li>
<li><strong>Clarity</strong>: Core concepts in pure form</li>
<li><strong>Historical</strong>: How programming was done</li>
<li><strong>Educational</strong>: Learn from masters</li>
</ol>
<p><strong>What Students Learn from PDP-7 Unix:</strong> - How an OS
really works (no abstractions hiding complexity) - Assembly language and
low-level programming - Design principles (simplicity, orthogonality) -
Historical context (how we got here) - Appreciation for modern tools (we
have it easy now!)</p>
<h2 data-number="11.7" id="economic-impact"><span class="header-section-number">11.7</span> 14.7 Economic Impact</h2>
<p>Unix‚Äôs economic impact is staggering.</p>
<h3 data-number="11.7.1" id="companies-built-on-unix"><span class="header-section-number">11.7.1</span> Companies Built on Unix</h3>
<p><strong>Major Unix-Based Companies:</strong></p>
<pre><code>Company          Founded  Peak Value    Unix Role
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Sun Microsystems 1982     $200B (2000)  SunOS/Solaris
Silicon Graphics 1982     $7B (1995)    IRIX
NeXT             1985     $429M (1996)  NeXTSTEP ‚Üí macOS
Apple            1976     $3T (2024)    macOS/iOS (BSD)
Google           1998     $2T (2024)    Linux (servers, Android)
Red Hat          1993     $34B (2019)   Enterprise Linux
Oracle           1977     $200B (2024)  Acquired Sun, Solaris
IBM              1911     $155B (2024)  AIX, bought Red Hat</code></pre>
<p><strong>Hundreds More:</strong> - Netflix: FreeBSD for CDN -
WhatsApp: FreeBSD for messaging - Amazon: Linux for AWS - Facebook:
Linux for infrastructure - Twitter: Linux for services - Every major web
company: Unix/Linux</p>
<h3 data-number="11.7.2" id="market-valuations"><span class="header-section-number">11.7.2</span> Market Valuations</h3>
<p><strong>Unix-Derived Technology Market Cap (2024
estimates):</strong></p>
<pre><code>Apple (iOS/macOS)           $3.0 trillion
Google (Android/Cloud)      $2.0 trillion
Amazon (AWS/Linux)          $1.8 trillion
Microsoft (Azure/Linux)     $3.0 trillion
Meta (Linux infra)          $900 billion
Oracle (Solaris/Linux)      $200 billion
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Total                       $11 trillion+</code></pre>
<p><strong>Not all of this is Unix</strong>, but Unix/Linux is
fundamental infrastructure for all these companies.</p>
<h3 data-number="11.7.3" id="jobs-created"><span class="header-section-number">11.7.3</span> Jobs Created</h3>
<p><strong>Direct Unix/Linux Jobs (2024 estimates):</strong></p>
<pre><code>Category                     Jobs (approximate)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Linux system administrators  2,000,000+
DevOps engineers (Linux)     1,500,000+
Android developers           5,000,000+
iOS developers               3,000,000+
Embedded Linux engineers     1,000,000+
Kernel developers            50,000+
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Total                        12,500,000+</code></pre>
<p><strong>Indirect jobs</strong> (web developers, data scientists, etc.
using Unix/Linux infrastructure): tens of millions more.</p>
<h3 data-number="11.7.4" id="industries-enabled"><span class="header-section-number">11.7.4</span> Industries Enabled</h3>
<p>Unix/Linux enabled entire industries:</p>
<p><strong>1. The Internet (1990s-present)</strong> - Web servers:
Mostly Unix/Linux - DNS servers: BIND (Unix) - Email servers: sendmail,
postfix (Unix) - Without Unix: Internet would look very different</p>
<p><strong>2. Mobile Computing (2007-present)</strong> - iOS: 2 billion
devices - Android: 3 billion devices - Without Unix: Mobile revolution
delayed or different</p>
<p><strong>3. Cloud Computing (2006-present)</strong> - AWS, Google
Cloud, Azure: Built on Linux - Virtualization: Xen, KVM (Linux) -
Containers: Docker, Kubernetes (Linux) - Without Unix/Linux: Cloud
computing much harder/different</p>
<p><strong>4. Embedded Systems</strong> - Routers: Linux - Smart TVs:
Linux - Automotive: Linux (many systems) - IoT devices: Linux - Without
Unix: Embedded much more fragmented</p>
<p><strong>5. Scientific Computing</strong> - Supercomputers: 100% run
Linux (Top500 list) - Research: Most done on Unix/Linux -
Bioinformatics: Unix tools standard - Without Unix: Scientific progress
slower</p>
<p><strong>6. Entertainment</strong> - Movie VFX: Linux render farms -
Game servers: Linux - Streaming: Linux (Netflix, YouTube) - Without
Unix: Entertainment tech different</p>
<h3 data-number="11.7.5" id="estimated-total-economic-impact"><span class="header-section-number">11.7.5</span> Estimated Total Economic
Impact</h3>
<p><strong>Impossible to quantify exactly</strong>, but rough
estimate:</p>
<p><strong>Conservative Estimate:</strong> - Companies built on Unix:
$10+ trillion market cap - Jobs directly enabled: 10+ million -
Industries transformed: Internet, mobile, cloud, embedded - Time saved:
Billions of person-hours (developer productivity) - Revenue enabled:
Trillions of dollars annually</p>
<p><strong>Thompson and Ritchie‚Äôs 8,000 lines of code</strong> ‚Üí
<strong>one of the highest-ROI software projects in
history</strong>.</p>
<h2 data-number="11.8" id="technical-debt-and-lessons"><span class="header-section-number">11.8</span> 14.8 Technical Debt and
Lessons</h2>
<p>Not everything from 1969 aged well. What can we learn?</p>
<h3 data-number="11.8.1" id="what-aged-well"><span class="header-section-number">11.8.1</span> What Aged Well</h3>
<h4 data-number="11.8.1.1" id="core-abstractions"><span class="header-section-number">11.8.1.1</span> 1. Core Abstractions</h4>
<p><strong>Still valid today:</strong> - <strong>Files as
abstraction</strong>: Devices, processes, network connections‚Äîall files
- <strong>Hierarchical namespace</strong>: Directories and paths -
<strong>Process model</strong>: fork/exec, parent/child relationships -
<strong>System calls</strong>: Clean separation between user and kernel
- <strong>Text streams</strong>: Universal data format</p>
<p><strong>These concepts are eternal</strong>‚Äîthey‚Äôll likely still be
valid in 2069.</p>
<h4 data-number="11.8.1.2" id="design-simplicity"><span class="header-section-number">11.8.1.2</span> 2. Design Simplicity</h4>
<p><strong>PDP-7 Unix Philosophy:</strong> - Simple mechanisms -
General-purpose tools - Composition over monolithic design - Clear
interfaces</p>
<p><strong>Still best practice</strong>: - Microservices (composition) -
Unix philosophy in distributed systems - REST APIs (simple, stateless) -
Cloud-native (small, focused services)</p>
<h4 data-number="11.8.1.3" id="tool-composition-model"><span class="header-section-number">11.8.1.3</span> 3. Tool Composition
Model</h4>
<p><strong>1969 concept:</strong></p>
<pre><code>Small tools ‚Üí pipes ‚Üí complex operations</code></pre>
<p><strong>2025 reality:</strong></p>
<div class="sourceCode" id="cb964"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb964-1"><a aria-hidden="true" href="#cb964-1" tabindex="-1"></a><span class="co"># Same pattern, 55 years later</span></span>
<span id="cb964-2"><a aria-hidden="true" href="#cb964-2" tabindex="-1"></a><span class="fu">cat</span> data.json <span class="kw">|</span> <span class="ex">jq</span> <span class="st">'.results[]'</span> <span class="kw">|</span> <span class="fu">grep</span> <span class="st">"active"</span> <span class="kw">|</span> <span class="fu">wc</span> <span class="at">-l</span></span></code></pre></div>
<p><strong>Modern equivalent:</strong></p>
<div class="sourceCode" id="cb965"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb965-1"><a aria-hidden="true" href="#cb965-1" tabindex="-1"></a><span class="co"># Python: compose functions</span></span>
<span id="cb965-2"><a aria-hidden="true" href="#cb965-2" tabindex="-1"></a>result <span class="op">=</span> (</span>
<span id="cb965-3"><a aria-hidden="true" href="#cb965-3" tabindex="-1"></a>    load_data()</span>
<span id="cb965-4"><a aria-hidden="true" href="#cb965-4" tabindex="-1"></a>    <span class="op">|</span> filter_active</span>
<span id="cb965-5"><a aria-hidden="true" href="#cb965-5" tabindex="-1"></a>    <span class="op">|</span> transform</span>
<span id="cb965-6"><a aria-hidden="true" href="#cb965-6" tabindex="-1"></a>    <span class="op">|</span> aggregate</span>
<span id="cb965-7"><a aria-hidden="true" href="#cb965-7" tabindex="-1"></a>)</span></code></pre></div>
<p><strong>Kubernetes:</strong></p>
<div class="sourceCode" id="cb966"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb966-1"><a aria-hidden="true" href="#cb966-1" tabindex="-1"></a><span class="co"># Compose containers</span></span>
<span id="cb966-2"><a aria-hidden="true" href="#cb966-2" tabindex="-1"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> v1</span></span>
<span id="cb966-3"><a aria-hidden="true" href="#cb966-3" tabindex="-1"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> Pod</span></span>
<span id="cb966-4"><a aria-hidden="true" href="#cb966-4" tabindex="-1"></a><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb966-5"><a aria-hidden="true" href="#cb966-5" tabindex="-1"></a><span class="at">  </span><span class="fu">containers</span><span class="kw">:</span></span>
<span id="cb966-6"><a aria-hidden="true" href="#cb966-6" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> app</span></span>
<span id="cb966-7"><a aria-hidden="true" href="#cb966-7" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> myapp:latest</span></span>
<span id="cb966-8"><a aria-hidden="true" href="#cb966-8" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> sidecar</span></span>
<span id="cb966-9"><a aria-hidden="true" href="#cb966-9" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> logging:latest</span></span></code></pre></div>
<p><strong>Same principle, different scales</strong>.</p>
<h3 data-number="11.8.2" id="what-didnt-age-well"><span class="header-section-number">11.8.2</span> What Didn‚Äôt Age Well</h3>
<h4 data-number="11.8.2.1" id="no-memory-protection"><span class="header-section-number">11.8.2.1</span> 1. No Memory
Protection</h4>
<p><strong>PDP-7 Unix:</strong> - Any process could access any memory -
No protection between user/kernel - Bugs could crash entire system -
Security nightmare</p>
<p><strong>Modern systems:</strong> - MMU (Memory Management Unit)
required - Kernel/user separation enforced by hardware - Process
isolation mandatory - Virtual memory standard</p>
<p><strong>Lesson</strong>: Security can‚Äôt be bolted on; it must be
designed in.</p>
<h4 data-number="11.8.2.2" id="non-reentrant-code"><span class="header-section-number">11.8.2.2</span> 2. Non-Reentrant Code</h4>
<p><strong>PDP-7 Unix:</strong></p>
<pre class="assembly"><code>" Global variables everywhere
counter: 0

increment:
   lac counter
   add o1
   dac counter    " RACE CONDITION if interrupted!</code></pre>
<p><strong>Modern approach:</strong></p>
<div class="sourceCode" id="cb968"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb968-1"><a aria-hidden="true" href="#cb968-1" tabindex="-1"></a><span class="co">/* Thread-safe, reentrant */</span></span>
<span id="cb968-2"><a aria-hidden="true" href="#cb968-2" tabindex="-1"></a><span class="dt">int</span> increment<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>counter<span class="op">)</span> <span class="op">{</span></span>
<span id="cb968-3"><a aria-hidden="true" href="#cb968-3" tabindex="-1"></a>    <span class="cf">return</span> __atomic_add_fetch<span class="op">(</span>counter<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> __ATOMIC_SEQ_CST<span class="op">);</span></span>
<span id="cb968-4"><a aria-hidden="true" href="#cb968-4" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>PDP-7 had no threads</strong>, so reentrancy wasn‚Äôt a
concern. Modern systems must handle concurrency.</p>
<p><strong>Lesson</strong>: Assumptions about execution environment
change; design for concurrency even if not needed yet.</p>
<h4 data-number="11.8.2.3" id="limited-security-model"><span class="header-section-number">11.8.2.3</span> 3. Limited Security
Model</h4>
<p><strong>PDP-7 Unix Security:</strong> - User ID: Yes - Permissions:
Basic (user/other, later user/group/other) - No encryption - No
capabilities - No sandboxing - Trust all logged-in users</p>
<p><strong>Modern Security Needs:</strong> - Mandatory Access Control
(SELinux, AppArmor) - Capabilities (fine-grained permissions) -
Namespaces (containers, isolation) - Encryption (at rest, in transit) -
Sandboxing (app isolation) - Zero-trust architecture</p>
<p><strong>Lesson</strong>: 1969 security model insufficient for
internet-connected, adversarial environment. Security requirements
evolve.</p>
<h4 data-number="11.8.2.4" id="what-modern-systems-had-to-add"><span class="header-section-number">11.8.2.4</span> 4. What Modern Systems Had
to Add</h4>
<p><strong>Not in PDP-7 Unix, essential now:</strong></p>
<p><strong>Networking:</strong> - TCP/IP stack (BSD, 1983) - Sockets API
- Network protocols</p>
<p><strong>Concurrency:</strong> - Threads (POSIX threads, 1995) -
Thread synchronization (mutexes, semaphores) - Lockless data
structures</p>
<p><strong>Security:</strong> - Encrypted file systems - Mandatory
access control - Sandboxing - Secure boot</p>
<p><strong>Performance:</strong> - SMP (Symmetric MultiProcessing) -
NUMA (Non-Uniform Memory Access) - Scalability to 1000+ CPUs</p>
<p><strong>Reliability:</strong> - Journaling file systems - Redundancy
(RAID) - Hot-plug devices - Containerization</p>
<p><strong>PDP-7 Unix didn‚Äôt need these</strong>‚Äîbut they became
essential as computing evolved.</p>
<h3 data-number="11.8.3" id="lessons-for-today"><span class="header-section-number">11.8.3</span> Lessons for Today</h3>
<h4 data-number="11.8.3.1" id="the-value-of-simplicity"><span class="header-section-number">11.8.3.1</span> 1. The Value of
Simplicity</h4>
<p><strong>PDP-7 Unix: 8,000 lines</strong> - Comprehensible -
Debuggable - Maintainable - Portable (eventually)</p>
<p><strong>Modern Linux: 30+ million lines</strong> - Complex - Hard to
debug - Difficult to maintain - But feature-rich</p>
<p><strong>Trade-off</strong>: Features vs.¬†simplicity</p>
<p><strong>Lesson</strong>: <strong>Start simple. Add complexity only
when necessary. Preserve simplicity where possible.</strong></p>
<p><strong>Examples of simplicity preserved:</strong> - Go language:
Deliberately simple - SQLite: Minimalist database - Redis: Simple data
structures - nginx: Simple event model</p>
<h4 data-number="11.8.3.2" id="constraints-driving-innovation"><span class="header-section-number">11.8.3.2</span> 2. Constraints Driving
Innovation</h4>
<p><strong>PDP-7 Constraints:</strong> - 8K words of RAM - 18-bit
architecture - Slow DECtape storage</p>
<p><strong>Innovations from Constraints:</strong> - Extremely efficient
code - Inode/directory separation (save space) - Swap to disk (maximize
available memory) - Simple, orthogonal design (no room for
complexity)</p>
<p><strong>Modern Example:</strong> - <strong>SQLite</strong>: Designed
for embedded systems with constraints - <strong>Result</strong>: Most
deployed database (billions of instances) - <strong>Why</strong>:
Constraints forced excellent design</p>
<p><strong>Lesson</strong>: <strong>Don‚Äôt fear constraints. They force
creative solutions and excellent design.</strong></p>
<h4 data-number="11.8.3.3" id="long-term-thinking-in-design"><span class="header-section-number">11.8.3.3</span> 3. Long-Term Thinking in
Design</h4>
<p><strong>PDP-7 Design Decisions Still Valid:</strong> - Hierarchical
file system: 55+ years, still standard - Process model: 55+ years, still
standard - System call interface: 55+ years, still compatible -
Text-based tools: 55+ years, still dominant</p>
<p><strong>Bad Design is Hard to Fix:</strong> - C strings
(null-terminated): Security nightmare, but backwards compatibility
prevents change - Unix file permissions: Insufficient for modern
security, but can‚Äôt break compatibility - 32-bit time_t: Y2038 problem
looming</p>
<p><strong>Lesson</strong>: <strong>Design for the long term. APIs are
forever. Bad design persists for decades.</strong></p>
<p><strong>Good Examples:</strong> - Git: Well-designed data model,
scales beautifully - Unicode: Planned for future expansion - IPv6:
Learned from IPv4 limitations</p>
<h4 data-number="11.8.3.4" id="code-that-lasts-50-years"><span class="header-section-number">11.8.3.4</span> 4. Code That Lasts 50+
Years</h4>
<p><strong>What makes code last?</strong></p>
<ol type="1">
<li><strong>Simple, clear concepts</strong>: Easy to understand decades
later</li>
<li><strong>Stable interfaces</strong>: Backward compatibility
maintained</li>
<li><strong>Good documentation</strong>: Future maintainers can
learn</li>
<li><strong>Minimal dependencies</strong>: Less to break over time</li>
<li><strong>Solves real problems</strong>: Continues to be useful</li>
</ol>
<p><strong>PDP-7 Unix achieved all of these.</strong></p>
<p><strong>Lesson</strong>: <strong>Write code that others (including
future you) can understand. Simple, well-documented, solving real
problems.</strong></p>
<h2 data-number="11.9" id="the-preservation-effort"><span class="header-section-number">11.9</span> 14.9 The Preservation
Effort</h2>
<p>Why preserve 50+-year-old code? Because <strong>history
matters</strong>.</p>
<h3 data-number="11.9.1" id="the-unix-heritage-society"><span class="header-section-number">11.9.1</span> The Unix Heritage
Society</h3>
<h4 data-number="11.9.1.1" id="warren-toomey-and-tuhs"><span class="header-section-number">11.9.1.1</span> Warren Toomey and
TUHS</h4>
<p><strong>The Unix Heritage Society (TUHS):</strong> - Founded: ~1995 -
Mission: Preserve Unix history - Leader: Warren Toomey (Australia) -
Website: https://www.tuhs.org/</p>
<p><strong>Achievements:</strong> - Preserved ancient Unix source code
(V1-V7) - Documented Unix history - Lobbied for open-sourcing old Unix -
Created community of Unix historians - Rescued code from oblivion</p>
<h4 data-number="11.9.1.2" id="preserving-unix-history"><span class="header-section-number">11.9.1.2</span> Preserving Unix
History</h4>
<p><strong>Challenges:</strong> - Old printouts: Fading, fragile - Lost
media: DECtapes, disks unreadable - Forgotten knowledge: Original
authors aging/deceased - Legal issues: Who owns ancient code? -
Technical issues: Old formats, obsolete hardware</p>
<p><strong>Solutions:</strong> - <strong>Scanned printouts</strong>:
Digitize before they decay - <strong>OCR and manual correction</strong>:
Convert to text - <strong>Simulators</strong>: SIMH, E11‚Äîrun old
hardware virtually - <strong>Interviews</strong>: Recorded oral
histories - <strong>Legal work</strong>: Got Caldera/SCO to open-source
ancient Unix</p>
<h4 data-number="11.9.1.3" id="the-pdp7-unix-resurrection"><span class="header-section-number">11.9.1.3</span> The pdp7-unix
Resurrection</h4>
<p><strong>The PDP-7 Unix project:</strong></p>
<p><strong>2019: Unix 50th Anniversary</strong></p>
<p>Dennis Ritchie‚Äôs papers donated to Computer History Museum included
PDP-7 Unix printouts (~190 pages).</p>
<p><strong>The Team:</strong> - Warren Toomey (TUHS) - Volunteers from
Unix community - Computer historians</p>
<p><strong>The Process:</strong></p>
<ol type="1">
<li><strong>Scan printouts</strong> (Computer History Museum)</li>
<li><strong>OCR the text</strong> (extract assembly code)</li>
<li><strong>Manually correct errors</strong> (OCR isn‚Äôt perfect)</li>
<li><strong>Reconstruct file structure</strong> (determine which code
goes in which file)</li>
<li><strong>Build cross-assembler</strong> (PDP-7 assembler for modern
systems)</li>
<li><strong>Assemble code</strong> (create binary)</li>
<li><strong>Debug</strong> (fix OCR errors, missing code)</li>
<li><strong>Run in simulator</strong> (SIMH PDP-7 emulator)</li>
<li><strong>IT BOOTED!</strong> (June 2019)</li>
</ol>
<p><strong>The Result:</strong></p>
<p>PDP-7 Unix runs again, 50 years later. You can:</p>
<div class="sourceCode" id="cb969"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb969-1"><a aria-hidden="true" href="#cb969-1" tabindex="-1"></a><span class="co"># On modern Linux:</span></span>
<span id="cb969-2"><a aria-hidden="true" href="#cb969-2" tabindex="-1"></a><span class="ex">$</span> git clone https://github.com/DoctorWkt/pdp7-unix</span>
<span id="cb969-3"><a aria-hidden="true" href="#cb969-3" tabindex="-1"></a><span class="ex">$</span> cd pdp7-unix</span>
<span id="cb969-4"><a aria-hidden="true" href="#cb969-4" tabindex="-1"></a><span class="ex">$</span> make</span>
<span id="cb969-5"><a aria-hidden="true" href="#cb969-5" tabindex="-1"></a><span class="ex">$</span> ./simh/pdp7 unixv0.simh</span>
<span id="cb969-6"><a aria-hidden="true" href="#cb969-6" tabindex="-1"></a></span>
<span id="cb969-7"><a aria-hidden="true" href="#cb969-7" tabindex="-1"></a><span class="co"># PDP-7 Unix boots!</span></span>
<span id="cb969-8"><a aria-hidden="true" href="#cb969-8" tabindex="-1"></a><span class="ex">login:</span> root</span>
<span id="cb969-9"><a aria-hidden="true" href="#cb969-9" tabindex="-1"></a><span class="co">#</span></span></code></pre></div>
<p><strong>Historical Significance:</strong> - First time PDP-7 Unix ran
since ~1971 - Proves preservation is possible - Enables study of
original Unix - Inspires future preservation efforts</p>
<h4 data-number="11.9.1.4" id="making-history-accessible"><span class="header-section-number">11.9.1.4</span> Making History
Accessible</h4>
<p><strong>TUHS Provides:</strong> - Source code: V1-V7 Unix, BSD, etc.
- Documentation: Manuals, papers, notes - Simulators: Run ancient Unix -
Mailing list: Discuss Unix history - Archives: Preserve for future</p>
<p><strong>Anyone can study Unix history:</strong></p>
<div class="sourceCode" id="cb970"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb970-1"><a aria-hidden="true" href="#cb970-1" tabindex="-1"></a><span class="co"># Run Unix V6 (1975)</span></span>
<span id="cb970-2"><a aria-hidden="true" href="#cb970-2" tabindex="-1"></a><span class="ex">$</span> git clone https://github.com/simh/simh</span>
<span id="cb970-3"><a aria-hidden="true" href="#cb970-3" tabindex="-1"></a><span class="ex">$</span> cd simh</span>
<span id="cb970-4"><a aria-hidden="true" href="#cb970-4" tabindex="-1"></a><span class="ex">$</span> make pdp11</span>
<span id="cb970-5"><a aria-hidden="true" href="#cb970-5" tabindex="-1"></a><span class="ex">$</span> ./pdp11 unix_v6.ini</span>
<span id="cb970-6"><a aria-hidden="true" href="#cb970-6" tabindex="-1"></a><span class="co"># Unix V6 boots, login as root, explore!</span></span></code></pre></div>
<p><strong>Educational Value:</strong> - Students: See OS evolution -
Historians: Understand computing history - Programmers: Learn from
masters - Everyone: Appreciate how far we‚Äôve come</p>
<h3 data-number="11.9.2" id="running-pdp-7-unix-today"><span class="header-section-number">11.9.2</span> Running PDP-7 Unix
Today</h3>
<h4 data-number="11.9.2.1" id="simh-simulator"><span class="header-section-number">11.9.2.1</span> SIMH Simulator</h4>
<p><strong>SIMH: Computer History Simulation</strong> - Simulates
ancient computers - PDP-7, PDP-11, VAX, IBM 1401, etc. - Cycle-accurate
(ish) - Runs ancient software</p>
<p><strong>Running PDP-7 Unix:</strong></p>
<div class="sourceCode" id="cb971"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb971-1"><a aria-hidden="true" href="#cb971-1" tabindex="-1"></a><span class="ex">$</span> ./pdp7 pdp7.ini</span>
<span id="cb971-2"><a aria-hidden="true" href="#cb971-2" tabindex="-1"></a></span>
<span id="cb971-3"><a aria-hidden="true" href="#cb971-3" tabindex="-1"></a><span class="ex">PDP-7</span> simulator V4.0-0</span>
<span id="cb971-4"><a aria-hidden="true" href="#cb971-4" tabindex="-1"></a></span>
<span id="cb971-5"><a aria-hidden="true" href="#cb971-5" tabindex="-1"></a><span class="co"># Unix boots</span></span>
<span id="cb971-6"><a aria-hidden="true" href="#cb971-6" tabindex="-1"></a><span class="ex">@</span></span></code></pre></div>
<p><strong>You can:</strong> - Edit files (ed) - Compile programs (as.s)
- Run utilities (cat, cp, ls) - Experience 1969 computing</p>
<h4 data-number="11.9.2.2" id="actual-pdp-7-hardware"><span class="header-section-number">11.9.2.2</span> Actual PDP-7 Hardware</h4>
<p><strong>Living Computer Museum (Seattle)</strong> - Had working PDP-7
(until museum closed 2020) - Could run PDP-7 Unix on real hardware -
Historical computing events</p>
<p><strong>Other PDP-7s:</strong> - Very few survive (maybe 5-10
worldwide) - Museum pieces - Occasionally operational</p>
<p><strong>The experience:</strong> - Teletype terminal (clacky!) -
Toggle switches (front panel) - DECtape (slow!) - Ancient but
functional</p>
<h4 data-number="11.9.2.3" id="historical-computing-community"><span class="header-section-number">11.9.2.3</span> Historical Computing
Community</h4>
<p><strong>Communities:</strong> - TUHS (Unix Heritage Society) - SIMH
users - Vintage Computer Federation - Computer History Museum - Living
Computer Museum (closed but archived)</p>
<p><strong>Activities:</strong> - Preserve old software - Restore old
hardware - Document history - Share knowledge - Inspire new
generations</p>
<h4 data-number="11.9.2.4" id="why-it-matters"><span class="header-section-number">11.9.2.4</span> Why It Matters</h4>
<p><strong>‚ÄúThose who don‚Äôt know history are doomed to repeat
it.‚Äù</strong></p>
<p><strong>Studying historical systems teaches:</strong> - Design
principles (what worked, what didn‚Äôt) - Evolution of ideas (how we got
here) - Context (why decisions were made) - Fundamentals (stripped of
modern cruft) - Appreciation (how much progress we‚Äôve made)</p>
<p><strong>PDP-7 Unix is:</strong> - Small enough to understand
completely - Foundational (all modern Unix descends from it) -
Well-documented (now) - Runnable (via simulator) - Educational (teaches
OS fundamentals)</p>
<h2 data-number="11.10" id="conclusion-the-longest-lasting-code"><span class="header-section-number">11.10</span> 14.10 Conclusion: The
Longest-Lasting Code</h2>
<h3 data-number="11.10.1" id="perspective"><span class="header-section-number">11.10.1</span> Perspective</h3>
<p>Consider these numbers:</p>
<p><strong>Written</strong>: Summer/Fall 1969 <strong>First
boot</strong>: Late 1969 <strong>Still influencing systems</strong>:
2025 <strong>Duration of impact</strong>: <strong>56+ years and
counting</strong> <strong>No end in sight</strong>: Will likely
influence systems for decades more</p>
<p><strong>Few software projects last 5 years.</strong> <strong>Unix has
lasted 50+.</strong></p>
<p><strong>Why?</strong> - <strong>Elegant design</strong>: Simple,
powerful abstractions - <strong>Solves real problems</strong>: File
management, process control, I/O - <strong>Good enough</strong>: Not
perfect, but adequate and improvable - <strong>Portable</strong>: C
rewrite enabled adaptation to new hardware - <strong>Open
(eventually)</strong>: Sharing enabled evolution and improvement -
<strong>Right time</strong>: Minicomputer revolution needed good OS -
<strong>Right people</strong>: Thompson and Ritchie were geniuses</p>
<h3 data-number="11.10.2" id="the-thompson-and-ritchie-legacy"><span class="header-section-number">11.10.2</span> The Thompson and Ritchie
Legacy</h3>
<h4 data-number="11.10.2.1" id="turing-awards"><span class="header-section-number">11.10.2.1</span> Turing Awards</h4>
<p><strong>Ken Thompson: 1983 Turing Award</strong> &gt; ‚ÄúFor their
development of generic operating systems theory and specifically for the
implementation of the UNIX operating system.‚Äù</p>
<p><strong>Dennis Ritchie: 1983 Turing Award</strong> (shared with
Thompson) &gt; ‚ÄúFor their development of generic operating systems
theory and specifically for the implementation of the UNIX operating
system.‚Äù</p>
<p><strong>Additional Honors:</strong> - National Medal of Technology
(1998, USA) - Japan Prize (2011) - IEEE Richard W. Hamming Medal -
Numerous honorary doctorates</p>
<p><strong>Dennis Ritchie (1941-2011):</strong> &gt; ‚ÄúUnix is very
simple, it just needs a genius to understand its simplicity.‚Äù</p>
<p><strong>Ken Thompson (1943-present):</strong> &gt; ‚ÄúWhen in doubt,
use brute force.‚Äù &gt; ‚ÄúOne of my most productive days was throwing away
1000 lines of code.‚Äù</p>
<h4 data-number="11.10.2.2" id="lasting-influence"><span class="header-section-number">11.10.2.2</span> Lasting Influence</h4>
<p><strong>Thompson and Ritchie taught the world:</strong></p>
<ol type="1">
<li><strong>Simplicity is power</strong>: Simple systems are
understandable, maintainable, adaptable</li>
<li><strong>Composition over complexity</strong>: Small tools composed
beat large monoliths</li>
<li><strong>Portability matters</strong>: Write once, run anywhere (with
C rewrite)</li>
<li><strong>Share knowledge</strong>: Collaboration accelerates
progress</li>
<li><strong>Design for humans</strong>: Make the system pleasant to
use</li>
<li><strong>Iterate</strong>: Ship early, improve based on use</li>
</ol>
<p><strong>Their code influenced:</strong> - Every Unix/Linux developer
- Every C programmer - Every systems programmer - Every open-source
contributor - Billions of device users (unknowingly)</p>
<h4 data-number="11.10.2.3" id="simplicity-as-design-principle"><span class="header-section-number">11.10.2.3</span> Simplicity as Design
Principle</h4>
<p><strong>The PDP-7 Unix philosophy:</strong></p>
<blockquote>
<p><strong>‚ÄúDo one thing well.‚Äù</strong> <strong>‚ÄúKeep it
simple.‚Äù</strong> <strong>‚ÄúMake it work first, optimize later.‚Äù</strong>
<strong>‚ÄúWrite programs that write programs.‚Äù</strong> <strong>‚ÄúWorse is
better (ship and iterate).‚Äù</strong></p>
</blockquote>
<p><strong>Applied today:</strong> - Google: Simple search box, complex
backend - Apple: Simple user interface, complex engineering - Unix
tools: Each does one thing well - Modern APIs: REST (simple), not SOAP
(complex)</p>
<p><strong>The eternal lesson</strong>: <strong>Complexity is easy.
Simplicity is hard. Simplicity wins.</strong></p>
<h4 data-number="11.10.2.4" id="code-as-literature"><span class="header-section-number">11.10.2.4</span> Code as Literature</h4>
<p><strong>Donald Knuth: ‚ÄúLiterate Programming‚Äù</strong> &gt; ‚ÄúLet us
change our traditional attitude to the construction of programs: Instead
of imagining that our main task is to instruct a computer what to do,
let us concentrate rather on explaining to human beings what we want a
computer to do.‚Äù</p>
<p><strong>PDP-7 Unix code is literature:</strong> - Read to learn -
Study to understand - Appreciate the craft - Learn from masters</p>
<p><strong>Like reading Shakespeare:</strong> - Understand the language
(PDP-7 assembly) - Appreciate the artistry (elegant solutions) - Learn
the context (1969 constraints) - Apply the lessons (design
principles)</p>
<p><strong>Thompson and Ritchie were poet-programmers:</strong> - Every
line purposeful - No wasted words (instructions) - Elegant solutions to
hard problems - Art and engineering combined</p>
<h3 data-number="11.10.3" id="looking-forward"><span class="header-section-number">11.10.3</span> Looking Forward</h3>
<h4 data-number="11.10.3.1" id="unix-concepts-in-the-next-50-years"><span class="header-section-number">11.10.3.1</span> Unix Concepts in the Next
50 Years?</h4>
<p><strong>What will persist?</strong></p>
<p><strong>Likely to continue:</strong> - <strong>Hierarchical file
systems</strong>: Too useful to abandon - <strong>Process
model</strong>: Fork/exec or equivalent - <strong>Text streams</strong>:
Universal data exchange - <strong>Composition</strong>: Small pieces,
loosely joined - <strong>System calls</strong>: Kernel/user
separation</p>
<p><strong>Likely to evolve:</strong> - <strong>Security model</strong>:
Zero-trust, capability-based - <strong>Concurrency</strong>: Better than
threads - <strong>Distributed</strong>: Assume networked systems -
<strong>Persistence</strong>: Persistent memory changes everything -
<strong>Hardware</strong>: Quantum, neuromorphic, exotic
architectures</p>
<p><strong>But core Unix ideas will adapt</strong>: They‚Äôre too
fundamental to abandon entirely.</p>
<h4 data-number="11.10.3.2" id="what-will-finally-change"><span class="header-section-number">11.10.3.2</span> What Will Finally
Change?</h4>
<p><strong>Candidates for replacement:</strong></p>
<p><strong>1. File systems:</strong> - Current: Hierarchical trees -
Future: Databases? Object stores? Content-addressed? - Unix assumption:
May not hold</p>
<p><strong>2. Processes:</strong> - Current: Fork/exec, isolation -
Future: Lightweight isolates? Unikernels? WebAssembly? - Unix model: May
evolve significantly</p>
<p><strong>3. Text:</strong> - Current: Text streams, ASCII/UTF-8 -
Future: Structured data (JSON, Protocol Buffers)? - Unix tradition: May
become secondary</p>
<p><strong>4. Monolithic kernels:</strong> - Current: Large kernel
(Linux) - Future: Microkernels? Library OSes? Separation kernels? - Unix
architecture: Already being challenged</p>
<p><strong>But changes will be gradual</strong>: Backward compatibility
and installed base keep Unix concepts alive.</p>
<h4 data-number="11.10.3.3" id="the-immortality-of-good-ideas"><span class="header-section-number">11.10.3.3</span> The Immortality of Good
Ideas</h4>
<p><strong>Why Unix ideas persist:</strong></p>
<ol type="1">
<li><strong>Fundamentally sound</strong>: Based on solid computer
science</li>
<li><strong>Practical</strong>: Solve real problems efficiently</li>
<li><strong>Simple</strong>: Easy to understand and implement</li>
<li><strong>Flexible</strong>: Adapt to new contexts</li>
<li><strong>Proven</strong>: 50+ years of success</li>
</ol>
<p><strong>Good ideas don‚Äôt die‚Äîthey evolve:</strong> - Files ‚Üí objects
- Pipes ‚Üí streams - Processes ‚Üí containers - System calls ‚Üí APIs -
Terminals ‚Üí web browsers</p>
<p><strong>The idea persists even as implementation
changes.</strong></p>
<p><strong>Unix is immortal because:</strong> - <strong>It
works</strong> - <strong>It‚Äôs simple</strong> - <strong>It‚Äôs
everywhere</strong> - <strong>It solves real problems</strong> -
<strong>It adapts to new requirements</strong></p>
<h3 data-number="11.10.4" id="final-reflection-8000-lines-that-changed-the-world"><span class="header-section-number">11.10.4</span> Final Reflection: 8,000
Lines That Changed the World</h3>
<p>In 1969, Ken Thompson wrote approximately 8,000 lines of assembly
code on an obsolete PDP-7 minicomputer. He created: - A hierarchical
file system - A simple process model - A set of elegant abstractions - A
foundation for modern computing</p>
<p>Today, in 2025: - <strong>5+ billion smartphones</strong> run
Unix-derived operating systems - <strong>90%+ of servers</strong> run
Unix or Linux - <strong>100% of Top 500 supercomputers</strong> run
Linux - <strong>Every major cloud platform</strong> is built on Linux -
<strong>The entire internet</strong> runs primarily on Unix/Linux
infrastructure</p>
<p><strong>From 8,000 lines of code</strong> to <strong>the foundation
of modern civilization‚Äôs digital infrastructure</strong>.</p>
<p><strong>No other software has had comparable impact.</strong></p>
<p><strong>Thompson and Ritchie didn‚Äôt set out to change the
world</strong>‚Äîthey just wanted a better environment to write programs.
They needed: - A decent editor - An assembler - A file system - A simple
OS to host these tools</p>
<p>They built it with: - Minimal resources (8K words of RAM) - Obsolete
hardware (PDP-7) - No budget - No formal project approval - Just skill,
taste, and determination</p>
<p><strong>The result:</strong> - Unix - C language - Modern computing -
A legacy that will outlive us all</p>
<p><strong>The lesson:</strong> &gt; <strong>Good design lasts.</strong>
&gt; <strong>Simple solutions scale.</strong> &gt; <strong>Elegant code
is eternal.</strong> &gt; <strong>8,000 lines can change the
world.</strong></p>
<hr/>
<p><strong>Epilogue:</strong></p>
<p>When you use your smartphone, browse a website, stream a video, send
an email, or use any digital service, you are standing on the shoulders
of giants.</p>
<p>Somewhere in the stack‚Äîmaybe buried deep, maybe abstracted away‚Äîare
ideas that Ken Thompson and Dennis Ritchie created in 1969 on a PDP-7
minicomputer.</p>
<p><strong>Files. Processes. Directories. Text streams. Simple tools
composed together.</strong></p>
<p><strong>These ideas didn‚Äôt just influence computing‚Äîthey became
computing.</strong></p>
<p><strong>And it all started with 8,000 lines of assembly
code.</strong></p>
<p>Thank you, Ken. Thank you, Dennis.</p>
<p><strong>Your code lives forever.</strong></p>
<hr/>
<p><em>‚ÄúUnix is simple and coherent, but it takes a genius (or at any
rate a programmer) to understand and appreciate the simplicity.‚Äù</em> ‚Äî
Dennis Ritchie (1941-2011)</p>
<p><em>‚ÄúWhen in doubt, use brute force.‚Äù</em> ‚Äî Ken Thompson (1943-)</p>
<p><strong>The End</strong></p>
<hr/>
<h2 data-number="11.11" id="references-and-further-reading"><span class="header-section-number">11.11</span> References and Further
Reading</h2>
<p><strong>Historical Sources:</strong> - Thompson, K., &amp; Ritchie,
D. M. (1974). ‚ÄúThe UNIX Time-Sharing System.‚Äù <em>Communications of the
ACM</em>, 17(7), 365-375. - Ritchie, D. M. (1984). ‚ÄúThe Evolution of the
Unix Time-sharing System.‚Äù <em>AT&amp;T Bell Laboratories Technical
Journal</em>, 63(6), 1577-1593. - Salus, P. H. (1994). <em>A Quarter
Century of UNIX</em>. Addison-Wesley. - Raymond, E. S. (2003). <em>The
Art of Unix Programming</em>. Addison-Wesley.</p>
<p><strong>Technical References:</strong> - Lions, J. (1977). <em>Lions‚Äô
Commentary on UNIX 6th Edition</em>. (Republished 1996) - Bach, M. J.
(1986). <em>The Design of the UNIX Operating System</em>. Prentice Hall.
- McKusick, M. K., et al.¬†(1996). <em>The Design and Implementation of
the 4.4BSD Operating System</em>. Addison-Wesley.</p>
<p><strong>Online Resources:</strong> - Unix Heritage Society:
https://www.tuhs.org/ - PDP-7 Unix resurrection:
https://github.com/DoctorWkt/pdp7-unix - Computer History Museum:
https://computerhistory.org/ - The Evolution of the Unix Time-sharing
System: https://www.bell-labs.com/usr/dmr/www/</p>
<p><strong>Oral Histories:</strong> - Thompson and Ritchie interviews
(Computer History Museum) - Unix pioneers‚Äô oral histories (TUHS) - ‚ÄúThe
UNIX Oral History Project‚Äù (various sources)</p>
<h1 data-number="12" id="glossary"><span class="header-section-number">12</span> Glossary</h1>
</main>
</div>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2"></script>
<script>
  // Mobile TOC toggle
  function toggleTOC() {
    const tocContent = document.getElementById('toc-content');
    tocContent.classList.toggle('active');
  }

  // Close TOC when clicking a link on mobile
  document.querySelectorAll('#TOC a').forEach(link => {
    link.addEventListener('click', () => {
      if (window.innerWidth < 1024) {
        document.getElementById('toc-content').classList.remove('active');
      }
    });
  });

  // Smooth scrolling for anchor links
  document.querySelectorAll('a[href^="#"]').forEach(anchor => {
    anchor.addEventListener('click', function (e) {
      e.preventDefault();
      const target = document.querySelector(this.getAttribute('href'));
      if (target) {
        target.scrollIntoView({
          behavior: 'smooth',
          block: 'start'
        });
      }
    });
  });

  // Search functionality
  let searchIndex = [];
  let fuse = null;

  // Build search index from all headings and paragraphs
  function buildSearchIndex() {
    const content = document.querySelector('.book-content');
    const items = [];

    // Index all headings
    content.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach((heading, idx) => {
      const id = heading.id || `heading-`;
      if (!heading.id) heading.id = id;

      items.push({
        id: id,
        title: heading.textContent,
        content: heading.textContent,
        type: 'heading',
        level: heading.tagName
      });

      // Also index the paragraph after each heading for context
      let next = heading.nextElementSibling;
      if (next && (next.tagName === 'P' || next.tagName === 'DIV')) {
        items.push({
          id: id,
          title: heading.textContent,
          content: next.textContent.substring(0, 200),
          type: 'content',
          level: heading.tagName
        });
      }
    });

    // Index code blocks
    content.querySelectorAll('pre code').forEach((code, idx) => {
      const pre = code.closest('pre');
      const id = pre.id || `code-`;
      if (!pre.id) pre.id = id;

      items.push({
        id: id,
        title: 'Code: ' + code.textContent.substring(0, 50) + '...',
        content: code.textContent,
        type: 'code'
      });
    });

    searchIndex = items;

    // Initialize Fuse.js
    fuse = new Fuse(searchIndex, {
      keys: ['title', 'content'],
      threshold: 0.3,
      includeScore: true,
      minMatchCharLength: 2
    });
  }

  // Perform search
  function performSearch(query) {
    const resultsDiv = document.getElementById('search-results');

    if (!query || query.length < 2) {
      resultsDiv.innerHTML = '';
      resultsDiv.style.display = 'none';
      return;
    }

    const results = fuse.search(query);

    if (results.length === 0) {
      resultsDiv.innerHTML = '<div class="search-no-results">No results found</div>';
      resultsDiv.style.display = 'block';
      return;
    }

    // Display top 10 results
    const html = results.slice(0, 10).map(result => {
      const item = result.item;
      const typeIcon = item.type === 'heading' ? 'üìÑ' : item.type === 'code' ? 'üíª' : 'üìù';
      return '<a href="#' + item.id + '" class="search-result-item" onclick="closeSearchOnMobile()">' +
        '<span class="search-result-icon">' + typeIcon + '</span>' +
        '<span class="search-result-title">' + highlightMatch(item.title, query) + '</span>' +
        '</a>';
    }).join('');

    resultsDiv.innerHTML = html;
    resultsDiv.style.display = 'block';
  }

  // Highlight matching text
  function highlightMatch(text, query) {
    const regex = new RegExp('(' + query + ')', 'gi');
    return text.replace(regex, '<mark>$1</mark>');
  }

  // Close search results on mobile
  function closeSearchOnMobile() {
    if (window.innerWidth < 1024) {
      document.getElementById('search-results').style.display = 'none';
      document.getElementById('search-input').value = '';
      document.getElementById('toc-content').classList.remove('active');
    }
  }

  // Initialize search when page loads
  document.addEventListener('DOMContentLoaded', () => {
    buildSearchIndex();

    const searchInput = document.getElementById('search-input');
    searchInput.addEventListener('input', (e) => {
      performSearch(e.target.value);
    });

    // Close search results when clicking outside
    document.addEventListener('click', (e) => {
      const searchContainer = document.querySelector('.search-container');
      if (!searchContainer.contains(e.target)) {
        document.getElementById('search-results').style.display = 'none';
      }
    });
  });
</script>
</body>
</html>
